# This is "inform.mkscript", a script used to generate the makefile "makefile"
# at the root of the "inform" repository. This isn't for making any single
# executable, but for orchestrating build-like operations across the whole
# suite of tools included in that repository, so a lot of what it does is to
# run make recursively on subsidiary makefiles belonging to the individual tools.

# Do not edit "inform/makefile" directly. Instead, edit this script, and then
# rebuild "inform/makefile" with the command:

# ../inweb/Tangled/inweb -prototype scripts/inform.mkscript -makefile makefile

# (Note that typing "make makers" will remake all of the subsidiary makefiles
# inside the repository from their scripts, but _not_ this one: we don't want
# to have a makefile editing itself.)

# See the inweb manual for documentation on the *.mkscript file format, i.e.,
# the format in which this file is written. But it is essentially just a makefile
# with a number of special macro and loop features whose syntax involves braces
# { ... }, so anywhere that you see braces, you're looking at something special
# to *.mkscript; anything else is straightforward make syntax.

# -----------------------------------------------------------------------------

# Note that the resulting makefile expects to be used with the current working
# directory set to "inform". It should then usually be invoked with just "make".

# -----------------------------------------------------------------------------
# Platform (operating system) dependencies
# -----------------------------------------------------------------------------

# This tells Inweb to incorporate settings for your platform (macos, windows,
# linux, etc.), as set when Inweb was installed.

{platform-settings}

# There is, however, another piece of platform dependency. We want a makefile
# which is capable of "integrating" the Inform toolchain and other resources
# into a UI app (say, the MacOS "Inform.app"), which basically means copying
# a lot of files into place in some hierarchy somewhere. Those hierarchies
# have different locations and naming conventions on the different platforms;
# and the inform repository should not be the place to set those.

# So, then, each platform provides its own "make-integration-settings.mk" file,
# which - if used - should be placed in the directory just outside "inform".
# This is all optional, and command-line users need not have such a file:
# note that the make syntax "-include" means "load this file if it exists but
# continue without any errors if it does not".

# If the file does exist, it will define the symbol INTEGRATION, and make a
# set of other definitions as well, which we will make use of below.

-include ../make-integration-settings.mk

# Note that if you are an app-maker wanting to make a release build of your
# app, always "make" first, and then "make forceintegration". (This ensures
# all resources are copied from the repository into your app, and doesn't
# try to do anything clever about working out the minimum necessary copy.)

# -----------------------------------------------------------------------------
# Where to find webs in this repository
# -----------------------------------------------------------------------------
# The makefile needs to deal with many "literate programs" at various places
# in the repository. A sort of roster of these, called a "colony file", is here:

COLONY = colony.txt

# We will also make use of two webs outside the inform repository, from our
# sidekick projects intest and inweb, which must both also be installed in order
# to test and build inform:

INTEST = ../intest/Tangled/intest
INTESTX = ../intest/Tangled/intest
INTESTWEB = ../intest

INWEB = ../inweb/Tangled/inweb
INWEBX = ../inweb/Tangled/inweb
INWEBWEB = ../inweb

# But the inform repository creates many other webs itself, and those can be
# divided into three: tools (executable code), modules (used to make tools),
# and miscellaneous webs (making something other than executable code). These
# are collectively called "components" below, and we now declare them all,
# beginning with the modules.

{component type: module symbol: WORDS       webname: words       path: services/words-module       set: modules}
{component type: module symbol: SYNTAX      webname: syntax      path: services/syntax-module      set: modules}
{component type: module symbol: HTML        webname: html        path: services/html-module        set: modules}
{component type: module symbol: ARCH        webname: arch        path: services/arch-module        set: modules}
{component type: module symbol: INFLECTIONS webname: inflections path: services/inflections-module set: modules}
{component type: module symbol: LEXICON     webname: lexicon     path: services/lexicon-module     set: modules}
{component type: module symbol: LINGUISTICS webname: linguistics path: services/linguistics-module set: modules}
{component type: module symbol: PROBLEMS    webname: problems    path: services/problems-module    set: modules}
{component type: module symbol: KINDS       webname: kinds       path: services/kinds-module       set: modules}
{component type: module symbol: CALCULUS    webname: calculus    path: services/calculus-module    set: modules}

{component type: module symbol: CORE        webname: core        path: inform7/core-module         set: modules}
{component type: module symbol: ASSERTIONS  webname: assertions  path: inform7/assertions-module   set: modules}
{component type: module symbol: KNOWLEDGE   webname: knowledge   path: inform7/knowledge-module    set: modules}
{component type: module symbol: IMPERATIVE  webname: imperative  path: inform7/imperative-module   set: modules}
{component type: module symbol: RUNTIME     webname: runtime     path: inform7/runtime-module      set: modules}
{component type: module symbol: VALUES      webname: values      path: inform7/values-module       set: modules}
{component type: module symbol: IF          webname: if          path: inform7/if-module           set: modules}
{component type: module symbol: MULTIMEDIA  webname: multimedia  path: inform7/multimedia-module   set: modules}

{component type: module symbol: BYTECODE    webname: bytecode    path: inter/bytecode-module       set: modules}
{component type: module symbol: BUILDING    webname: building    path: inter/building-module       set: modules}
{component type: module symbol: PIPELINE    webname: pipeline    path: inter/pipeline-module       set: modules}
{component type: module symbol: FINAL       webname: final       path: inter/final-module          set: modules}
{component type: module symbol: INDEX       webname: index       path: inter/index-module          set: modules}

{component type: module symbol: SUPERVISOR  webname: supervisor  path: inbuild/supervisor-module   set: modules}

# Next the tools. Note that to each symbol (say, NAME) the following will write
# makefile variable definitions of NAMEWEB, its location; NAMEMAKER, the make
# file for the tool; and NAMEX, the actual executable which will be compiled.

# There are two sets here: the "ctools" are the compiler tools, all made from the
# same inform7 code-base but in different ways; the "otools" are other tools.

{component type: tool   symbol: INBLORB   webname: inblorb     path: inblorb   set: otools}
{component type: tool   symbol: INDOC     webname: indoc       path: indoc     set: otools}
{component type: tool   symbol: INFORM7   webname: inform7     path: inform7   set: ctools}
{component type: tool   symbol: INPOLICY  webname: inpolicy    path: inpolicy  set: otools}
{component type: tool   symbol: INRTPS    webname: inrtps      path: inrtps    set: otools}
{component type: tool   symbol: INBUILD   webname: inbuild     path: inbuild   set: ctools}
{component type: tool   symbol: INTER     webname: inter       path: inter     set: ctools}

# Because Inform 6 is not a web, we have to give it special treatment, and define
# its executable location INFORM6X manually. (The directory holding it will be
# called INFORM6WEB for consistency, even though it is not actually a web.)

INFORM6X = inform6/Tangled/inform6
INFORM6WEB = inform6

# The "utools" set of executables provides unit testing for modules:

{component type: tool   symbol: SYNTAXTEST      webname: syntax-test        path: services/syntax-test      set: utools}
{component type: tool   symbol: WORDSTEST       webname: words-test         path: services/words-test       set: utools}
{component type: tool   symbol: ARCHTEST        webname: arch-test          path: services/arch-test        set: utools}
{component type: tool   symbol: INFLECTIONSTEST webname: inflections-test   path: services/inflections-test set: utools}
{component type: tool   symbol: LINGUISTICSTEST webname: linguistics-test   path: services/linguistics-test set: utools}
{component type: tool   symbol: KINDSTEST       webname: kinds-test         path: services/kinds-test       set: utools}
{component type: tool   symbol: CALCULUSTEST    webname: calculus-test      path: services/calculus-test    set: utools}
{component type: tool   symbol: PROBLEMSTEST    webname: problems-test      path: services/problems-test    set: utools}

{component type: tool   symbol: BUILDINGTEST    webname: building-test      path: inter/building-test       set: utools}

# Then there are webs which make programs other than C executables: kits of Inter
# code and Inform 7 extensions.

{component type: web symbol: BASICINFORMKIT       webname: BasicInformKit       path: inform7/Internal/Inter/BasicInformKit       set: kits}
{component type: web symbol: ARCHITECTURE16KIT    webname: Architecture16Kit    path: inform7/Internal/Inter/Architecture16Kit    set: kits}
{component type: web symbol: ARCHITECTURE32KIT    webname: Architecture32Kit    path: inform7/Internal/Inter/Architecture32Kit    set: kits}
{component type: web symbol: WORLDMODELKIT        webname: WorldModelKit        path: inform7/Internal/Inter/WorldModelKit        set: kits}
{component type: web symbol: COMMANDPARSERKIT     webname: CommandParserKit     path: inform7/Internal/Inter/CommandParserKit     set: kits}
{component type: web symbol: ENGLISHLANGUAGEKIT   webname: EnglishLanguageKit   path: inform7/Internal/Inter/EnglishLanguageKit   set: kits}
{component type: web symbol: DIALOGUEKIT          webname: DialogueKit          path: inform7/Internal/Inter/DialogueKit          set: kits}

{component type: web symbol: STANDARDRULES        webname: standard_rules       path: inform7/extensions/standard_rules           set: extensions}
{component type: web symbol: BASICINFORM          webname: basic_inform         path: inform7/extensions/basic_inform             set: extensions}

# Those extensions, when tangled from these webs, will need to be placed here:

STANDARDRULESTANGLED = $(INFORM7WEB)/Internal/Extensions/Graham\ Nelson/Standard\ Rules.i7x
BASICINFORMTANGLED =   $(INFORM7WEB)/Internal/Extensions/Graham\ Nelson/Basic\ Inform.i7x

# -----------------------------------------------------------------------------
# Targets "all" and "force"
# -----------------------------------------------------------------------------
# "make all", the default target, incrementally makes the tools; "make force"
# makes everything, disregarding all timestamps on files. Note that neither
# one of these performs a "make integration", to push the results of our efforts
# into a surrounding GUI app (if it is present) - that must be done (if desired)
# by "make integration" explicitly.

.PHONY: all
all: tools kits extensions localintegration

.PHONY: force
force: forcetools forcekits forceextensions localintegration

# -----------------------------------------------------------------------------
# Target "localintegration"
# -----------------------------------------------------------------------------
# This is not the same thing as integration into a GUI app. It means taking the
# side-files tangled from the Inform 7 code base out of the inform7 web and
# into the places elsewhere in the repository where they are actually needed:

.PHONY: localintegration
localintegration: \
	$(INFORM7WEB)/Internal/Languages/English/Syntax.preform \
	$(INFORM7WEB)/Internal/Miscellany/inform7_clib.h \
	$(INFORM7WEB)/Internal/Miscellany/inform7_clib.c

# When tangled, the inform7 web most importantly makes inform7.c, of course,
# but it makes three side files as well: Syntax.preform, a grammar file, and
# a small C library used when compiling Inform projects to C.

$(INFORM7WEB)/Internal/Languages/English/Syntax.preform: $(INFORM7WEB)/Tangled/Syntax.preform
	cp -f "$(INFORM7WEB)/Tangled/Syntax.preform" "$(INFORM7WEB)/Internal/Languages/English/Syntax.preform"

$(INFORM7WEB)/Internal/Miscellany/inform7_clib.h: $(INFORM7WEB)/Tangled/inform7_clib.h
	cp -f "$(INFORM7WEB)/Tangled/inform7_clib.h" "$(INFORM7WEB)/Internal/Miscellany/inform7_clib.h"

$(INFORM7WEB)/Internal/Miscellany/inform7_clib.c: $(INFORM7WEB)/Tangled/inform7_clib.c
	cp -f "$(INFORM7WEB)/Tangled/inform7_clib.c" "$(INFORM7WEB)/Internal/Miscellany/inform7_clib.c"

# It is in fact sufficient to tangle just the inter subset of inform7 to make
# the two C-library files:

$(INFORM7WEB)/Tangled/inform7_clib.h: inter/final-module/Chapter\ 5/*.w
	$(INWEBX) $(INTERWEB) -tangle

$(INFORM7WEB)/Tangled/inform7_clib.c: inter/final-module/Chapter\ 5/*.w
	$(INWEBX) $(INTERWEB) -tangle

# -----------------------------------------------------------------------------
# Target "makers"
# -----------------------------------------------------------------------------
# Each individual tool has its own makefile, stored inside its individual web. 
# "make makers" runs through each tool in turn and creates them from their
# respective makescripts. The one makefile we don't make is this one: it really
# doesn't seem safe for a makefile to run a command which overwrites itself.

# Note that {components type: tool}...{end-components} iterates through all the
# components given the type "tool" above.

.PHONY: makers
makers:
	{components type: tool}
	$(INWEBX) $({SYMBOL}WEB) -makefile $({SYMBOL}MAKER)
	{end-components}
	$(INWEBX) -prototype $(INFORM6WEB)/inform6.mkscript -makefile $(INFORM6WEB)/inform6.mk
	$(INWEBX) -prototype retrospective/retrospective.mkscript -makefile retrospective/makefile

# -----------------------------------------------------------------------------
# Target "gitignores"
# -----------------------------------------------------------------------------
# Each individual web needs its own .gitignore file, and this makes them. No
# overwriting issues time, so we do include the .gitignore at the root of the
# inform repository.

.PHONY: gitignores
gitignores:
	$(INWEBX) -prototype scripts/inform.giscript -gitignore .gitignore
	{components type: tool}
	$(INWEBX) $({SYMBOL}WEB) -gitignore $({SYMBOL}WEB)/.gitignore
	{end-components}
	$(INWEBX) -prototype $(INFORM6WEB)/inform6.giscript -gitignore $(INFORM6WEB)/.gitignore

# -----------------------------------------------------------------------------
# Target "versions"
# -----------------------------------------------------------------------------
# Asks the tools their current version numbers.

.PHONY: versions
versions:
	{components type: tool}
	$({SYMBOL}X) -version
	{end-components}
	$(INFORM6X) -V

# -----------------------------------------------------------------------------
# Targets "extensions" and "forceextensions"
# -----------------------------------------------------------------------------
# "make extensions" incrementally re-tangles any extensions defined by webs
# (such as Basic Inform); "make forceextensions" does so regardless of timestamps.

{define: tangle-extension name: SYMBOL}
	$(INWEBX) $({SYMBOL}WEB) -tangle-to $({SYMBOL}TANGLED)
{end-define}

.PHONY: extensions
extensions: {components type: web set: extensions}$({SYMBOL}TANGLED) {end-components}

{components type: web set: extensions}
$({SYMBOL}TANGLED): $({SYMBOL}WEB)/Contents.w $({SYMBOL}WEB)/Sections/*.w
	{tangle-extension name: {SYMBOL}}

{end-components}

PHONY: forceextensions
forceextensions:
	{components type: web set: extensions}
	{tangle-extension name: {SYMBOL}}
	{end-components}

# -----------------------------------------------------------------------------
# Targets "kits" and "forcekits"
# -----------------------------------------------------------------------------
# These are easier because Inbuild already performs a make-like service on
# directories of kits; that saves a great deal of messy make code here.

.PHONY: kits
kits:
	$(INBUILDX) -build -contents-of $(INFORM7WEB)/Internal/Inter

.PHONY: forcekits
forcekits:
	$(INBUILDX) -rebuild -contents-of $(INFORM7WEB)/Internal/Inter

# -----------------------------------------------------------------------------
# Target "tools"
# -----------------------------------------------------------------------------
# "make tools" builds all of the tools incrementally, i.e., only as necessary.
# Note the use of repeat to make a list: $(INBLORBX) $(INDOCX) ..., etc.

.PHONY: tools
tools: {components type: tool}$({SYMBOL}X) {end-components}$(INFORM6X)

{components type: tool}
$({SYMBOL}X): {dependent-files tool-and-modules: {SYMBOL}}
	$(MAKE) -f $({SYMBOL}MAKER)

{end-components}

# As ever, Inform 6 needs special handling:

$(INFORM6X): $(INFORM6WEB)/Inform6/*.c
	$(MAKE) -f $(INFORM6WEB)/inform6.mk

# -----------------------------------------------------------------------------
# Target "forcetools"
# -----------------------------------------------------------------------------
# Similarly, but with a single target, since nothing is incremental here.

.PHONY: forcetools
forcetools:
	{components type: tool}
	$(MAKE) -f $({SYMBOL}MAKER) force
	{end-components}
	$(MAKE) -f $(INFORM6WEB)/inform6.mk force

# -----------------------------------------------------------------------------
# Target "retrospective"
# -----------------------------------------------------------------------------
# "make retrospective" builds the back catalogue of old releases, but delegates
# all the work to a makefile there:

.PHONY: retrospective
retrospective:
	$(MAKE) -f retrospective/makefile

# -----------------------------------------------------------------------------
# Target "check"
# -----------------------------------------------------------------------------
# "make check" invites the make file for every tool to run its own tests.
# I6 must come first, because that guarantees the Z and Glulx interpreters
# are safely built before we need them (as we will in order to test I7).
# -----------------------------------------------------------------------------

.PHONY: check
check:
	$(MAKE) -f $(INFORM6WEB)/inform6.mk test
	$(INPOLICYX) -silence -check-problems
	{components type: tool}
	$(MAKE) -f $({SYMBOL}MAKER) test
	{end-components}

# -----------------------------------------------------------------------------
# Target "commit"
# -----------------------------------------------------------------------------
# "make commit" should be used only by the Benevolent Overlord of Inform.
# It updates the build code and commits to the repository.
# -----------------------------------------------------------------------------

{define: update-readme}
	$(INWEBX) -prototype scripts/inform.rmscript -write-me README.md
{end-define}

.PHONY: commit
commit:
	$(INWEBX) -advance-build-file build.txt
	$(INPOLICYX) -sync-kit-versions
	{update-readme}
	git commit -a

# -----------------------------------------------------------------------------
# Target "pages"
# -----------------------------------------------------------------------------
# "make pages" refreshes the GitHub Pages content in the docs folder.
# -----------------------------------------------------------------------------

.PHONY: pages
pages: readmepage icon diagnostics diagrams navigationpages \
	{components type: tool}{SYMBOL}PAGES {end-components} \
	{components type: module}{SYMBOL}PAGES {end-components} \
	{components type: web}{SYMBOL}PAGES {end-components}

.PHONY: forcepages
forcepages: readmepage icon diagnostics diagrams forcenavigationpages \
	{components type: tool}{SYMBOL}FORCEPAGES {end-components} \
	{components type: module}{SYMBOL}FORCEPAGES {end-components} \
	{components type: web}{SYMBOL}FORCEPAGES {end-components}

# -----------------------------------------------------------------------------
# Just one lonely icon file!

.PHONY: icon
icon:
	mkdir -p docs
	mkdir -p docs/docs-assets
	cp -f docs-src/Inform.png docs/docs-assets

# -----------------------------------------------------------------------------
# See the "make commit" target above.

.PHONY: readmepage
readmepage:
	{update-readme}

# -----------------------------------------------------------------------------
# A number of diagrams in the woven form of our webs are automatically created,
# so that they will always be correct to the current state of Inform. The following
# copies them into place in the relevant Figures folders; or, in the case of -help
# listings of command-line settings, creates them in place.

{define: copy-diagram file: FILE into: WEB}
	cp -f {FILE} $({WEB})/Figures
{end-define}
{define: update-reference-card for: TOOL}
	$({TOOL}X) -help >$({TOOL}WEB)/Figures/help.txt
{end-define}

.PHONY: diagrams
diagrams:
	{copy-diagram file: $(LINGUISTICSTESTWEB)/Tests/Test\ Diagrams/_Results_Ideal/*.txt into: LINGUISTICSWEB}
	{copy-diagram file: $(LINGUISTICSTESTWEB)/Tests/vocabulary.txt                      into: LINGUISTICSWEB}
	{copy-diagram file: $(INFORM7WEB)/Tests/Test\ Internals/_Results_Ideal/Refine*.txt  into: ASSERTIONSWEB}
	{copy-diagram file: $(KINDSTESTWEB)/Tests/Test\ Cases/_Results_Ideal/*.txt          into: KINDSWEB}
	{copy-diagram file: $(CALCULUSTESTWEB)/Tests/Test\ Cases/_Results_Ideal/*.txt       into: CALCULUSWEB}
	{copy-diagram file: $(INFORM7WEB)/Internal/Pipelines/compile.interpipeline          into: INTERWEB}
	{copy-diagram file: $(INFORM7WEB)/Internal/Pipelines/compile.interpipeline          into: PIPELINEWEB}
	{copy-diagram file: $(INFORM7WEB)/Internal/Pipelines/assimilate.interpipeline       into: PIPELINEWEB}
	{copy-diagram file: $(INFORM7WEB)/Internal/Pipelines/link.interpipeline             into: PIPELINEWEB}
	{copy-diagram file: $(INFORM7WEB)/Internal/Pipelines/optimise.interpipeline         into: PIPELINEWEB}
	{copy-diagram file: $(INFORM7WEB)/Internal/Pipelines/build-kit.interpipeline        into: PIPELINEWEB}
	{components type: tool set: ctools}
	{update-reference-card for: {SYMBOL}}
	{end-components}
	{components type: tool set: otools}
	{update-reference-card for: {SYMBOL}}
	{end-components}

# -----------------------------------------------------------------------------
# "Diagnostics" are files produced by inform7 to measure its own performance when
# running in a special mode, as it does when intest runs the test GenerateDiagnostics-G.
# We need first to run that test; then the diagnostics files will all be in the
# $(INFORM7WEB)/Figures directory; but in some cases that is not where we want them, so
# we need to move those on to their proper homes.

{define: copy-download file: FILE into: WEB}
	cp -f {FILE} $({WEB})/Downloads
{end-define}

.PHONY: diagnostics
diagnostics:
	$(INTESTX) inform7 GenerateDiagnostics-G
	{copy-download file: $(INFORM7WEB)/Figures/excerpts-diagnostics.txt into: INFORM7WEB}
	rm -f $(INFORM7WEB)/Figures/syntax-diagnostics.txt
	{copy-download file: $(INFORM7WEB)/Figures/preform-diagnostics.txt  into: INFORM7WEB}
	rm -f $(INFORM7WEB)/Figures/preform-diagnostics.txt
	{copy-diagram file: $(INFORM7WEB)/Figures/excerpts-diagnostics.txt  into: LEXICONWEB}
	rm -f $(INFORM7WEB)/Figures/excerpts-diagnostics.txt
	{copy-diagram file: $(INFORM7WEB)/Figures/stock-diagnostics.txt     into: LINGUISTICSWEB}
	rm -f $(INFORM7WEB)/Figures/stock-diagnostics.txt

# -----------------------------------------------------------------------------
# These are the special pages at the top of the mini-website, which act as
# navigation points into the interior. They are each little one-file webs in
# their own right, designed just for weaving, not tangling.

# Annoyingly, we can't put overview into this list, because it weaves to a
# file called index.html, not overview.html; and we can't rename overview as
# "index" because that would be a name clash with the "index" module of I7,
# which is already a web in the colony file.

{set name: NAVIGATIONPAGES value: structure, extensions, kits, services, inform6, inbuildn, inform7n, intern, inblorbn, indocn, inrtpsn, inpolicyn, secrets}

{define: weave-one page: PAGE}
	$(INWEBX) -colony $(COLONY) -member {PAGE} -weave
{end-define}

.PHONY: navigationpages
navigationpages: docs/index.html {repeat with: PAGE in: {NAVIGATIONPAGES}}docs/{PAGE}.html {end-repeat}

docs/index.html: docs-src/index.inweb docs-src/nav.html
	{weave-one page: overview}

{repeat with: PAGE in: {NAVIGATIONPAGES}}
docs/{PAGE}.html: docs-src/{PAGE}.inweb docs-src/nav.html
	{weave-one page: {PAGE}}

{end-repeat}

.PHONY: forcenavigationpages
forcenavigationpages:
	rm -f docs/*.html
	{weave-one page: overview}
	{repeat with: PAGE in: {NAVIGATIONPAGES}}
	{weave-one page: {PAGE}}
	{end-repeat}

# -----------------------------------------------------------------------------
# Now we have to weave each of the webs for the many component parts. For the
# the web SYMBOL, the following defines two phony targets, SYMBOLPAGES and
# SYMBOLFORCEPAGES. The first weaves the web only if the source has changed
# since the last time; the second weaves it regardless.

{define: weave-target component: SYMBOL}
.PHONY: {SYMBOL}PAGES
{SYMBOL}PAGES: docs/$({SYMBOL}LEAF)/index.html

docs/$({SYMBOL}LEAF)/index.html: {dependent-files tool: {SYMBOL}}
	rm -f docs/$({SYMBOL}LEAF)/*.html
	$(INWEBX) -colony $(COLONY) -member $({SYMBOL}LEAF) -weave

.PHONY: {SYMBOL}FORCEPAGES
{SYMBOL}FORCEPAGES:
	rm -f docs/$({SYMBOL}LEAF)/*.html
	$(INWEBX) -colony $(COLONY) -member $({SYMBOL}LEAF) -weave

{end-define}

{define: weave-module-target component: SYMBOL}
.PHONY: {SYMBOL}PAGES
{SYMBOL}PAGES: docs/$({SYMBOL}LEAF)/index.html

docs/$({SYMBOL}LEAF)/index.html: {dependent-files module: {SYMBOL}}
	rm -f docs/$({SYMBOL}LEAF)/*.html
	$(INWEBX) -colony $(COLONY) -member $({SYMBOL}LEAF) -weave

.PHONY: {SYMBOL}FORCEPAGES
{SYMBOL}FORCEPAGES:
	rm -f docs/$({SYMBOL}LEAF)/*.html
	$(INWEBX) -colony $(COLONY) -member $({SYMBOL}LEAF) -weave

{end-define}

# And using that:

{components type: tool}
{weave-target component: {SYMBOL}}
{end-components}
{components type: module}
{weave-module-target component: {SYMBOL}}
{end-components}
{components type: web}
{weave-target component: {SYMBOL}}
{end-components}

# -----------------------------------------------------------------------------
# Targets "clean" and "purge"
# -----------------------------------------------------------------------------
# "make clean" removes some inessential files from the Inform source hierarchy;
# "make purge" also removes binaries
# -----------------------------------------------------------------------------

{define: ask-each-tool-makefile to: TARGET}
	{components type: tool}
	$(MAKE) -f $({SYMBOL}MAKER) {TARGET}
	{end-components}
	$(MAKE) -f $(INFORM6WEB)/inform6.mk {TARGET}
{end-define}

.PHONY: clean
clean:
	{ask-each-tool-makefile to: clean}

.PHONY: purge
purge:
	{ask-each-tool-makefile to: purge}

# -----------------------------------------------------------------------------
# Target "ebooks"
# -----------------------------------------------------------------------------
# "make ebooks" generates the two Inform ebook files in ePub format.
# One combines the manuals Writing with Inform and The Inform Recipe Book into
# a single volume, while the other holds the collected change logs.
# -----------------------------------------------------------------------------

{define: clean-ebooks}
	rm -f resources/Documentation/Output/OEBPS/images/*
	rm -f resources/Documentation/Output/OEBPS/*.*
	rm -f resources/Documentation/Output/META-INF/container.xml
	rm -f resources/Documentation/Output/mimetype
	rm -f resources/Documentation/Output/*.*
	rm -f resources/Changes/Output/OEBPS/images/*
	rm -f resources/Changes/Output/OEBPS/*.*
	rm -f resources/Changes/Output/META-INF/container.xml
	rm -f resources/Changes/Output/mimetype
	rm -f resources/Changes/Output/*.*
{end-define}

{set name: EBOOKSLIST value: Documentation, Changes}

.PHONY: ebooks
ebooks:
	$(call clean-ebooks)
	{repeat with: EBOOK in: {EBOOKSLIST}}
	$(INDOCX) -from resources/{EBOOK} ebook
	$(call clean-ebooks)
	{end-repeat}

# =============================================================================
# From here on, everything is to do with integration: that is, with copying files
# from the inform repository (after all is built) into a GUI app. Command-line
# hackers will therefore not use these make targets.

{set name: IMAGESETLIST value: bg_images, doc_images, map_icons, outcome_images, scene_icons}

{define: transfer-images}
	mkdir -p $(BUILTINHTML)
	cp -f resources/Imagery/app_images/Welcome*Background.png $(BUILTINHTML)
	cp -f resources/Imagery/app_images/Welcome*Banner.png $(BUILTINHTML)
	{repeat with: SET in: {IMAGESETLIST}}
	mkdir -p $(BUILTINHTML)/{SET}
	rm -f $(BUILTINHTML)/{SET}/*
	cp -f resources/Imagery/{SET}/[A-Za-z]*.* $(BUILTINHTML)/{SET}
	{end-repeat}
{end-define}

# The next part of the file is inside "ifdef BUILTINCOMPS ... endif", which tests
# whether functional parts of the built core distribution should be copied into
# the app. If BUILTINCOMPS is defined, then BUILTINHTML should be defined too;
# but it is also legal to define just ADVICEHTML, BUILTINHTML and BUILTINHTMLINNER

ifdef BUILTINCOMPS

# -----------------------------------------------------------------------------
# Targets "integration" and "forceintegration"
# -----------------------------------------------------------------------------

.PHONY: integration
integration: \
		transfertools \
		transferpreform \
		transferindext \
		transferkits \
		transferinternals \
		transferdocumentation \
		transferoutcomepages

.PHONY: forceintegration
forceintegration: \
		forcetransfertools \
		forcetransferpreform \
		forcetransferindext \
		forcetransferkits \
		forcetransferextensions \
		forcetransferlanguages \
		forcetransferimages \
		forcetransferotherinternals \
		forcetransferdocumentation \
		forcetransferoutcomepages \
		forcetransfertemplates

# -----------------------------------------------------------------------------
# Copying part of the Inform toolchain into the app

# The UI apps do not contain all of the intools: for example, they do not need
# indoc or inpolicy, which are run only at the command line. They do have these:

{set name: TOOLSINAPPS value: INBLORB, INFORM6, INFORM7, INTEST, INBUILD}

# The make-integration-settings.mk file is expected to have defined the symbols
# INBLORBNAME, INFORM6NAME, etc., as the leafnames these executables should be
# given when they are copied into the app: so, for example, if they want to call
# the "inform7" compiler by its old name, "ni", they can do so with INFORM7NAME = ni,
# and similarly if they want to call "inblorb" by its old name "cblorb".

# make-integration-settings.mk must also have set BUILTINCOMPS to the path for
# the built-in compiler tools.

{define: transfer-tool name: SYMBOL}
	mkdir -p $(BUILTINCOMPS)
	cp -f $({SYMBOL}X) $(BUILTINCOMPS)/$({SYMBOL}NAME)
{end-define}

.PHONY: transfertools
transfertools: {repeat with: SYMBOL in: {TOOLSINAPPS}}$(BUILTINCOMPS)/$({SYMBOL}NAME) {end-repeat}

{repeat with: SYMBOL in: {TOOLSINAPPS}}
$(BUILTINCOMPS)/$({SYMBOL}NAME): $({SYMBOL}X)
	{transfer-tool name: {SYMBOL}}

{end-repeat}

.PHONY: forcetransfertools
forcetransfertools:
	{repeat with: SYMBOL in: {TOOLSINAPPS}}
	{transfer-tool name: {SYMBOL}}
	{end-repeat}

# -----------------------------------------------------------------------------
# Copying the main English-language Preform definition file into the app

.PHONY: transferpreform
transferpreform: forcetransferpreform

.PHONY: forcetransferpreform
forcetransferpreform:
	mkdir -p "$(INTERNAL)/Languages"
	mkdir -p "$(INTERNAL)/Languages/English"
	cp -f "$(INFORM7WEB)/Tangled/Syntax.preform" "$(INTERNAL)/Languages/English/Syntax.preform"

# -----------------------------------------------------------------------------
# Copying the indexing structure and localisation files into the app

{set name: LOCALISEDINDEXES value: English}

.PHONY: transferindext
transferindext: forcetransferindext

.PHONY: forcetransferindext
forcetransferindext:
	mkdir -p "$(INTERNAL)/Miscellany"
	cp -f "$(INFORM7WEB)/Internal/Miscellany/Standard.indext" "$(INTERNAL)/Miscellany/Standard.indext"
	cp -f "$(INFORM7WEB)/Internal/Miscellany/Basic.indext"    "$(INTERNAL)/Miscellany/Basic.indext"
	{repeat with: LANGUAGE in: {LOCALISEDINDEXES}}
	mkdir -p "$(INTERNAL)/Languages/{LANGUAGE}"
	cp -f "$(INFORM7WEB)/Internal/Languages/{LANGUAGE}/Index.txt" "$(INTERNAL)/Languages/{LANGUAGE}/Index.txt"
	{end-repeat}

# -----------------------------------------------------------------------------
# Copying kits (and Inter pipelines) into the app

# This is easy, because Inbuild provides a convenient sync facility. Note that
# make-integration-settings.mk is expected to have defined INTERNAL as the
# directory of resources inside itself which will be supplied to its copy of
# inform7 on the command line with the -internal switch.

.PHONY: transferkits
transferkits: forcetransferkits

.PHONY: forcetransferkits
forcetransferkits:
	$(INBUILDX) -no-versions-in-filenames -sync-to $(INTERNAL) -contents-of $(INFORM7WEB)/Internal/Inter
	$(INBUILDX) -no-versions-in-filenames -sync-to $(INTERNAL) -contents-of $(INFORM7WEB)/Internal/Pipelines

# -----------------------------------------------------------------------------
# Copying extensions into the app

# And also the documentation cross-referencing file, since that cross-references
# the Standard Rules and Basic Inform.

{define: transfer-extensions}
	mkdir -p $(INTERNAL)
	mkdir -p "$(INTERNAL)/Extensions/Eric Eve"
	rm -f $(INTERNAL)/Extensions/Eric\ Eve/*
	mkdir -p "$(INTERNAL)/Extensions/Emily Short"
	rm -f $(INTERNAL)/Extensions/Emily\ Short/*
	mkdir -p "$(INTERNAL)/Extensions/Graham Nelson"
	rm -f $(INTERNAL)/Extensions/Graham\ Nelson/*
	cp -R -f $(INFORM7WEB)/Internal/Extensions $(INTERNAL)/Extensions/..
	mkdir -p "$(INTERNAL)/HTML"
	cp -f $(INFORM7WEB)/Internal/HTML/xrefs.txt "$(INTERNAL)/HTML"
{end-define}

.PHONY: forcetransferextensions
forcetransferextensions:
	{transfer-extensions}

# -----------------------------------------------------------------------------
# Copying language bundles into the app

{define: transfer-languages}
	mkdir -p "$(INTERNAL)/Languages"
	cp -R -f $(INFORM7WEB)/Internal/Languages $(INTERNAL)/Languages/..
	rm -f $(INTERNAL)/Languages/*/about.txt
{end-define}

.PHONY: forcetransferlanguages
forcetransferlanguages:
	{transfer-languages}

# -----------------------------------------------------------------------------
# Copying website templates into the app

{set name: TEMPLATENAMES value: Standard, Classic, Parchment, Quixe}

{define: transfer-templates}
	mkdir -p "$(INTERNAL)/Templates"
	{repeat with: INTERPRETER in: {TEMPLATENAMES}}
	mkdir -p "$(INTERNAL)/Templates/{INTERPRETER}"
	rm -f $(INTERNAL)/Templates/{INTERPRETER}/*
	{end-repeat}
	cp -R -f $(INFORM7WEB)/Internal/Templates $(INTERNAL)/Templates/..
{end-define}

.PHONY: forcetransfertemplates
forcetransfertemplates:
	{transfer-templates}

{define: transfer-other-internals}
	mkdir -p "$(INTERNAL)/Miscellany"
	rm -f $(INTERNAL)/Miscellany/*
	cp -R -f $(INFORM7WEB)/Internal/Miscellany $(INTERNAL)/Miscellany/..
	mkdir -p "$(INTERNAL)/HTML"
	rm -f $(INTERNAL)/HTML/*
	cp -R -f $(INFORM7WEB)/Internal/HTML $(INTERNAL)/HTML/..
{end-define}

.PHONY: forcetransferotherinternals
forcetransferotherinternals:
	{transfer-other-internals}

# -----------------------------------------------------------------------------
# Incrementally copying the internal tree
# This is super-awkward and probably should be dropped in favour of rsync, but
# it's only used by "make integration", not by "make forceintegration". It aims
# to copy only what has changed, out of the extensions, languages, templates,
# images and miscellany files.

# Basically we use the timestamps on these two files to see whether a sync
# is now needed. (If it is, INTERNALEXEMPLUMFROM will be copied to INTERNALEXEMPLUM
# in the process.)

INTERNALEXEMPLUM = $(INTERNAL)/Miscellany/Cover.jpg
INTERNALEXEMPLUMFROM = $(INFORM7WEB)/Internal/Miscellany/Cover.jpg

.PHONY: transferinternals
transferinternals: $(INTERNALEXEMPLUM)

$(INTERNALEXEMPLUMFROM):
	$(INTERNALEXEMPLUM)

$(INTERNALEXEMPLUM): \
		$(INFORM7WEB)/Internal/Extensions/Eric\ Eve/[A-Za-z]* \
		$(INFORM7WEB)/Internal/Extensions/Emily\ Short/[A-Za-z]* \
		$(INFORM7WEB)/Internal/Extensions/Graham\ Nelson/[A-Za-z]* \
		$(INFORM7WEB)/Internal/Languages/*/*.* \
		$(INFORM7WEB)/Internal/Templates/*/*.* \
		$(INFORM7WEB)/Internal/HTML/[A-Za-z]*.* \
		{repeat with: INTERPRETER in: {TEMPLATENAMES}}
		$(INFORM7WEB)/Internal/Templates/{INTERPRETER}/[A-Za-z]*.* \
		{end-repeat}
		{repeat with: SET in: {IMAGESETLIST}}
		resources/Imagery/{SET}/[A-Za-z]*.* \
		{end-repeat}
		resources/Imagery/app_images/[A-Za-z]*.* \
		$(INFORM7WEB)/Internal/Miscellany/[A-Za-z]*.*
	touch $(INTERNALEXEMPLUMFROM)
	{transfer-extensions}
	{transfer-languages}
	{transfer-templates}
	{transfer-other-internals}
	{transfer-images}

# =============================================================================

# End of the block which is used only if make-integration-settings.mk defines
# BUILTINCOMPS

endif

# =============================================================================

ifdef BUILTINHTML

# (alternative passage to the above, for use only if BUILTINCOMPS is not provided)

ifndef BUILTINCOMPS

# -----------------------------------------------------------------------------
# Targets "integration" and "forceintegration"
# -----------------------------------------------------------------------------

.PHONY: integration
integration: \
		transferimages \
		transferdocumentation \
		transferoutcomepages

.PHONY: forceintegration
forceintegration: \
		forcetransferimages \
		forcetransferdocumentation \
		forcetransferoutcomepages

# -----------------------------------------------------------------------------
# Incrementally copying the images
# A simplified version of the above.

IMAGEEXEMPLUM = $(BUILTINHTML)/doc_images/index.png
IMAGEEXEMPLUMFROM = resources/Imagery/doc_images/index.png

.PHONY: transferimages
transferimages: $(IMAGEEXEMPLUM)

$(IMAGEEXEMPLUMFROM):
	$(IMAGEEXEMPLUM)

$(IMAGEEXEMPLUM): \
		{repeat with: SET in: {IMAGESETLIST}}
		resources/Imagery/{SET}/[A-Za-z]*.* \
		{end-repeat}
		resources/Imagery/app_images/[A-Za-z]*.*
	touch $(IMAGEEXEMPLUMFROM)
	{transfer-images}

# (end of the alternative passage if BUILTINCOMPS is not provided)

endif

# -----------------------------------------------------------------------------
# Copying images into the app

.PHONY: forcetransferimages
forcetransferimages:
	{transfer-images}

# -----------------------------------------------------------------------------
# Typesetting documentation to HTML inside the app, using indoc

# Note that make-integration-settings.mk is expected to define BUILTINHTMLINNER as
# the directory which will hold the text pages of the mini-website formed by the
# in-app manuals. That may or may not be the same as BUILTINHTML, but whatever
# the relation between the two, the indoc settings for the platform will need to
# agree with that.

{define: compile-inapp-advice}
ifdef ADVICEHTML
	mkdir -p $(ADVICEHTML)
	$(INBUILDX) -preprocess-html-to $(ADVICEHTML) -preprocess-app $(HTMLPLATFORM) -preprocess-html resources/Documentation/Advice/AdviceCredits.html
	$(INBUILDX) -preprocess-html-to $(ADVICEHTML) -preprocess-app $(HTMLPLATFORM) -preprocess-html resources/Documentation/Advice/AdviceKeyboardShortcuts.html
	$(INBUILDX) -preprocess-html-to $(ADVICEHTML) -preprocess-app $(HTMLPLATFORM) -preprocess-html resources/Documentation/Advice/AdviceMaterialsFolder.html
	$(INBUILDX) -preprocess-html-to $(ADVICEHTML) -preprocess-app $(HTMLPLATFORM) -preprocess-html resources/Documentation/Advice/AdviceNewToInform.html
	$(INBUILDX) -preprocess-html-to $(ADVICEHTML) -preprocess-app $(HTMLPLATFORM) -preprocess-html resources/Documentation/Advice/AdviceUpgrading.html
	$(INBUILDX) -preprocess-html-to $(ADVICEHTML) -preprocess-app $(HTMLPLATFORM) -preprocess-html resources/Documentation/Advice/TestingTemplate.html
	cp -f 'resources/Documentation/Advice/MaterialsDiagram.png' $(ADVICEHTML)
endif
{end-define}

.PHONY: forcetransferadvice
forcetransferadvice:
	{compile-inapp-advice}

{define: compile-inapp-documentation}
	mkdir -p $(BUILTINHTMLINNER)
	$(INDOCX) -from resources/Documentation -xrefs '$(INFORM7WEB)/Internal/HTML/xrefs.txt' $(INDOCOPTS)
ifdef INTERNAL
	cp -f $(INFORM7WEB)/Internal/HTML/xrefs.txt "$(INTERNAL)/HTML"
endif
{end-define}

.PHONY: transferdocumentation
transferdocumentation: $(BUILTINHTMLINNER)/index.html

$(BUILTINHTMLINNER)/index.html: resources/Documentation/*.txt resources/Documentation/Examples/*.txt
	{compile-inapp-advice}
	{compile-inapp-documentation}

.PHONY: forcetransferdocumentation
forcetransferdocumentation:
	{compile-inapp-advice}
	{compile-inapp-documentation}

# -----------------------------------------------------------------------------
# Typesetting the HTML pages used to display run-time problem messages, using inrtps

{define: make-inapp-outcome-pages}
	$(INRTPSX) resources/Outcome\ Pages $(BUILTINHTMLINNER) $(INRTPSOPTS)
	cp -f resources/Outcome\ Pages/pl404.html $(BUILTINHTMLINNER)
{end-define}

RTPEXEMPLUM = $(BUILTINHTMLINNER)/RTP_P1.html

.PHONY: transferoutcomepages
transferoutcomepages: $(RTPEXEMPLUM)

$(RTPEXEMPLUM): resources/Outcome*Pages/texts.txt resources/Outcome*Pages/*.html
	{make-inapp-outcome-pages}

.PHONY: forcetransferoutcomepages
forcetransferoutcomepages:
	{make-inapp-outcome-pages}

# =============================================================================

# End of the block which is used only if make-integration-settings.mk defines
# BUILTINHTML

endif
