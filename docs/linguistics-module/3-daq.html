<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>3/cao</title>
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="../inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>
		<nav role="navigation">
		<h1><a href="../webs.html">Sources</a></h1>
<ul>
<li><a href="../compiler.html"><b>compiler</b></a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul>
<h2>Compiler Webs</h2>
<ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul>
<h2>Inbuild Modules</h2>
<ul>
<li><a href="../inbuild-module/index.html">inbuild</a></li>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../html-module/index.html">html</a></li>
</ul>
<h2>Inform7 Modules</h2>
<ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../if-module/index.html">if</a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul>
<h2>Inter Modules</h2>
<ul>
<li><a href="../inter-module/index.html">inter</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../codegen-module/index.html">codegen</a></li>
</ul>
<h2>Foundation</h2>
<ul>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>
</ul>


		</nav>
		<main role="main">
		
<!--Weave of '3/daq' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">Source</a></li><li><a href="../compiler.html">Compiler</a></li><li><a href="index.html">linguistics</a></li><li><a href="index.html#3">Chapter 3: Grammatical Categories I</a></li><li><b>Determiners and Quantifiers</b></li></ul><p class="purpose">To create the determiners found in standard English which refer to collections of things, and to create their meanings as logical quantifiers.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Definitions</a></li><li><a href="#SP6">&#167;6. Creating a quantifier</a></li><li><a href="#SP9">&#167;9. Acting on quantifiers</a></li><li><a href="#SP12">&#167;12. Creating a determiner</a></li><li><a href="#SP14">&#167;14. Parsing the determiner at the head of a noun phrase</a></li><li><a href="#SP18">&#167;18. The built-in set</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Definitions. </b></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2.  </b>In logic, a "quantifier" appears at the front of a statement which can
apply to many cases, and describes the quantity of cases for which the
statement is true: all of them, some of them, exactly six, and so on.
</p>

<p class="inwebparagraph">When a quantifier is used, it "ranges over a domain". The domain is the
set of cases. For instance, in:
</p>

<blockquote>
    <p>if most of the doors are open, ...</p>

</blockquote>

<p class="inwebparagraph">the "most of" text is parsed into a quantifier written in the debugging
log as <code class="display"><span class="extract">Proportion&gt;50%</span></code>, and the domain is the set of all doors. We then
test the inner condition ("open") for the objects in the domain.
</p>

<p class="inwebparagraph">Some quantifiers apply to a proportion of the domain, and the proportion is
measured with a number we will call the T-coefficient, which is measured in
tenths. Thus a quantifier talking about the entire domain ("all of the
doors are open") will have T=10, while the "most of" example above has
T=5. Other quantifiers apply to an exact number, a "cardinality" in
logic jargon, rather than a proportion: for instance, "three doors are
open". These quantifiers have T=-1.
</p>

<p class="inwebparagraph">Finally, a few quantifiers apply not to the cases in the domain which
passed, but to those which didn't, and those are called "complementary"
(because they describe the complement of the domain set). For instance,
"all but six doors are open", where the "six" describes the number
of closed doors and not the number of open ones.
</p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3.  </b>These different ways to describe multiple outcomes are represented in Inform by
<code class="display"><span class="extract">quantifier</span></code> structures. One exists for each different meaning supported
by Inform &mdash; <code class="display"><span class="extract">ForAll</span></code>, <code class="display"><span class="extract">Exists</span></code> and so forth &mdash; except that some quantifiers
take a numerical parameter, and a single <code class="display"><span class="extract">quantifier</span></code> structure represents
the meaning for any value of this parameter. For instance, the cardinality
quantifiers <code class="display"><span class="extract">Card=3</span></code> and <code class="display"><span class="extract">Card=17</span></code> are both represented by the same
quantifier structure, whose pointer is called <code class="display"><span class="extract">exactly_quantifier</span></code> below.
This is the result of parsing "exactly three" doors or "exactly 17"
containers, for instance, where the parameter is 3 or 17 respectively.
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">quantifier</span><span class="plain"> {</span>
        <span class="reserved">char</span><span class="plain"> *</span><span class="identifier">operator</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">CORE_MODULE</span>
        <span class="identifier">inter_t</span><span class="plain"> </span><span class="identifier">operator_prim</span><span class="plain">; </span>    <span class="comment">inter opcode to compare successes against the threshold</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">T_coefficient</span><span class="plain">; </span>    <span class="comment">see above</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">is_complementary</span><span class="plain">; </span>    <span class="comment">tests the complement of the set, not the set of matches</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">can_be_used_in_now</span><span class="plain">; </span>    <span class="comment">can be asserted true or false using "now"</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">can_be_used_in_assertions</span><span class="plain">; </span>    <span class="comment">can be used in assertion sentences</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">quantifier</span><span class="plain"> *</span><span class="identifier">negated_quant</span><span class="plain">; </span>    <span class="comment">the logically converse determiner</span>
        <span class="reserved">char</span><span class="plain"> *</span><span class="identifier">log_text</span><span class="plain">; </span>    <span class="comment">to be used in the debugging log when logging propositions</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">quantifier</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure quantifier is private to this section.</p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4.  </b>The built-in set of 16 quantifiers, arranged in eight pairs, is as follows:
</p>


<pre class="display">
    <span class="reserved">quantifier</span>
        <span class="plain">*</span><span class="identifier">for_all_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,    *</span><span class="identifier">not_for_all_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,</span>
        <span class="plain">*</span><span class="identifier">exists_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,     *</span><span class="identifier">not_exists_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,</span>
        <span class="plain">*</span><span class="identifier">all_but_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,    *</span><span class="identifier">not_all_but_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,</span>
        <span class="plain">*</span><span class="identifier">almost_all_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">, *</span><span class="identifier">almost_no_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,</span>
        <span class="plain">*</span><span class="identifier">most_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,       *</span><span class="identifier">under_half_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,</span>
        <span class="plain">*</span><span class="identifier">at_least_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,   *</span><span class="identifier">more_than_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,</span>
        <span class="plain">*</span><span class="identifier">at_most_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,    *</span><span class="identifier">less_than_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,</span>
        <span class="plain">*</span><span class="identifier">exactly_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">,    *</span><span class="identifier">other_than_quantifier</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5.  </b>Whereas "quantifier" is a term from mathematical logic, "determiner"
is a term from linguistics which approximately &mdash; but only approximately &mdash;
means the same thing.
</p>

<p class="inwebparagraph">The determiner is the part of a noun phrase, always its head, which gives
counting information to be combined with a common noun. Thus "the" clock,
"seven" seals, "almost all of the" open doors, and so on. When a
determiner appears to refer to a range of objects rather than a single
item, NI translates it into a quantifier. Thus "the" clock is not parsed
into a quantifier, but "all but three" rooms is.
</p>

<p class="inwebparagraph">The same quantifier can have several different verbal forms. For instance,
"each" container and "every" container mean the same thing: both
apply the <code class="display"><span class="extract">ForAll</span></code> quantifier to containers. These different verbal forms
are stored in the <code class="display"><span class="extract">determiner</span></code> structure, and each one points to the
<code class="display"><span class="extract">quantifier</span></code> structure which is its meaning.
</p>


<pre class="display">
    <span class="reserved">typedef</span><span class="plain"> </span><span class="reserved">struct</span><span class="plain"> </span><span class="reserved">determiner</span><span class="plain"> {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">allows_prefixed_not</span><span class="plain">; </span>    <span class="comment">can the word "not" come before this?</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">text_of_det</span><span class="plain">; </span>    <span class="comment">which is allowed to be empty</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">takes_number</span><span class="plain">; </span>    <span class="comment">does a number follow? (e.g. for "at least N"</span>
        <span class="reserved">struct</span><span class="plain"> </span><span class="reserved">quantifier</span><span class="plain"> *</span><span class="identifier">quantifier_meant</span><span class="plain">; </span>    <span class="comment">meaning of this quantifier</span>
        <span class="reserved">char</span><span class="plain"> *</span><span class="identifier">index_text</span><span class="plain">; </span>    <span class="comment">used in the Phrasebook index lexicon</span>
        <span class="identifier">MEMORY_MANAGEMENT</span>
    <span class="plain">} </span><span class="reserved">determiner</span><span class="plain">;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The structure determiner is private to this section.</p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Creating a quantifier. </b>At present, there's only the built-in set, and no method exists to create
new quantifiers from the source text or the template files, but what follows
is written so that it would be fairly easy to add this ability.
</p>


<pre class="display">
    <span class="reserved">quantifier</span><span class="plain"> *</span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="reserved">char</span><span class="plain"> *</span><span class="identifier">op</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">T</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">is_comp</span><span class="plain">, </span><span class="reserved">char</span><span class="plain"> *</span><span class="identifier">text</span><span class="plain">) {</span>
        <span class="reserved">quantifier</span><span class="plain"> *</span><span class="identifier">quant</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">quantifier</span><span class="plain">);</span>
        <span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator</span><span class="plain"> = </span><span class="identifier">op</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">CORE_MODULE</span>
        <span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator_prim</span><span class="plain"> = 0;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">strcmp</span><span class="plain">(</span><span class="identifier">op</span><span class="plain">, </span><span class="string">"=="</span><span class="plain">) == 0) </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator_prim</span><span class="plain"> = </span><span class="identifier">EQ_BIP</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">strcmp</span><span class="plain">(</span><span class="identifier">op</span><span class="plain">, </span><span class="string">"~="</span><span class="plain">) == 0) </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator_prim</span><span class="plain"> = </span><span class="identifier">NE_BIP</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">strcmp</span><span class="plain">(</span><span class="identifier">op</span><span class="plain">, </span><span class="string">"&gt;="</span><span class="plain">) == 0) </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator_prim</span><span class="plain"> = </span><span class="identifier">GE_BIP</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">strcmp</span><span class="plain">(</span><span class="identifier">op</span><span class="plain">, </span><span class="string">"&gt;"</span><span class="plain">) == 0) </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator_prim</span><span class="plain"> = </span><span class="identifier">GT_BIP</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">strcmp</span><span class="plain">(</span><span class="identifier">op</span><span class="plain">, </span><span class="string">"&lt;="</span><span class="plain">) == 0) </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator_prim</span><span class="plain"> = </span><span class="identifier">LE_BIP</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">strcmp</span><span class="plain">(</span><span class="identifier">op</span><span class="plain">, </span><span class="string">"&lt;"</span><span class="plain">) == 0) </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator_prim</span><span class="plain"> = </span><span class="identifier">LT_BIP</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator_prim</span><span class="plain"> == 0) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"unfamiliar operator"</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">endif</span>

        <span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;T_coefficient</span><span class="plain"> = </span><span class="identifier">T</span><span class="plain">; </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;is_complementary</span><span class="plain"> = </span><span class="identifier">is_comp</span><span class="plain">;</span>
        <span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;can_be_used_in_now</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;can_be_used_in_assertions</span><span class="plain"> = </span><span class="identifier">FALSE</span><span class="plain">;</span>
        <span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;negated_quant</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>
        <span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;log_text</span><span class="plain"> = </span><span class="identifier">text</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">quant</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Quantifiers::quant_new is used in <a href="#SP18_1">&#167;18.1</a>, <a href="#SP18_2">&#167;18.2</a>, <a href="#SP18_3">&#167;18.3</a>, <a href="#SP18_4">&#167;18.4</a>.</p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7.  </b>That fills out the whole structure except for the negation pointers, and
to ensure that these always occur in matched pairs, these are set here.
</p>

<p class="inwebparagraph">A little explanation may be useful about what we mean by negation. In
traditional logic, the basic quantifiers "for all" and "there exists"
are dual to each other in that they are related by a sort of negation:
"there does not exist an open door" means the same as "all doors are
closed", and so on. Thus
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Not ( ForAll x: P(x) )| is equivalent to |Exists x: Not(P(x))</span>
</pre>

<p class="inwebparagraph">That isn't what we mean here. If Q and NQ are a quantifier and its
negation in our sense, then:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Not ( Q x: P(x) )| is equivalent to |NQ x: P(x)</span>
</pre>

<p class="inwebparagraph">Why do we do this? There are several reasons. First, we are using a richer
set of quantifiers than traditional logic provides, and most of these have
natural negations which we were going to be creating anyway &mdash; so we may
as well exploit that. Second, we are going to try to represent propositions
using as much conjunction ("and") and as little disjunction ("or") as
possible. Consider what effect de Morgan's laws have if we simplify:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Not ( ForAll x: closed(x) and locked(x) and lockable(x) )</span>
</pre>

<p class="inwebparagraph">in the traditional way: we obtain
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">Exists x: Not(closed(x)) or Not(locked(x)) or Not(lockable(x))</span>
</pre>

<p class="inwebparagraph">which introduces disjunction ("or") in just the way we don't want. By
simply regarding <code class="display"><span class="extract">NotAll</span></code> as a quantifier in its own right, we obtain
something much easier to handle:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">NotAll x: closed(x) and locked(x) and lockable(x)</span>
</pre>

<p class="inwebparagraph">This is why we will be creating quantifiers <code class="display"><span class="extract">NotAll</span></code> and <code class="display"><span class="extract">DoesNotExist</span></code> &mdash;
the negations of <code class="display"><span class="extract">ForAll</span></code> and <code class="display"><span class="extract">ThereExists</span></code> &mdash; even though they might seem
puzzlingly redundant from a traditional logic point of view.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Quantifiers::quants_negate_each_other</span><span class="plain">(</span><span class="reserved">quantifier</span><span class="plain"> *</span><span class="identifier">qx</span><span class="plain">, </span><span class="reserved">quantifier</span><span class="plain"> *</span><span class="identifier">qy</span><span class="plain">) {</span>
        <span class="identifier">qx</span><span class="plain">-</span><span class="element">&gt;negated_quant</span><span class="plain"> = </span><span class="identifier">qy</span><span class="plain">; </span><span class="identifier">qy</span><span class="plain">-</span><span class="element">&gt;negated_quant</span><span class="plain"> = </span><span class="identifier">qx</span><span class="plain">;</span>
    <span class="plain">}</span>
    <span class="reserved">quantifier</span><span class="plain"> *</span><span class="functiontext">Quantifiers::get_negation</span><span class="plain">(</span><span class="reserved">quantifier</span><span class="plain"> *</span><span class="identifier">quant</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;negated_quant</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Quantifiers::quants_negate_each_other is used in <a href="#SP18_1">&#167;18.1</a>, <a href="#SP18_2">&#167;18.2</a>, <a href="#SP18_3">&#167;18.3</a>, <a href="#SP18_4">&#167;18.4</a>.</p>

<p class="endnote">The function Quantifiers::get_negation appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8.  </b>Logging a quantifier:
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Quantifiers::log</span><span class="plain">(</span><span class="reserved">quantifier</span><span class="plain"> *</span><span class="identifier">quant</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">parameter</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">quant</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) { </span><span class="identifier">LOG</span><span class="plain">(</span><span class="string">"&lt;NULL-QUANTIFIER&gt;"</span><span class="plain">); </span><span class="reserved">return</span><span class="plain">; }</span>
        <span class="identifier">LOG</span><span class="plain">(</span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;log_text</span><span class="plain">, </span><span class="identifier">parameter</span><span class="plain">);</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Quantifiers::log appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Acting on quantifiers. </b>When compiling code to test a proposition which includes a quantifier, we
need to test the cases in the domain set to see how many of them qualify
and how many do not. These counts are stored in local variables called
<code class="display"><span class="extract">qcy_0</span></code>, <code class="display"><span class="extract">qcn_0</span></code> and so on: <code class="display"><span class="extract">qcn</span></code> means "quantifier count number" and is
the size of the domain set, while <code class="display"><span class="extract">qcy</span></code> is the number of "yes" cases.
Thus if the original source text read:
</p>

<blockquote>
    <p>if most of the closed doors are locked, ...</p>

</blockquote>

<p class="inwebparagraph"><code class="display"><span class="extract">qcy_0</span></code> will be the number of closed doors which turned out to be locked
and <code class="display"><span class="extract">qcn_0</span></code> the total number of closed doors. (The indices <code class="display"><span class="extract">_0</span></code>, <code class="display"><span class="extract">_1</span></code>, ...,
are used because the same routine may have to compile code to test several
quantifiers.)
</p>

<p class="inwebparagraph">The following routine compiles an I6 condition to test whether the
tallies are acceptable for the given quantifier. In the example above,
the quantifier is <code class="display"><span class="extract">Proportion&gt;50%</span></code>, and compiles to the test:
</p>

<p class="inwebparagraph"></p>


<pre class="display">
        <span class="plain">qcy_0 &gt; 5*qcn_0/10</span>
</pre>

<p class="inwebparagraph">(It looks a little wasteful to multiply by 5 and then divide by 10, but
I6 will fold that out in eventual code generation. When the proportion is
0/10ths or 10/10ths, though, we do generate simpler code, mostly so that
the resulting I6 is more legible.)
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Quantifiers::compile_test</span><span class="plain">(</span><span class="identifier">OUTPUT_STREAM</span><span class="plain">, </span><span class="reserved">quantifier</span><span class="plain"> *</span><span class="identifier">quant</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">index</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">quantification_parameter</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">TC</span><span class="plain"> = </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;T_coefficient</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">TC</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> -1:</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;is_complementary</span><span class="plain">)</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"qcy_%d %s qcn_%d-%d"</span><span class="plain">,</span>
                        <span class="identifier">index</span><span class="plain">, </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator</span><span class="plain">, </span><span class="identifier">index</span><span class="plain">, </span><span class="identifier">quantification_parameter</span><span class="plain">);</span>
                <span class="reserved">else</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"qcy_%d %s %d"</span><span class="plain">,</span>
                        <span class="identifier">index</span><span class="plain">, </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator</span><span class="plain">, </span><span class="identifier">quantification_parameter</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 10:</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"qcy_%d %s qcn_%d"</span><span class="plain">, </span><span class="identifier">index</span><span class="plain">, </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator</span><span class="plain">, </span><span class="identifier">index</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 0:</span>
                <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"qcy_%d %s 0"</span><span class="plain">, </span><span class="identifier">index</span><span class="plain">, </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">strcmp</span><span class="plain">(</span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator</span><span class="plain">, </span><span class="string">"=="</span><span class="plain">) != 0)</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"qcy_%d*10 %s %d*qcn_%d"</span><span class="plain">, </span><span class="identifier">index</span><span class="plain">, </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator</span><span class="plain">, </span><span class="identifier">TC</span><span class="plain">, </span><span class="identifier">index</span><span class="plain">);</span>
                <span class="reserved">else</span>
                    <span class="identifier">WRITE</span><span class="plain">(</span><span class="string">"qcy_%d %s %d*qcn_%d/10"</span><span class="plain">, </span><span class="identifier">index</span><span class="plain">, </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator</span><span class="plain">, </span><span class="identifier">TC</span><span class="plain">, </span><span class="identifier">index</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
    <span class="plain">}</span>

    <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">CORE_MODULE</span>
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Quantifiers::emit_test</span><span class="plain">(</span><span class="reserved">quantifier</span><span class="plain"> *</span><span class="identifier">quant</span><span class="plain">,</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">quantification_parameter</span><span class="plain">, </span><span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">qcy</span><span class="plain">, </span><span class="identifier">inter_symbol</span><span class="plain"> *</span><span class="identifier">qcn</span><span class="plain">) {</span>

        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator_prim</span><span class="plain">);</span>
        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>

        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">TC</span><span class="plain"> = </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;T_coefficient</span><span class="plain">;</span>
        <span class="reserved">switch</span><span class="plain"> (</span><span class="identifier">TC</span><span class="plain">) {</span>
            <span class="reserved">case</span><span class="plain"> -1:</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;is_complementary</span><span class="plain">) {</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">qcy</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">MINUS_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">qcn</span><span class="plain">);</span>
                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="identifier">quantification_parameter</span><span class="plain">);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">qcy</span><span class="plain">);</span>
                    <span class="identifier">Produce::val</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="identifier">quantification_parameter</span><span class="plain">);</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 10:</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">qcy</span><span class="plain">);</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">qcn</span><span class="plain">);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">case</span><span class="plain"> 0:</span>
                <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">qcy</span><span class="plain">);</span>
                <span class="identifier">Produce::val</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 0);</span>
                <span class="reserved">break</span><span class="plain">;</span>
            <span class="reserved">default</span><span class="plain">:</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;operator_prim</span><span class="plain"> != </span><span class="identifier">EQ_BIP</span><span class="plain">) {</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">TIMES_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">qcy</span><span class="plain">);</span>
                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 10);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">TIMES_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="identifier">TC</span><span class="plain">);</span>
                        <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">qcn</span><span class="plain">);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="plain">} </span><span class="reserved">else</span><span class="plain"> {</span>
                    <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">qcy</span><span class="plain">);</span>
                    <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">DIVIDE_BIP</span><span class="plain">);</span>
                    <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::inv_primitive</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">TIMES_BIP</span><span class="plain">);</span>
                        <span class="identifier">Produce::down</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                            <span class="identifier">Produce::val</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, (</span><span class="identifier">inter_t</span><span class="plain">) </span><span class="identifier">TC</span><span class="plain">);</span>
                            <span class="identifier">Produce::val_symbol</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_value</span><span class="plain">, </span><span class="identifier">qcn</span><span class="plain">);</span>
                        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                        <span class="identifier">Produce::val</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">(), </span><span class="identifier">K_number</span><span class="plain">, </span><span class="identifier">LITERAL_IVAL</span><span class="plain">, 10);</span>
                    <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
                <span class="plain">}</span>
                <span class="reserved">break</span><span class="plain">;</span>
        <span class="plain">}</span>
        <span class="identifier">Produce::up</span><span class="plain">(</span><span class="identifier">Emit::tree</span><span class="plain">());</span>
    <span class="plain">}</span>
    <span class="plain">#</span><span class="identifier">endif</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Quantifiers::compile_test appears nowhere else.</p>

<p class="endnote">The function Quantifiers::emit_test appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10.  </b>"Now" is the Inform way to assert that a proposition should now be made
true. Many quantifiers obstruct this, by introducing too much vagueness.
For instance, "now three doors are open" is dangerously vague because it
doesn't say which doors are to be made open; similarly "now most of the
coins are in the box". On the other hand, "now all the coins are in the
box" is fine, because there's no ambiguity. The <code class="display"><span class="extract">can_be_used_in_now</span></code> flag for
a quantifier shows whether it can be asserted in "now" like this.
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Quantifiers::is_now_assertable</span><span class="plain">(</span><span class="reserved">quantifier</span><span class="plain"> *</span><span class="identifier">quant</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;can_be_used_in_now</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Quantifiers::is_now_assertable appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11.  </b>Not every proposition can be used in assertion sentences, either, and
again it's the quantifiers which cause the trouble. For instance, "Not
every room is dark." gives Inform too little to act on. Which room(s)
should it make lighted?
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Quantifiers::can_be_used_in_assertions</span><span class="plain">(</span><span class="reserved">quantifier</span><span class="plain"> *</span><span class="identifier">quant</span><span class="plain">) {</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">quant</span><span class="plain">-</span><span class="element">&gt;can_be_used_in_assertions</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Quantifiers::can_be_used_in_assertions appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Creating a determiner. </b>Again, at present there's only the built-in set, but we want to keep our
options open.
</p>


<pre class="definitions">
    <span class="definitionkeyword">define</span> <span class="constant">ALL_DET_NAME</span><span class="plain"> 0</span>
    <span class="definitionkeyword">define</span> <span class="constant">EACH_DET_NAME</span><span class="plain"> 1</span>
    <span class="definitionkeyword">define</span> <span class="constant">EVERY_DET_NAME</span><span class="plain"> 2</span>
    <span class="definitionkeyword">define</span> <span class="constant">NO_DET_NAME</span><span class="plain"> 3</span>
    <span class="definitionkeyword">define</span> <span class="constant">NONE_DET_NAME</span><span class="plain"> 4</span>
    <span class="definitionkeyword">define</span> <span class="constant">SOME_DET_NAME</span><span class="plain"> 5</span>
    <span class="definitionkeyword">define</span> <span class="constant">ANY_DET_NAME</span><span class="plain"> 6</span>
    <span class="definitionkeyword">define</span> <span class="constant">ALL_BUT_DET_NAME</span><span class="plain"> 7</span>
    <span class="definitionkeyword">define</span> <span class="constant">ALL_EXCEPT_DET_NAME</span><span class="plain"> 8</span>
    <span class="definitionkeyword">define</span> <span class="constant">ALMOST_ALL_DET_NAME</span><span class="plain"> 9</span>
    <span class="definitionkeyword">define</span> <span class="constant">ALMOST_NO_DET_NAME</span><span class="plain"> 10</span>
    <span class="definitionkeyword">define</span> <span class="constant">MOST_DET_NAME</span><span class="plain"> 11</span>
    <span class="definitionkeyword">define</span> <span class="constant">UNDER_HALF_DET_NAME</span><span class="plain"> 12</span>
    <span class="definitionkeyword">define</span> <span class="constant">AT_LEAST_DET_NAME</span><span class="plain"> 13</span>
    <span class="definitionkeyword">define</span> <span class="constant">AT_MOST_DET_NAME</span><span class="plain"> 14</span>
    <span class="definitionkeyword">define</span> <span class="constant">EXACTLY_DET_NAME</span><span class="plain"> 15</span>
    <span class="definitionkeyword">define</span> <span class="constant">FEWER_THAN_DET_NAME</span><span class="plain"> 16</span>
    <span class="definitionkeyword">define</span> <span class="constant">LESS_THAN_DET_NAME</span><span class="plain"> 17</span>
    <span class="definitionkeyword">define</span> <span class="constant">MORE_THAN_DET_NAME</span><span class="plain"> 18</span>
    <span class="definitionkeyword">define</span> <span class="constant">GREATER_THAN_DET_NAME</span><span class="plain"> 19</span>
    <span class="definitionkeyword">define</span> <span class="constant">OTHER_THAN_DET_NAME</span><span class="plain"> 20</span>
</pre>

<pre class="display">
    <span class="reserved">determiner</span><span class="plain"> *</span><span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">not</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">pr</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">num</span><span class="plain">, </span><span class="reserved">quantifier</span><span class="plain"> *</span><span class="identifier">quant</span><span class="plain">, </span><span class="reserved">char</span><span class="plain"> *</span><span class="identifier">text</span><span class="plain">) {</span>
        <span class="identifier">word_assemblage</span><span class="plain"> </span><span class="identifier">wa</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">pr</span><span class="plain"> &lt; 0) </span><span class="identifier">wa</span><span class="plain"> = </span><span class="identifier">WordAssemblages::lit_0</span><span class="plain">();</span>
        <span class="reserved">else</span><span class="plain"> </span><span class="identifier">wa</span><span class="plain"> = </span><span class="identifier">Preform::Nonparsing::wording</span><span class="plain">(&lt;</span><span class="reserved">determiner</span><span class="plain">-</span><span class="identifier">names</span><span class="plain">&gt;, </span><span class="identifier">pr</span><span class="plain">);</span>
        <span class="reserved">determiner</span><span class="plain"> *</span><span class="identifier">det</span><span class="plain"> = </span><span class="identifier">CREATE</span><span class="plain">(</span><span class="reserved">determiner</span><span class="plain">);</span>
        <span class="identifier">det</span><span class="plain">-</span><span class="element">&gt;text_of_det</span><span class="plain"> = </span><span class="identifier">wa</span><span class="plain">;</span>
        <span class="identifier">det</span><span class="plain">-</span><span class="element">&gt;takes_number</span><span class="plain"> = </span><span class="identifier">num</span><span class="plain">;</span>
        <span class="identifier">det</span><span class="plain">-</span><span class="element">&gt;allows_prefixed_not</span><span class="plain"> = </span><span class="identifier">not</span><span class="plain">;</span>
        <span class="identifier">det</span><span class="plain">-</span><span class="element">&gt;quantifier_meant</span><span class="plain"> = </span><span class="identifier">quant</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">quant</span><span class="plain"> == </span><span class="identifier">NULL</span><span class="plain">) </span><span class="identifier">internal_error</span><span class="plain">(</span><span class="string">"created meaningless quantifier"</span><span class="plain">);</span>
        <span class="identifier">det</span><span class="plain">-</span><span class="element">&gt;index_text</span><span class="plain"> = </span><span class="identifier">text</span><span class="plain">;</span>
        <span class="plain">#</span><span class="identifier">ifdef</span><span class="plain"> </span><span class="identifier">CORE_MODULE</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">text</span><span class="plain">)</span>
            <span class="identifier">Index::Lexicon::new_entry_with_details</span><span class="plain">(</span>
                <span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">MISCELLANEOUS_LEXE</span><span class="plain">, </span><span class="identifier">wa</span><span class="plain">, </span><span class="string">"determiner"</span><span class="plain">, </span><span class="identifier">text</span><span class="plain">);</span>
        <span class="plain">#</span><span class="identifier">endif</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">det</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Quantifiers::det_new is used in <a href="#SP18_1">&#167;18.1</a>, <a href="#SP18_2">&#167;18.2</a>, <a href="#SP18_3">&#167;18.3</a>, <a href="#SP18_4">&#167;18.4</a>.</p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13.  </b>Inform supports a built-in set of sixteen generalised quantifiers, in
logical terms, and English maps onto these with a rather less elegantly
structured set of twenty wordings. One of these doesn't appear below because
it's empty of text: this is the determiner in "three blind mice", where
no text appears in front of the number "three".
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="reserved">determiner</span><span class="plain">-</span><span class="identifier">names</span><span class="plain">&gt; ::=</span>
        <span class="identifier">all</span><span class="plain"> |</span>
        <span class="identifier">each</span><span class="plain"> |</span>
        <span class="identifier">every</span><span class="plain"> |</span>
        <span class="identifier">no</span><span class="plain"> |</span>
        <span class="identifier">none</span><span class="plain"> |</span>
        <span class="identifier">some</span><span class="plain"> |</span>
        <span class="identifier">any</span><span class="plain"> |</span>
        <span class="identifier">all</span><span class="plain"> </span><span class="identifier">but</span><span class="plain"> |</span>
        <span class="identifier">all</span><span class="plain"> </span><span class="identifier">except</span><span class="plain"> |</span>
        <span class="identifier">almost</span><span class="plain"> </span><span class="identifier">all</span><span class="plain"> |</span>
        <span class="identifier">almost</span><span class="plain"> </span><span class="identifier">no</span><span class="plain"> |</span>
        <span class="identifier">most</span><span class="plain"> |</span>
        <span class="identifier">under</span><span class="plain"> </span><span class="identifier">half</span><span class="plain"> |</span>
        <span class="identifier">at</span><span class="plain"> </span><span class="identifier">least</span><span class="plain"> |</span>
        <span class="identifier">at</span><span class="plain"> </span><span class="identifier">most</span><span class="plain"> |</span>
        <span class="identifier">exactly</span><span class="plain"> |</span>
        <span class="identifier">fewer</span><span class="plain"> </span><span class="identifier">than</span><span class="plain"> |</span>
        <span class="identifier">less</span><span class="plain"> </span><span class="identifier">than</span><span class="plain"> |</span>
        <span class="identifier">more</span><span class="plain"> </span><span class="identifier">than</span><span class="plain"> |</span>
        <span class="identifier">greater</span><span class="plain"> </span><span class="identifier">than</span><span class="plain"> |</span>
        <span class="identifier">other</span><span class="plain"> </span><span class="identifier">than</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Parsing the determiner at the head of a noun phrase. </b>We run through the possible determiners in reverse creation order, choosing the
first which matches. The following returns -1 if nothing was found, or
else the first word number after the determiner words, and in that case
it also writes a pointer to the quantifier meant to <code class="display"><span class="extract">*which_quant</span></code> and the
parameter value to <code class="display"><span class="extract">*which_P</span></code>.
</p>

<p class="inwebparagraph">(Reverse order is used really only to make sure "all but" and "all except"
are tried before "all".)
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Quantifiers::parse_against_text</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">which_P</span><span class="plain">, </span><span class="reserved">quantifier</span><span class="plain"> **</span><span class="identifier">which_quant</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">excluded</span><span class="plain">-</span><span class="identifier">from</span><span class="plain">-</span><span class="identifier">determiners</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> -1;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">not_flag</span><span class="plain"> = &lt;</span><span class="identifier">negated</span><span class="plain">-</span><span class="identifier">clause</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">not_flag</span><span class="plain">) </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">negated</span><span class="plain">-</span><span class="identifier">clause</span><span class="plain">&gt;, 1);</span>

        <span class="plain">*</span><span class="identifier">which_P</span><span class="plain"> = -1; *</span><span class="identifier">which_quant</span><span class="plain"> = </span><span class="identifier">NULL</span><span class="plain">;</span>

        <span class="reserved">determiner</span><span class="plain"> *</span><span class="identifier">det</span><span class="plain">;</span>
        <span class="identifier">LOOP_BACKWARDS_OVER</span><span class="plain">(</span><span class="identifier">det</span><span class="plain">, </span><span class="reserved">determiner</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">not_flag</span><span class="plain">) &amp;&amp; (</span><span class="identifier">det</span><span class="plain">-</span><span class="element">&gt;allows_prefixed_not</span><span class="plain"> == </span><span class="identifier">FALSE</span><span class="plain">)) </span><span class="reserved">continue</span><span class="plain">;</span>
            <span class="identifier">wording</span><span class="plain"> </span><span class="identifier">XW</span><span class="plain"> = </span><span class="functiontext">Quantifiers::det_parse_against_text</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">det</span><span class="plain">, </span><span class="identifier">which_P</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::nonempty</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">)) {</span>
                <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">not_flag</span><span class="plain">) *</span><span class="identifier">which_quant</span><span class="plain"> = </span><span class="identifier">det</span><span class="plain">-</span><span class="element">&gt;quantifier_meant</span><span class="plain">-</span><span class="element">&gt;negated_quant</span><span class="plain">;</span>
                <span class="reserved">else</span><span class="plain"> *</span><span class="identifier">which_quant</span><span class="plain"> = </span><span class="identifier">det</span><span class="plain">-</span><span class="element">&gt;quantifier_meant</span><span class="plain">;</span>
                <span class="reserved">return</span><span class="plain"> </span><span class="identifier">Wordings::first_wn</span><span class="plain">(</span><span class="identifier">XW</span><span class="plain">);</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="reserved">return</span><span class="plain"> -1;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Quantifiers::parse_against_text appears nowhere else.</p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15.  </b>We look for a determiner at the start of a noun phrase; this can sometimes
be followed by a number. For example,
</p>

<blockquote>
    <p>More than three doors</p>

</blockquote>

<p class="inwebparagraph">matches "more than" from the selection above, then the number "three".
It's legal to include "of the":
</p>

<blockquote>
    <p>three of the doors are open</p>

</blockquote>

<p class="inwebparagraph">but not "of" on its own: this reduces misunderstandings when objects have
names like "three of clubs", meaning a single playing card.
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">determination</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">&gt; ::=</span>
        <span class="identifier">of</span><span class="plain"> </span><span class="identifier">the</span><span class="plain"> ... |		==&gt; </span><span class="identifier">TRUE</span>
        <span class="identifier">of</span><span class="plain"> ... |			==&gt; </span><span class="identifier">TRUE</span><span class="plain">; </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">FAIL_NONTERMINAL</span>
        <span class="plain">...					==&gt; </span><span class="identifier">TRUE</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16.  </b>English has an awkward ambiguity here: what does this mean?
</p>

<blockquote>
    <p>no one</p>

</blockquote>

<p class="inwebparagraph">Inform would normally read this as the determiner "no" followed by the
number "one", not realising that "one" is more likely to refer to a
kind (i.e., people and not things) rather than counting something. We want
to stop this reading, so that we can read "no one" as if it were "nobody".
</p>

<p class="inwebparagraph">The following grammar is provided to list noun phrases which will be immune
from determiner parsing:
</p>


<pre class="display">
    <span class="plain">&lt;</span><span class="identifier">excluded</span><span class="plain">-</span><span class="identifier">from</span><span class="plain">-</span><span class="identifier">determiners</span><span class="plain">&gt; ::=</span>
        <span class="identifier">no</span><span class="plain"> </span><span class="identifier">one</span><span class="plain"> ***</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17.  </b>We attempt to see if the word range begins with (or consists of) text which
refers to the given determiner, returning the first word past this text and
also (where appropriate) setting the number specified. For instance, for
"at least three doors are open" and the <code class="display"><span class="extract">at_least_determiner</span></code> we would
return the word "doors" and set <code class="display"><span class="extract">which_P</span></code> to 3.
</p>


<pre class="display">
    <span class="identifier">wording</span><span class="plain"> </span><span class="functiontext">Quantifiers::det_parse_against_text</span><span class="plain">(</span><span class="identifier">wording</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">, </span><span class="reserved">determiner</span><span class="plain"> *</span><span class="identifier">det</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> *</span><span class="identifier">which_P</span><span class="plain">) {</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">parameter</span><span class="plain"> = -1;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">;</span>
        <span class="reserved">int</span><span class="plain"> </span><span class="identifier">x</span><span class="plain"> = </span><span class="identifier">WordAssemblages::parse_as_weakly_initial_text</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, &amp;(</span><span class="identifier">det</span><span class="plain">-</span><span class="element">&gt;text_of_det</span><span class="plain">),</span>
            <span class="identifier">EMPTY_WORDING</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">);</span>
        <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Wordings::from</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">, </span><span class="identifier">x</span><span class="plain">);</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">det</span><span class="plain">-</span><span class="element">&gt;takes_number</span><span class="plain">) {</span>
            <span class="reserved">if</span><span class="plain"> ((&lt;</span><span class="identifier">cardinal</span><span class="plain">-</span><span class="identifier">number</span><span class="plain">&gt;(</span><span class="identifier">Wordings::one_word</span><span class="plain">(</span><span class="identifier">x</span><span class="plain">)) == </span><span class="identifier">FALSE</span><span class="plain">) ||</span>
                <span class="plain">(</span><span class="identifier">Word::unexpectedly_upper_case</span><span class="plain">(</span><span class="identifier">x</span><span class="plain">))) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
            <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">Wordings::trim_first_word</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
            <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">Wordings::empty</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">;</span>
            <span class="identifier">parameter</span><span class="plain"> = &lt;&lt;</span><span class="identifier">r</span><span class="plain">&gt;&gt;;</span>
        <span class="plain">}</span>
        <span class="reserved">if</span><span class="plain"> (&lt;</span><span class="identifier">determination</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">&gt;(</span><span class="identifier">W</span><span class="plain">)) {</span>
            <span class="identifier">W</span><span class="plain"> = </span><span class="identifier">GET_RW</span><span class="plain">(&lt;</span><span class="identifier">determination</span><span class="plain">-</span><span class="identifier">of</span><span class="plain">&gt;, 1);</span>
            <span class="plain">*</span><span class="identifier">which_P</span><span class="plain"> = </span><span class="identifier">parameter</span><span class="plain">;</span>
            <span class="identifier">W</span><span class="plain"> = </span><span class="functiontext">Articles::remove_the</span><span class="plain">(</span><span class="identifier">W</span><span class="plain">);</span>
        <span class="plain">} </span><span class="reserved">else</span><span class="plain"> </span><span class="identifier">W</span><span class="plain"> = </span><span class="identifier">EMPTY_WORDING</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">W</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Quantifiers::det_parse_against_text is used in <a href="#SP14">&#167;14</a>.</p>

<p class="inwebparagraph"><a id="SP18"></a><b>&#167;18. The built-in set. </b>We now construct both the tidy logical world of 16 quantifiers in matched
pairs, and also a higgledy-piggledy world of 20 English-language determiners
referring to them. There are four broad families which we take in turn.
</p>


<pre class="display">
    <span class="reserved">void</span><span class="plain"> </span><span class="functiontext">Quantifiers::make_built_in</span><span class="plain">(</span><span class="reserved">void</span><span class="plain">) {</span>
        &lt;<span class="cwebmacro">Make traditional quantification determiners</span> <span class="cwebmacronumber">18.1</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Make complement comparison determiners</span> <span class="cwebmacronumber">18.2</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Make proportion determiners</span> <span class="cwebmacronumber">18.3</span>&gt;<span class="plain">;</span>
        &lt;<span class="cwebmacro">Make cardinality quantification determiners</span> <span class="cwebmacronumber">18.4</span>&gt;<span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Quantifiers::make_built_in is used in 1/lm (<a href="1-lm.html#SP4">&#167;4</a>).</p>

<p class="inwebparagraph"><a id="SP18_1"></a><b>&#167;18.1.  </b>As discussed above, the two traditional quantifiers in logic are "for
all" and "there exists", usually written in mathematical notation as
 and , but we also need to create their negation
quantifiers. So we end up with four: <code class="display"><span class="extract">ForAll</span></code>, <code class="display"><span class="extract">NotAll</span></code>, <code class="display"><span class="extract">Exists</span></code> and
<code class="display"><span class="extract">DoesNotExist</span></code>.
</p>

<p class="inwebparagraph">The for-all quantifier can be used in assertions for a slightly oddball
reason: it's how the source text makes assemblies. For instance,
</p>

<blockquote>
    <p>A nose is part of every person.</p>

</blockquote>

<p class="inwebparagraph">The "every" is parsed as a use of <code class="display"><span class="extract">ForAll</span></code>. Strictly speaking this
sentence should be read as creating a single nose which would be shared
by all of the people. But the presence of a <code class="display"><span class="extract">ForAll</span></code> quantifier in an
assertion causes the A-parser to interpret the sentence differently, and to
create a fresh nose for each person. (There are some restrictions on the
use of <code class="display"><span class="extract">ForAll</span></code> in this way, but they are enforced in the A-parser: our
part here is simply to authorise <code class="display"><span class="extract">ForAll</span></code> in assertions.)
</p>

<p class="inwebparagraph">Something which English allows, but Inform does not, is the use of "all"
in a way which also specifies a cardinality. For instance, the following
condition:
</p>

<blockquote>
    <p>if all six doors are open, ...</p>

</blockquote>

<p class="inwebparagraph">is an attempt to use a determiner which Inform does not possess &mdash; "all"
plus number. We don't allow this because if there happen to be eight doors,
say, the condition would be meaningless.
</p>

<p class="inwebparagraph">It's an example of the irregularity of English that you can say "not every
door is open" but would never say "not each door is open". In all other
respects "each" and "every" are synonymous in the S-parser.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make traditional quantification determiners</span> <span class="cwebmacronumber">18.1</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">for_all_quantifier</span><span class="plain">     = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"=="</span><span class="plain">, 10, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"ForAll"</span><span class="plain">);</span>
        <span class="identifier">not_for_all_quantifier</span><span class="plain"> = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"&lt;"</span><span class="plain">, 10, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"NotAll"</span><span class="plain">);</span>
        <span class="identifier">exists_quantifier</span><span class="plain">      = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"&gt;"</span><span class="plain">, 0, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"Exists"</span><span class="plain">);</span>
        <span class="identifier">not_exists_quantifier</span><span class="plain">  = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"=="</span><span class="plain">, 0, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"DoesNotExist"</span><span class="plain">);</span>

        <span class="identifier">for_all_quantifier</span><span class="plain">-</span><span class="element">&gt;can_be_used_in_now</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">for_all_quantifier</span><span class="plain">-</span><span class="element">&gt;can_be_used_in_assertions</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="identifier">not_exists_quantifier</span><span class="plain">-</span><span class="element">&gt;can_be_used_in_now</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>

        <span class="functiontext">Quantifiers::quants_negate_each_other</span><span class="plain">(</span><span class="identifier">for_all_quantifier</span><span class="plain">, </span><span class="identifier">not_for_all_quantifier</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::quants_negate_each_other</span><span class="plain">(</span><span class="identifier">exists_quantifier</span><span class="plain">, </span><span class="identifier">not_exists_quantifier</span><span class="plain">);</span>

        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">TRUE</span><span class="plain">, </span><span class="constant">ALL_DET_NAME</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">for_all_quantifier</span><span class="plain">,</span>
            <span class="string">"used in conditions: 'if all of the doors are open'"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">EACH_DET_NAME</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">for_all_quantifier</span><span class="plain">,</span>
            <span class="string">"- see &lt;/i&gt;all&lt;i&gt;"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">TRUE</span><span class="plain">, </span><span class="constant">EVERY_DET_NAME</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">for_all_quantifier</span><span class="plain">,</span>
            <span class="string">"- see &lt;/i&gt;all&lt;i&gt;, and can also be used in generalisations such as "</span>
            <span class="string">"'A nose is part of every person.'"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">NO_DET_NAME</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">not_exists_quantifier</span><span class="plain">,</span>
            <span class="string">"opposite of 'all': 'if no door is open...'"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">NONE_DET_NAME</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">not_exists_quantifier</span><span class="plain">,</span>
            <span class="string">"opposite of 'all of': 'if none of the doors is open...'"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">SOME_DET_NAME</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">exists_quantifier</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">ANY_DET_NAME</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">exists_quantifier</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_2"></a><b>&#167;18.2.  </b>Here T=-1, because we are counting actual numbers of matches rather than
a proportion of matches. But these quantifiers count downwards from the total:
thus "all but six" means there have to be exactly S-6 matching items,
where S is the total available. The only logical negation for this
quantifier would be "other than S-6", which is too unnatural a
construction to have any natural English paraphrase, so we do not make a
<code class="display"><span class="extract">determiner *</span></code> structure pointing to it. But we create it in order that the
built-in quantifiers all occur in negation pairs.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make complement comparison determiners</span> <span class="cwebmacronumber">18.2</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">all_but_quantifier</span><span class="plain">     = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"=="</span><span class="plain">, -1, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="string">"AllBut%d"</span><span class="plain">);</span>
        <span class="identifier">not_all_but_quantifier</span><span class="plain"> = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"~="</span><span class="plain">, -1, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="string">"NotAllBut%d"</span><span class="plain">);</span>

        <span class="functiontext">Quantifiers::quants_negate_each_other</span><span class="plain">(</span><span class="identifier">all_but_quantifier</span><span class="plain">, </span><span class="identifier">not_all_but_quantifier</span><span class="plain">);</span>

        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">ALL_BUT_DET_NAME</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">all_but_quantifier</span><span class="plain">,</span>
            <span class="string">"used to count things: 'all but three containers'"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">ALL_EXCEPT_DET_NAME</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">all_but_quantifier</span><span class="plain">,</span>
            <span class="string">"- see &lt;/i&gt;all but&lt;i&gt;"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_3"></a><b>&#167;18.3.  </b>Here the T-coefficient, measuring the proportion needed, has 0 &lt; T &lt; 10.
</p>

<p class="inwebparagraph">We don't support the determiner "half", as in, "if half the doors are open",
because it's ambiguous as to whether it means exactly half or half-or-more.
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make proportion determiners</span> <span class="cwebmacronumber">18.3</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">almost_all_quantifier</span><span class="plain">  = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"&gt;="</span><span class="plain">, 8, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"Proportion&gt;=80%%"</span><span class="plain">);</span>
        <span class="identifier">almost_no_quantifier</span><span class="plain">   = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"&lt;"</span><span class="plain">,  2, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"Proportion&lt;20%%"</span><span class="plain">);</span>
        <span class="identifier">most_quantifier</span><span class="plain">        = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"&gt;"</span><span class="plain">,  5, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"Proportion&gt;50%%"</span><span class="plain">);</span>
        <span class="identifier">under_half_quantifier</span><span class="plain">  = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"&lt;="</span><span class="plain">, 5, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"Proportion&lt;=50%%"</span><span class="plain">);</span>

        <span class="functiontext">Quantifiers::quants_negate_each_other</span><span class="plain">(</span><span class="identifier">almost_all_quantifier</span><span class="plain">, </span><span class="identifier">almost_no_quantifier</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::quants_negate_each_other</span><span class="plain">(</span><span class="identifier">most_quantifier</span><span class="plain">, </span><span class="identifier">under_half_quantifier</span><span class="plain">);</span>

        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">ALMOST_ALL_DET_NAME</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">almost_all_quantifier</span><span class="plain">,</span>
            <span class="string">"used in conditions: true if 80 percent or more possibilities work"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">ALMOST_NO_DET_NAME</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">almost_no_quantifier</span><span class="plain">,</span>
            <span class="string">"used in conditions: true if fewer than 20 percent of possibilities work"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">MOST_DET_NAME</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">most_quantifier</span><span class="plain">,</span>
            <span class="string">"used in conditions: true if a simple majority of possibilities work"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">UNDER_HALF_DET_NAME</span><span class="plain">, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="identifier">under_half_quantifier</span><span class="plain">,</span>
            <span class="string">"used in conditions: true if fewer than half of possibilities work"</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP18_4"></a><b>&#167;18.4.  </b>The usefulness of cardinality quantifiers in logic as applied to
linguistics seems to be an observation due to Barwise and Cooper. They are
a natural generalisation of the for-all and there-exists quantifiers, and
again come in matched pairs.
</p>

<p class="inwebparagraph">The bare number determiner, as in "six doors are open", is perhaps a little
ambiguous in English. We read it as "at least six doors are open", in
distinction to "exactly six doors are open". This is why the at-least
quantifier is allowed in assertions: the assertion sentence "Four coins are
in the strongbox." is read as containing the <code class="display"><span class="extract">Card&gt;=4</span></code> quantifier, not
<code class="display"><span class="extract">Card=4</span></code> one. The advantage of this is that two assertions in a row, such
as
</p>

<blockquote>
    <p>Four coins are in the strongbox. Two coins are in the strongbox.</p>

</blockquote>

<p class="inwebparagraph">can combine to put six coins in the strongbox, rather than having to be
read as contradictory. (It may look improbable that anyone would ever
write that, but of course the two assertions need not be adjacent in
the source text. One might be in an extension, for instance.)
</p>


<p class="macrodefinition"><code class="display">
&lt;<span class="cwebmacrodefn">Make cardinality quantification determiners</span> <span class="cwebmacronumber">18.4</span>&gt; =
</code></p>


<pre class="displaydefn">
        <span class="identifier">at_least_quantifier</span><span class="plain">    = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"&gt;="</span><span class="plain">, -1, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"Card&gt;=%d"</span><span class="plain">);</span>
        <span class="identifier">at_most_quantifier</span><span class="plain">     = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"&lt;="</span><span class="plain">, -1, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"Card&lt;=%d"</span><span class="plain">);</span>
        <span class="identifier">exactly_quantifier</span><span class="plain">     = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"=="</span><span class="plain">, -1, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"Card=%d"</span><span class="plain">);</span>
        <span class="identifier">less_than_quantifier</span><span class="plain">   = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"&lt;"</span><span class="plain">,  -1, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"Card&lt;%d"</span><span class="plain">);</span>
        <span class="identifier">more_than_quantifier</span><span class="plain">   = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"&gt;"</span><span class="plain">,  -1, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"Card&gt;%d"</span><span class="plain">);</span>
        <span class="identifier">other_than_quantifier</span><span class="plain">  = </span><span class="functiontext">Quantifiers::quant_new</span><span class="plain">(</span><span class="string">"~="</span><span class="plain">, -1, </span><span class="identifier">FALSE</span><span class="plain">, </span><span class="string">"Card~=%d"</span><span class="plain">);</span>

        <span class="identifier">at_least_quantifier</span><span class="plain">-</span><span class="element">&gt;can_be_used_in_assertions</span><span class="plain"> = </span><span class="identifier">TRUE</span><span class="plain">;</span>

        <span class="functiontext">Quantifiers::quants_negate_each_other</span><span class="plain">(</span><span class="identifier">at_least_quantifier</span><span class="plain">, </span><span class="identifier">less_than_quantifier</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::quants_negate_each_other</span><span class="plain">(</span><span class="identifier">at_most_quantifier</span><span class="plain">, </span><span class="identifier">more_than_quantifier</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::quants_negate_each_other</span><span class="plain">(</span><span class="identifier">exactly_quantifier</span><span class="plain">, </span><span class="identifier">other_than_quantifier</span><span class="plain">);</span>

        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">AT_LEAST_DET_NAME</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">at_least_quantifier</span><span class="plain">,</span>
            <span class="string">"used to count things: 'at least five doors'"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">AT_MOST_DET_NAME</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">at_most_quantifier</span><span class="plain">,</span>
            <span class="string">"- see &lt;/i&gt;at least&lt;i&gt;"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">EXACTLY_DET_NAME</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">exactly_quantifier</span><span class="plain">,</span>
            <span class="string">"whereas 'if two doors are open' implicitly means 'if at least two "</span>
            <span class="string">"doors are open', 'if exactly two...' makes the count precise"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">TRUE</span><span class="plain">, </span><span class="constant">FEWER_THAN_DET_NAME</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">less_than_quantifier</span><span class="plain">,</span>
            <span class="string">"pedantic way to say &lt;/i&gt;less than&lt;i&gt; when counting"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">TRUE</span><span class="plain">, </span><span class="constant">LESS_THAN_DET_NAME</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">less_than_quantifier</span><span class="plain">,</span>
            <span class="string">"- see &lt;/i&gt;more than&lt;i&gt;"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">TRUE</span><span class="plain">, </span><span class="constant">MORE_THAN_DET_NAME</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">more_than_quantifier</span><span class="plain">,</span>
            <span class="string">"used to count things: 'more than three rooms'"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">TRUE</span><span class="plain">, </span><span class="constant">GREATER_THAN_DET_NAME</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">more_than_quantifier</span><span class="plain">,</span>
            <span class="string">"used to count things: 'greater than three rooms'"</span><span class="plain">);</span>
        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, </span><span class="constant">OTHER_THAN_DET_NAME</span><span class="plain">, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">other_than_quantifier</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>

        <span class="functiontext">Quantifiers::det_new</span><span class="plain">(</span><span class="identifier">FALSE</span><span class="plain">, -1, </span><span class="identifier">TRUE</span><span class="plain">, </span><span class="identifier">at_least_quantifier</span><span class="plain">, </span><span class="identifier">NULL</span><span class="plain">);</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">This code is used in <a href="#SP18">&#167;18</a>.</p>

<p class="inwebparagraph"><a id="SP19"></a><b>&#167;19.  </b>The following question is relevant when simplifying propositions:
</p>


<pre class="display">
    <span class="reserved">int</span><span class="plain"> </span><span class="functiontext">Quantifiers::quant_requires_at_least_one_true_case</span><span class="plain">(</span><span class="reserved">quantifier</span><span class="plain"> *</span><span class="identifier">quant</span><span class="plain">, </span><span class="reserved">int</span><span class="plain"> </span><span class="identifier">parameter</span><span class="plain">) {</span>
        <span class="reserved">if</span><span class="plain"> (</span><span class="identifier">quant</span><span class="plain"> == </span><span class="identifier">exists_quantifier</span><span class="plain">) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> (((</span><span class="identifier">quant</span><span class="plain"> == </span><span class="identifier">exactly_quantifier</span><span class="plain">) || (</span><span class="identifier">quant</span><span class="plain"> == </span><span class="identifier">at_least_quantifier</span><span class="plain">)) &amp;&amp;</span>
            <span class="plain">(</span><span class="identifier">parameter</span><span class="plain"> &gt; 0)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">quant</span><span class="plain"> == </span><span class="identifier">more_than_quantifier</span><span class="plain">) &amp;&amp; (</span><span class="identifier">parameter</span><span class="plain"> &gt;= 0)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">if</span><span class="plain"> ((</span><span class="identifier">quant</span><span class="plain"> == </span><span class="identifier">other_than_quantifier</span><span class="plain">) &amp;&amp; (</span><span class="identifier">parameter</span><span class="plain"> == 0)) </span><span class="reserved">return</span><span class="plain"> </span><span class="identifier">TRUE</span><span class="plain">;</span>
        <span class="reserved">return</span><span class="plain"> </span><span class="identifier">FALSE</span><span class="plain">;</span>
    <span class="plain">}</span>
</pre>

<p class="inwebparagraph"></p>

<p class="endnote">The function Quantifiers::quant_requires_at_least_one_true_case appears nowhere else.</p>

<hr class="tocbar">
<ul class="toc"><li><a href="3-cao.html">Back to 'Cardinals and Ordinals'</a></li><li><a href="3-adj.html">Continue with 'Adjectives'</a></li></ul><hr class="tocbar">
<!--End of weave-->
		</main>
	</body>
</html>

