<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Determiners and Quantifiers</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
	tex: {
		inlineMath: '$', '$'], ['\\(', '\\)'
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Preform-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../index.html">home</a></li>
</ul><h2>Compiler</h2><ul>
<li><a href="../structure.html">structure</a></li>
<li><a href="../inbuildn.html">inbuild</a></li>
<li><a href="../inform7n.html">inform7</a></li>
<li><a href="../intern.html">inter</a></li>
<li><a href="../services.html">services</a></li>
<li><a href="../secrets.html">secrets</a></li>
</ul><h2>Other Tools</h2><ul>
<li><a href="../inblorbn.html">inblorb</a></li>
<li><a href="../indocn.html">indoc</a></li>
<li><a href="../inform6.html">inform6</a></li>
<li><a href="../inpolicyn.html">inpolicy</a></li>
</ul><h2>Resources</h2><ul>
<li><a href="../extensions.html">extensions</a></li>
<li><a href="../kits.html">kits</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=18> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="../../../inweb/index.html">inweb</a></li>
<li><a href="../../../intest/index.html">intest</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Determiners and Quantifiers' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../services.html">Services</a></li><li><a href="index.html">linguistics</a></li><li><a href="index.html#2">Chapter 2: NP Categories</a></li><li><b>Determiners and Quantifiers</b></li></ul></div>
<p class="purpose">To create the determiners found in standard English which refer to collections of things, and to create their meanings as logical quantifiers.</p>

<ul class="toc"><li><a href="2-daq.html#SP1">&#167;1. How these relate</a></li><li><a href="2-daq.html#SP6">&#167;6. Creating a quantifier</a></li><li><a href="2-daq.html#SP9">&#167;9. Acting on quantifiers</a></li><li><a href="2-daq.html#SP12">&#167;12. Creating a determiner</a></li><li><a href="2-daq.html#SP14">&#167;14. Negation</a></li><li><a href="2-daq.html#SP15">&#167;15. Parsing the determiner at the head of a noun phrase</a></li><li><a href="2-daq.html#SP19">&#167;19. The built-in set</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. How these relate. </b>In logic, a "quantifier" appears at the front of a statement which can
apply to many cases, and describes the quantity of cases for which the
statement is true: all of them, some of them, exactly six, and so on.
</p>

<p class="commentary">When a quantifier is used, it "ranges over a domain". The domain is the
set of cases. For instance, in:
</p>

<blockquote>
    <p>if most of the doors are open, ...</p>
</blockquote>

<p class="commentary">the "most of" text is parsed into a quantifier written in the debugging
log as <span class="extract"><span class="extract-syntax">Proportion&gt;50%</span></span>, and the domain is the set of all doors. We then
test the inner condition ("open") for the objects in the domain.
</p>

<p class="commentary">Some quantifiers apply to a proportion of the domain, and the proportion is
measured with a number we will call the \(T\)-coefficient, which is measured in
tenths. Thus a quantifier talking about the entire domain ("all of the
doors are open") will have \(T=10\), while the "most of" example above has
\(T=5\). Other quantifiers apply to an exact number, a "cardinality" in
logic jargon, rather than a proportion: for instance, "three doors are
open". These quantifiers have \(T=-1\).
</p>

<p class="commentary">Finally, a few quantifiers apply not to the cases in the domain which
passed, but to those which didn't, and those are called "complementary"
(because they describe the complement of the domain set). For instance,
"all but six doors are open", where the "six" describes the number
of closed doors and not the number of open ones.
</p>

<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2.  </b>These different ways to describe multiple outcomes are represented in Inform by
<a href="2-daq.html#SP2" class="internal">quantifier</a> structures. One exists for each different meaning supported
by Inform &mdash; <span class="extract"><span class="extract-syntax">ForAll</span></span>, <span class="extract"><span class="extract-syntax">Exists</span></span> and so forth &mdash; except that some quantifiers
take a numerical parameter, and a single <a href="2-daq.html#SP2" class="internal">quantifier</a> structure represents
the meaning for any value of this parameter. For instance, the cardinality
quantifiers <span class="extract"><span class="extract-syntax">Card=3</span></span> and <span class="extract"><span class="extract-syntax">Card=17</span></span> are both represented by the same
quantifier structure, whose pointer is called <span class="extract"><span class="extract-syntax">exactly_quantifier</span></span> below.
This is the result of parsing "exactly three" doors or "exactly 17"
containers, for instance, where the parameter is 3 or 17 respectively.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inter_ti</span><span class="plain-syntax"> </span><span class="identifier-syntax">operator_prim</span><span class="plain-syntax">; </span><span class="comment-syntax"> inter opcode to compare successes against the threshold</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T_coefficient</span><span class="plain-syntax">; </span><span class="comment-syntax"> see above</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">is_complementary</span><span class="plain-syntax">; </span><span class="comment-syntax"> tests the complement of the set, not the set of matches</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">can_be_used_in_now</span><span class="plain-syntax">; </span><span class="comment-syntax"> can be asserted true or false using "now"</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">can_be_used_in_assertions</span><span class="plain-syntax">; </span><span class="comment-syntax"> can be used in assertion sentences</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">negated_quant</span><span class="plain-syntax">; </span><span class="comment-syntax"> the logically converse determiner</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">char</span><span class="plain-syntax"> *</span><span class="identifier-syntax">log_text</span><span class="plain-syntax">; </span><span class="comment-syntax"> to be used in the debugging log when logging propositions</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">quantifier</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure quantifier is private to this section.</li></ul>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3.  </b>The built-in set of 16 quantifiers, arranged in eight pairs, is as follows:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">quantifier</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">for_all_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,    *</span><span class="identifier-syntax">not_for_all_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">exists_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,     *</span><span class="identifier-syntax">not_exists_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">all_but_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,    *</span><span class="identifier-syntax">not_all_but_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">almost_all_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, *</span><span class="identifier-syntax">almost_no_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">most_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,       *</span><span class="identifier-syntax">under_half_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">at_least_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,   *</span><span class="identifier-syntax">more_than_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">at_most_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,    *</span><span class="identifier-syntax">less_than_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">exactly_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,    *</span><span class="identifier-syntax">other_than_quantifier</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4.  </b>Whereas "quantifier" is a term from mathematical logic, "determiner"
is a term from linguistics which approximately &mdash; but only approximately &mdash;
means the same thing.
</p>

<p class="commentary">The determiner is the part of a noun phrase, always its head, which gives
counting information to be combined with a common noun. Thus "the" clock,
"seven" seals, "almost all of the" open doors, and so on. When a
determiner appears to refer to a range of objects rather than a single
item, Inform translates it into a quantifier. Thus "the" clock is not parsed
into a quantifier, but "all but three" rooms is.
</p>

<p class="commentary">The same quantifier can have several different verbal forms. For instance,
"each" container and "every" container mean the same thing: both
apply the <span class="extract"><span class="extract-syntax">ForAll</span></span> quantifier to containers. These different verbal forms
are stored in the <span class="extract"><span class="extract-syntax">determiner</span></span> structure, and each one points to the
<span class="extract"><span class="extract-syntax">quantifier</span></span> structure which is its meaning.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">determiner</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">allows_prefixed_not</span><span class="plain-syntax">; </span><span class="comment-syntax"> can the word "not" come before this?</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">word_assemblage</span><span class="plain-syntax"> </span><span class="identifier-syntax">text_of_det</span><span class="plain-syntax">; </span><span class="comment-syntax"> which is allowed to be empty</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">takes_number</span><span class="plain-syntax">; </span><span class="comment-syntax"> does a number follow? (e.g. for "at least N"</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">quantifier_meant</span><span class="plain-syntax">; </span><span class="comment-syntax"> meaning of this quantifier</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">char</span><span class="plain-syntax"> *</span><span class="identifier-syntax">index_text</span><span class="plain-syntax">; </span><span class="comment-syntax"> used in the Phrasebook index lexicon</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">linguistic_stock_item</span><span class="plain-syntax"> *</span><span class="identifier-syntax">in_stock</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">determiner</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure determiner is accessed in 2/adj, 2/art, 2/nns, 2/prn, 3/vrb, 3/vu, 3/prp and here.</li></ul>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5.  </b>Determiners are a grammatical category:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">grammatical_category</span><span class="plain-syntax"> *</span><span class="identifier-syntax">determiners_category</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Quantifiers::create_category</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">Quantifiers::create_category</span></span>:<br/>Stock Control - <a href="1-sc.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">determiners_category</span><span class="plain-syntax"> = </span><a href="1-sc.html#SP3" class="function-link"><span class="function-syntax">Stock::new_category</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"determiner"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">determiners_category</span><span class="plain-syntax">, </span><span class="constant-syntax">LOG_GRAMMATICAL_CATEGORY_MTID</span><span class="plain-syntax">, </span><a href="2-daq.html#SP5" class="function-link"><span class="function-syntax">Quantifiers::log_item</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Quantifiers::log_item</span><span class="plain-syntax">(</span><span class="reserved-syntax">grammatical_category</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cat</span><span class="plain-syntax">, </span><span class="identifier-syntax">general_pointer</span><span class="plain-syntax"> </span><span class="identifier-syntax">data</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">determiner</span><span class="plain-syntax"> *</span><span class="identifier-syntax">D</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RETRIEVE_POINTER_determiner</span><span class="plain-syntax">(</span><span class="identifier-syntax">data</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"'%A' --&gt; %s"</span><span class="plain-syntax">, &amp;(</span><span class="identifier-syntax">D</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">text_of_det</span><span class="plain-syntax">), </span><span class="identifier-syntax">D</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">quantifier_meant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">log_text</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6. Creating a quantifier. </b>At present, there's only the built-in set, and no method exists to create
new quantifiers from the source text or the template files, but what follows
is written so that it would be fairly easy to add this ability.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="function-syntax">Quantifiers::quant_new</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">Quantifiers::quant_new</span></span>:<br/><a href="2-daq.html#SP19_1">&#167;19.1</a>, <a href="2-daq.html#SP19_2">&#167;19.2</a>, <a href="2-daq.html#SP19_3">&#167;19.3</a>, <a href="2-daq.html#SP19_4">&#167;19.4</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">op</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">is_comp</span><span class="plain-syntax">, </span><span class="reserved-syntax">char</span><span class="plain-syntax"> *</span><span class="identifier-syntax">text</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">quant</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">quantifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">op</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"=="</span><span class="plain-syntax">))      </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">operator_prim</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EQ_BIP</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">op</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"~="</span><span class="plain-syntax">)) </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">operator_prim</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NE_BIP</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">op</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"&gt;="</span><span class="plain-syntax">)) </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">operator_prim</span><span class="plain-syntax"> = </span><span class="identifier-syntax">GE_BIP</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">op</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"&gt;"</span><span class="plain-syntax">))  </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">operator_prim</span><span class="plain-syntax"> = </span><span class="identifier-syntax">GT_BIP</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">op</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;="</span><span class="plain-syntax">)) </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">operator_prim</span><span class="plain-syntax"> = </span><span class="identifier-syntax">LE_BIP</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">op</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;"</span><span class="plain-syntax">))  </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">operator_prim</span><span class="plain-syntax"> = </span><span class="identifier-syntax">LT_BIP</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"unfamiliar operator"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">T_coefficient</span><span class="plain-syntax"> = </span><span class="identifier-syntax">T</span><span class="plain-syntax">; </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">is_complementary</span><span class="plain-syntax"> = </span><span class="identifier-syntax">is_comp</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">can_be_used_in_now</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">can_be_used_in_assertions</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_quant</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">log_text</span><span class="plain-syntax"> = </span><span class="identifier-syntax">text</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">quant</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7.  </b>That fills out the whole structure except for the negation pointers, and
to ensure that these always occur in matched pairs, these are set here.
</p>

<p class="commentary">A little explanation may be useful about what we mean by negation. In
traditional logic, the basic quantifiers "for all" and "there exists"
are dual to each other in that they are related by a sort of negation:
"there does not exist an open door" means the same as "all doors are
closed", and so on. Thus
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">Not ( ForAll x: P(x) )</span></span> is equivalent to <span class="extract"><span class="extract-syntax">Exists x: Not(P(x))</span></span>
</p>

<p class="commentary">That isn't what we mean here. If \(Q\) and \(NQ\) are a quantifier and its
negation in our sense, then:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">Not ( Q x: P(x) )</span></span> is equivalent to <span class="extract"><span class="extract-syntax">NQ x: P(x)</span></span>
</p>

<p class="commentary">Why do we do this? There are several reasons. First, we are using a richer
set of quantifiers than traditional logic provides, and most of these have
natural negations which we were going to be creating anyway &mdash; so we may
as well exploit that. Second, we are going to try to represent propositions
using as much conjunction ("and") and as little disjunction ("or") as
possible. Consider what effect de Morgan's laws have if we simplify:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">Not ( ForAll x: closed(x) and locked(x) and lockable(x) )</span></span>
</p>

<p class="commentary">in the traditional way: we obtain
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">Exists x: Not(closed(x)) or Not(locked(x)) or Not(lockable(x))</span></span>
</p>

<p class="commentary">which introduces disjunction ("or") in just the way we don't want. By
simply regarding <span class="extract"><span class="extract-syntax">NotAll</span></span> as a quantifier in its own right, we obtain
something much easier to handle:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">NotAll x: closed(x) and locked(x) and lockable(x)</span></span>
</p>

<p class="commentary">This is why we will be creating quantifiers <span class="extract"><span class="extract-syntax">NotAll</span></span> and <span class="extract"><span class="extract-syntax">DoesNotExist</span></span> &mdash;
the negations of <span class="extract"><span class="extract-syntax">ForAll</span></span> and <span class="extract"><span class="extract-syntax">ThereExists</span></span> &mdash; even though they might seem
puzzlingly redundant from a traditional logic point of view.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Quantifiers::quants_negate_each_other</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">Quantifiers::quants_negate_each_other</span></span>:<br/><a href="2-daq.html#SP19_1">&#167;19.1</a>, <a href="2-daq.html#SP19_2">&#167;19.2</a>, <a href="2-daq.html#SP19_3">&#167;19.3</a>, <a href="2-daq.html#SP19_4">&#167;19.4</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">qx</span><span class="plain-syntax">, </span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">qy</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">qx</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_quant</span><span class="plain-syntax"> = </span><span class="identifier-syntax">qy</span><span class="plain-syntax">; </span><span class="identifier-syntax">qy</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_quant</span><span class="plain-syntax"> = </span><span class="identifier-syntax">qx</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
<span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="function-syntax">Quantifiers::get_negation</span><span class="plain-syntax">(</span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">quant</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_quant</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8.  </b>Logging a quantifier:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Quantifiers::log</span><span class="plain-syntax">(</span><span class="identifier-syntax">OUTPUT_STREAM</span><span class="plain-syntax">, </span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">quant</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">parameter</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">quant</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) { </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"&lt;NULL-QUANTIFIER&gt;"</span><span class="plain-syntax">); </span><span class="reserved-syntax">return</span><span class="plain-syntax">; }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">log_text</span><span class="plain-syntax">, </span><span class="identifier-syntax">parameter</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9. Acting on quantifiers. </b>When compiling code to test a proposition which includes a quantifier, we
need to test the cases in the domain set to see how many of them qualify
and how many do not. These counts are stored in local variables called
<span class="extract"><span class="extract-syntax">qcy_0</span></span>, <span class="extract"><span class="extract-syntax">qcn_0</span></span> and so on: <span class="extract"><span class="extract-syntax">qcn</span></span> means "quantifier count number" and is
the size of the domain set, while <span class="extract"><span class="extract-syntax">qcy</span></span> is the number of "yes" cases.
Thus if the original source text read:
</p>

<blockquote>
    <p>if most of the closed doors are locked, ...</p>
</blockquote>

<p class="commentary"><span class="extract"><span class="extract-syntax">qcy_0</span></span> will be the number of closed doors which turned out to be locked
and <span class="extract"><span class="extract-syntax">qcn_0</span></span> the total number of closed doors. (The indices <span class="extract"><span class="extract-syntax">_0</span></span>, <span class="extract"><span class="extract-syntax">_1</span></span>, ...,
are used because the same routine may have to compile code to test several
quantifiers.)
</p>

<p class="commentary">The following routine compiles an I6 condition to test whether the
tallies are acceptable for the given quantifier. In the example above,
the quantifier is <span class="extract"><span class="extract-syntax">Proportion&gt;50%</span></span>, and compiles to the test:
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">qcy_0 &gt; 5*qcn_0/10</span></span>
</p>

<p class="commentary">(It looks a little wasteful to multiply by 5 and then divide by 10, but
I6 will fold that out in eventual code generation. When the proportion is
0/10ths or 10/10ths, though, we do generate simpler code, mostly so that
the resulting I6 is more legible.)
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">#</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Quantifiers::emit_test</span><span class="plain-syntax">(</span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">quant</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">quantification_parameter</span><span class="plain-syntax">, </span><span class="identifier-syntax">inter_symbol</span><span class="plain-syntax"> *</span><span class="identifier-syntax">qcy</span><span class="plain-syntax">, </span><span class="identifier-syntax">inter_symbol</span><span class="plain-syntax"> *</span><span class="identifier-syntax">qcn</span><span class="plain-syntax">) {</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">EmitCode::inv</span><span class="plain-syntax">(</span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">operator_prim</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">EmitCode::down</span><span class="plain-syntax">();</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">TC</span><span class="plain-syntax"> = </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">T_coefficient</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">TC</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> -1:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">is_complementary</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">qcy</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::inv</span><span class="plain-syntax">(</span><span class="identifier-syntax">MINUS_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::down</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">EmitCode::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">qcn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">EmitCode::val_number</span><span class="plain-syntax">((</span><span class="identifier-syntax">inter_ti</span><span class="plain-syntax">) </span><span class="identifier-syntax">quantification_parameter</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::up</span><span class="plain-syntax">();</span>
<span class="plain-syntax">            } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">qcy</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::val_number</span><span class="plain-syntax">((</span><span class="identifier-syntax">inter_ti</span><span class="plain-syntax">) </span><span class="identifier-syntax">quantification_parameter</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">10</span><span class="plain-syntax">:</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">EmitCode::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">qcy</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">EmitCode::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">qcn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span><span class="plain-syntax">:</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">EmitCode::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">qcy</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">EmitCode::val_number</span><span class="plain-syntax">(0);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">default:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">operator_prim</span><span class="plain-syntax"> != </span><span class="identifier-syntax">EQ_BIP</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::inv</span><span class="plain-syntax">(</span><span class="identifier-syntax">TIMES_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::down</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">EmitCode::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">qcy</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">EmitCode::val_number</span><span class="plain-syntax">(10);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::up</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::inv</span><span class="plain-syntax">(</span><span class="identifier-syntax">TIMES_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::down</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">EmitCode::val_number</span><span class="plain-syntax">((</span><span class="identifier-syntax">inter_ti</span><span class="plain-syntax">) </span><span class="identifier-syntax">TC</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">EmitCode::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">qcn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::up</span><span class="plain-syntax">();</span>
<span class="plain-syntax">            } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">qcy</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::inv</span><span class="plain-syntax">(</span><span class="identifier-syntax">DIVIDE_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::down</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">EmitCode::inv</span><span class="plain-syntax">(</span><span class="identifier-syntax">TIMES_BIP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">EmitCode::down</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">EmitCode::val_number</span><span class="plain-syntax">((</span><span class="identifier-syntax">inter_ti</span><span class="plain-syntax">) </span><span class="identifier-syntax">TC</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">EmitCode::val_symbol</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">, </span><span class="identifier-syntax">qcn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">EmitCode::up</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">EmitCode::val_number</span><span class="plain-syntax">(10);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">EmitCode::up</span><span class="plain-syntax">();</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">EmitCode::up</span><span class="plain-syntax">();</span>
<span class="plain-syntax">}</span>
<span class="plain-syntax">#</span><span class="identifier-syntax">endif</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10.  </b>"Now" is the Inform way to assert that a proposition should now be made
true. Many quantifiers obstruct this, by introducing too much vagueness.
For instance, "now three doors are open" is dangerously vague because it
doesn't say which doors are to be made open; similarly "now most of the
coins are in the box". On the other hand, "now all the coins are in the
box" is fine, because there's no ambiguity. The <span class="extract"><span class="extract-syntax">can_be_used_in_now</span></span> flag for
a quantifier shows whether it can be asserted in "now" like this.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Quantifiers::is_now_assertable</span><span class="plain-syntax">(</span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">quant</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">can_be_used_in_now</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11.  </b>Not every proposition can be used in assertion sentences, either, and
again it's the quantifiers which cause the trouble. For instance, "Not
every room is dark." gives Inform too little to act on. Which room(s)
should it make lighted?
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Quantifiers::can_be_used_in_assertions</span><span class="plain-syntax">(</span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">quant</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">quant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">can_be_used_in_assertions</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12. Creating a determiner. </b>Again, at present there's only the built-in set, but we want to keep our
options open.
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">ALL_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">EACH_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">EVERY_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">2</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">NO_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">3</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">NONE_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">4</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">SOME_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">5</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">ANY_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">6</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">ALL_BUT_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">7</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">ALL_EXCEPT_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">8</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">ALMOST_ALL_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">9</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">ALMOST_NO_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">10</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">MOST_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">11</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">UNDER_HALF_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">12</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">AT_LEAST_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">13</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">AT_MOST_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">14</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">EXACTLY_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">15</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">FEWER_THAN_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">16</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">LESS_THAN_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">17</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">MORE_THAN_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">18</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">GREATER_THAN_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">19</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">OTHER_THAN_DET_NAME</span><span class="plain-syntax"> </span><span class="constant-syntax">20</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">determiner</span><span class="plain-syntax"> *</span><span class="function-syntax">Quantifiers::det_new</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">Quantifiers::det_new</span></span>:<br/><a href="2-daq.html#SP19_1">&#167;19.1</a>, <a href="2-daq.html#SP19_2">&#167;19.2</a>, <a href="2-daq.html#SP19_3">&#167;19.3</a>, <a href="2-daq.html#SP19_4">&#167;19.4</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">not</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">pr</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">num</span><span class="plain-syntax">, </span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">quant</span><span class="plain-syntax">, </span><span class="reserved-syntax">char</span><span class="plain-syntax"> *</span><span class="identifier-syntax">text</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">word_assemblage</span><span class="plain-syntax"> </span><span class="identifier-syntax">wa</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pr</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="identifier-syntax">wa</span><span class="plain-syntax"> = </span><span class="identifier-syntax">WordAssemblages::lit_0</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">wa</span><span class="plain-syntax"> = </span><span class="identifier-syntax">PreformUtilities::wording</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;determiner-names&gt;</span><span class="plain-syntax">, </span><span class="identifier-syntax">pr</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">determiner</span><span class="plain-syntax"> *</span><span class="identifier-syntax">det</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">determiner</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">det</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">text_of_det</span><span class="plain-syntax"> = </span><span class="identifier-syntax">wa</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">det</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">takes_number</span><span class="plain-syntax"> = </span><span class="identifier-syntax">num</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">det</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">allows_prefixed_not</span><span class="plain-syntax"> = </span><span class="identifier-syntax">not</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">det</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">quantifier_meant</span><span class="plain-syntax"> = </span><span class="identifier-syntax">quant</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">quant</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"created meaningless quantifier"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">det</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">index_text</span><span class="plain-syntax"> = </span><span class="identifier-syntax">text</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">det</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">in_stock</span><span class="plain-syntax"> = </span><a href="1-sc.html#SP6" class="function-link"><span class="function-syntax">Stock::new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">determiners_category</span><span class="plain-syntax">, </span><span class="identifier-syntax">STORE_POINTER_determiner</span><span class="plain-syntax">(</span><span class="identifier-syntax">det</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">det</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13.  </b>Inform supports a built-in set of sixteen generalised quantifiers, in
logical terms, and English maps onto these with a rather less elegantly
structured set of twenty wordings. One of these doesn't appear below because
it's empty of text: this is the determiner in "three blind mice", where
no text appears in front of the number "three".
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;determiner-names&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">all</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">each</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">every</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">no</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">none</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">some</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">any</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">all</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">but</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">all</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">except</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">almost</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">all</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">almost</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">no</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">most</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">under</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">half</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">at</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">least</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">at</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">most</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">exactly</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">fewer</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">than</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">less</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">than</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">more</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">than</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">greater</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">than</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">other</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">than</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP14" class="paragraph-anchor"></a><b>&#167;14. Negation. </b></p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;negated-clause&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">not</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP15" class="paragraph-anchor"></a><b>&#167;15. Parsing the determiner at the head of a noun phrase. </b>We run through the possible determiners in reverse creation order, choosing the
first which matches. The following returns \(-1\) if nothing was found, or
else the first word number after the determiner words, and in that case
it also writes a pointer to the quantifier meant to <span class="extract"><span class="Preform-extract-syntax">*which_quant</span></span> and the
parameter value to <span class="extract"><span class="Preform-extract-syntax">*which_P</span></span>.
</p>

<p class="commentary">(Reverse order is used really only to make sure "all but" and "all except"
are tried before "all".)
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Quantifiers::parse_against_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> *</span><span class="identifier-syntax">which_P</span><span class="plain-syntax">, </span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> **</span><span class="identifier-syntax">which_quant</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;excluded-from-determiners&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> -1;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">not_flag</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;negated-clause&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">not_flag</span><span class="plain-syntax">) </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">GET_RW</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;negated-clause&gt;</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    *</span><span class="identifier-syntax">which_P</span><span class="plain-syntax"> = -1; *</span><span class="identifier-syntax">which_quant</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">determiner</span><span class="plain-syntax"> *</span><span class="identifier-syntax">det</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_BACKWARDS_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">det</span><span class="plain-syntax">, </span><span class="reserved-syntax">determiner</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">not_flag</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">det</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">allows_prefixed_not</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)) </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">XW</span><span class="plain-syntax"> = </span><a href="2-daq.html#SP18" class="function-link"><span class="function-syntax">Quantifiers::det_parse_against_text</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">det</span><span class="plain-syntax">, </span><span class="identifier-syntax">which_P</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">XW</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">not_flag</span><span class="plain-syntax">) *</span><span class="identifier-syntax">which_quant</span><span class="plain-syntax"> = </span><span class="identifier-syntax">det</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">quantifier_meant</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_quant</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">else</span><span class="plain-syntax"> *</span><span class="identifier-syntax">which_quant</span><span class="plain-syntax"> = </span><span class="identifier-syntax">det</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">quantifier_meant</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">Wordings::first_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">XW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> -1;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP16" class="paragraph-anchor"></a><b>&#167;16.  </b>We look for a determiner at the start of a noun phrase; this can sometimes
be followed by a number. For example,
</p>

<blockquote>
    <p>More than three doors</p>
</blockquote>

<p class="commentary">matches "more than" from the selection above, then the number "three".
It's legal to include "of the":
</p>

<blockquote>
    <p>three of the doors are open</p>
</blockquote>

<p class="commentary">but not "of" on its own: this reduces misunderstandings when objects have
names like "three of clubs", meaning a single playing card.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;determination-of&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">the</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { TRUE, - }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">      </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { fail }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax">           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { TRUE, - }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP17" class="paragraph-anchor"></a><b>&#167;17.  </b>English has an awkward ambiguity here: what does this mean?
</p>

<blockquote>
    <p>no one</p>
</blockquote>

<p class="commentary">Inform would normally read this as the determiner "no" followed by the
number "one", not realising that "one" is more likely to refer to a
kind (i.e., people and not things) rather than counting something. We want
to stop this reading, so that we can read "no one" as if it were "nobody".
</p>

<p class="commentary">The following grammar is provided to list noun phrases which will be immune
from determiner parsing:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;excluded-from-determiners&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">no</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">one</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">***</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP18" class="paragraph-anchor"></a><b>&#167;18.  </b>We attempt to see if the word range begins with (or consists of) text which
refers to the given determiner, returning the first word past this text and
also (where appropriate) setting the number specified. For instance, for
"at least three doors are open" and the <span class="extract"><span class="Preform-extract-syntax">at_least_determiner</span></span> we would
return the word "doors" and set <span class="extract"><span class="Preform-extract-syntax">which_P</span></span> to 3.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="function-syntax">Quantifiers::det_parse_against_text</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">Quantifiers::det_parse_against_text</span></span>:<br/><a href="2-daq.html#SP15">&#167;15</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="reserved-syntax">determiner</span><span class="plain-syntax"> *</span><span class="identifier-syntax">det</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> *</span><span class="identifier-syntax">which_P</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">parameter</span><span class="plain-syntax"> = -1;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::empty</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">x</span><span class="plain-syntax"> = </span><span class="identifier-syntax">WordAssemblages::parse_as_weakly_initial_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">, &amp;(</span><span class="identifier-syntax">det</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">text_of_det</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Wordings::from</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">x</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::empty</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">det</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">takes_number</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="function-syntax">&lt;cardinal-number&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">Wordings::one_word</span><span class="plain-syntax">(</span><span class="identifier-syntax">x</span><span class="plain-syntax">)) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) ||</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">Word::unexpectedly_upper_case</span><span class="plain-syntax">(</span><span class="identifier-syntax">x</span><span class="plain-syntax">))) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Wordings::trim_first_word</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::empty</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parameter</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;r&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;determination-of&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">GET_RW</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;determination-of&gt;</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        *</span><span class="identifier-syntax">which_P</span><span class="plain-syntax"> = </span><span class="identifier-syntax">parameter</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><a href="2-art.html#SP8" class="function-link"><span class="function-syntax">Articles::remove_the</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP19" class="paragraph-anchor"></a><b>&#167;19. The built-in set. </b>We now construct both the tidy logical world of 16 quantifiers in matched
pairs, and also a higgledy-piggledy world of 20 English-language determiners
referring to them. There are four broad families which we take in turn.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Quantifiers::make_built_in</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">Quantifiers::make_built_in</span></span>:<br/>Linguistics Module - <a href="1-lm.html#SP4">&#167;4</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="2-daq.html#SP19_1" class="named-paragraph-link"><span class="named-paragraph">Make traditional quantification determiners</span><span class="named-paragraph-number">19.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="2-daq.html#SP19_2" class="named-paragraph-link"><span class="named-paragraph">Make complement comparison determiners</span><span class="named-paragraph-number">19.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="2-daq.html#SP19_3" class="named-paragraph-link"><span class="named-paragraph">Make proportion determiners</span><span class="named-paragraph-number">19.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="2-daq.html#SP19_4" class="named-paragraph-link"><span class="named-paragraph">Make cardinality quantification determiners</span><span class="named-paragraph-number">19.4</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP19_1" class="paragraph-anchor"></a><b>&#167;19.1.  </b>As discussed above, the two traditional quantifiers in logic are "for
all" and "there exists", usually written in mathematical notation as
\(\forall\) and \(\exists\), but we also need to create their negation
quantifiers. So we end up with four: <span class="extract"><span class="extract-syntax">ForAll</span></span>, <span class="extract"><span class="extract-syntax">NotAll</span></span>, <span class="extract"><span class="extract-syntax">Exists</span></span> and
<span class="extract"><span class="extract-syntax">DoesNotExist</span></span>.
</p>

<p class="commentary">The for-all quantifier can be used in assertions for a slightly oddball
reason: it's how the source text makes assemblies. For instance,
</p>

<blockquote>
    <p>A nose is part of every person.</p>
</blockquote>

<p class="commentary">The "every" is parsed as a use of <span class="extract"><span class="extract-syntax">ForAll</span></span>. Strictly speaking this
sentence should be read as creating a single nose which would be shared
by all of the people. But the presence of a <span class="extract"><span class="extract-syntax">ForAll</span></span> quantifier in an
assertion causes the A-parser to interpret the sentence differently, and to
create a fresh nose for each person. (There are some restrictions on the
use of <span class="extract"><span class="extract-syntax">ForAll</span></span> in this way, but they are enforced in the A-parser: our
part here is simply to authorise <span class="extract"><span class="extract-syntax">ForAll</span></span> in assertions.)
</p>

<p class="commentary">Something which English allows, but Inform does not, is the use of "all"
in a way which also specifies a cardinality. For instance, the following
condition:
</p>

<blockquote>
    <p>if all six doors are open, ...</p>
</blockquote>

<p class="commentary">is an attempt to use a determiner which Inform does not possess &mdash; "all"
plus number. We don't allow this because if there happen to be eight doors,
say, the condition would be meaningless.
</p>

<p class="commentary">It's an example of the irregularity of English that you can say "not every
door is open" but would never say "not each door is open". In all other
respects "each" and "every" are synonymous in the S-parser.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make traditional quantification determiners</span><span class="named-paragraph-number">19.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">for_all_quantifier</span><span class="plain-syntax">     = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"=="</span><span class="plain-syntax">, </span><span class="constant-syntax">10</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"ForAll"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">not_for_all_quantifier</span><span class="plain-syntax"> = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;"</span><span class="plain-syntax">, </span><span class="constant-syntax">10</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"NotAll"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">exists_quantifier</span><span class="plain-syntax">      = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&gt;"</span><span class="plain-syntax">, </span><span class="constant-syntax">0</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"Exists"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">not_exists_quantifier</span><span class="plain-syntax">  = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"=="</span><span class="plain-syntax">, </span><span class="constant-syntax">0</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"DoesNotExist"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">for_all_quantifier</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">can_be_used_in_now</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">for_all_quantifier</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">can_be_used_in_assertions</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">not_exists_quantifier</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">can_be_used_in_now</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><a href="2-daq.html#SP7" class="function-link"><span class="function-syntax">Quantifiers::quants_negate_each_other</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">for_all_quantifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">not_for_all_quantifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP7" class="function-link"><span class="function-syntax">Quantifiers::quants_negate_each_other</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">exists_quantifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">not_exists_quantifier</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="constant-syntax">ALL_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">for_all_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"used in conditions: 'if all of the doors are open'"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">EACH_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">for_all_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"- see &lt;/i&gt;all&lt;i&gt;"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="constant-syntax">EVERY_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">for_all_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"- see &lt;/i&gt;all&lt;i&gt;, and can also be used in generalisations such as "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"'A nose is part of every person.'"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">NO_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">not_exists_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"opposite of 'all': 'if no door is open...'"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">NONE_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">not_exists_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"opposite of 'all of': 'if none of the doors is open...'"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">SOME_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">exists_quantifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">ANY_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">exists_quantifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-daq.html#SP19">&#167;19</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP19_2" class="paragraph-anchor"></a><b>&#167;19.2.  </b>Here \(T=-1\), because we are counting actual numbers of matches rather than
a proportion of matches. But these quantifiers count downwards from the total:
thus "all but six" means there have to be exactly \(S-6\) matching items,
where \(S\) is the total available. The only logical negation for this
quantifier would be "other than \(S-6\)", which is too unnatural a
construction to have any natural English paraphrase, so we do not make a
<span class="extract"><span class="extract-syntax">determiner *</span></span> structure pointing to it. But we create it in order that the
built-in quantifiers all occur in negation pairs.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make complement comparison determiners</span><span class="named-paragraph-number">19.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">all_but_quantifier</span><span class="plain-syntax">     = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"=="</span><span class="plain-syntax">, -1, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="string-syntax">"AllBut%d"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">not_all_but_quantifier</span><span class="plain-syntax"> = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"~="</span><span class="plain-syntax">, -1, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="string-syntax">"NotAllBut%d"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><a href="2-daq.html#SP7" class="function-link"><span class="function-syntax">Quantifiers::quants_negate_each_other</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">all_but_quantifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">not_all_but_quantifier</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">ALL_BUT_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">all_but_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"used to count things: 'all but three containers'"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">ALL_EXCEPT_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">all_but_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"- see &lt;/i&gt;all but&lt;i&gt;"</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-daq.html#SP19">&#167;19</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP19_3" class="paragraph-anchor"></a><b>&#167;19.3.  </b>Here the \(T\)-coefficient, measuring the proportion needed, has \(0 &lt; T &lt; 10\).
</p>

<p class="commentary">We don't support the determiner "half", as in, "if half the doors are open",
because it's ambiguous as to whether it means exactly half or half-or-more.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make proportion determiners</span><span class="named-paragraph-number">19.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">almost_all_quantifier</span><span class="plain-syntax">  = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&gt;="</span><span class="plain-syntax">, </span><span class="constant-syntax">8</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"Proportion&gt;=80%%"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">almost_no_quantifier</span><span class="plain-syntax">   = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;"</span><span class="plain-syntax">,  </span><span class="constant-syntax">2</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"Proportion&lt;20%%"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">most_quantifier</span><span class="plain-syntax">        = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&gt;"</span><span class="plain-syntax">,  </span><span class="constant-syntax">5</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"Proportion&gt;50%%"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">under_half_quantifier</span><span class="plain-syntax">  = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;="</span><span class="plain-syntax">, </span><span class="constant-syntax">5</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"Proportion&lt;=50%%"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><a href="2-daq.html#SP7" class="function-link"><span class="function-syntax">Quantifiers::quants_negate_each_other</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">almost_all_quantifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">almost_no_quantifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP7" class="function-link"><span class="function-syntax">Quantifiers::quants_negate_each_other</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">most_quantifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">under_half_quantifier</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">ALMOST_ALL_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">almost_all_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"used in conditions: true if 80 percent or more possibilities work"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">ALMOST_NO_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">almost_no_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"used in conditions: true if fewer than 20 percent of possibilities work"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">MOST_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">most_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"used in conditions: true if a simple majority of possibilities work"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">UNDER_HALF_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">under_half_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"used in conditions: true if fewer than half of possibilities work"</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-daq.html#SP19">&#167;19</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP19_4" class="paragraph-anchor"></a><b>&#167;19.4.  </b>The usefulness of cardinality quantifiers in logic as applied to
linguistics seems to be an observation due to Barwise and Cooper. They are
a natural generalisation of the for-all and there-exists quantifiers, and
again come in matched pairs.
</p>

<p class="commentary">The bare number determiner, as in "six doors are open", is perhaps a little
ambiguous in English. We read it as "at least six doors are open", in
distinction to "exactly six doors are open". This is why the at-least
quantifier is allowed in assertions: the assertion sentence "Four coins are
in the strongbox." is read as containing the <span class="extract"><span class="extract-syntax">Card&gt;=4</span></span> quantifier, not
<span class="extract"><span class="extract-syntax">Card=4</span></span> one. The advantage of this is that two assertions in a row, such
as
</p>

<blockquote>
    <p>Four coins are in the strongbox. Two coins are in the strongbox.</p>
</blockquote>

<p class="commentary">can combine to put six coins in the strongbox, rather than having to be
read as contradictory. (It may look improbable that anyone would ever
write that, but of course the two assertions need not be adjacent in
the source text. One might be in an extension, for instance.)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make cardinality quantification determiners</span><span class="named-paragraph-number">19.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">at_least_quantifier</span><span class="plain-syntax">    = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&gt;="</span><span class="plain-syntax">, -1, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"Card&gt;=%d"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">at_most_quantifier</span><span class="plain-syntax">     = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;="</span><span class="plain-syntax">, -1, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"Card&lt;=%d"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">exactly_quantifier</span><span class="plain-syntax">     = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"=="</span><span class="plain-syntax">, -1, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"Card=%d"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">less_than_quantifier</span><span class="plain-syntax">   = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&lt;"</span><span class="plain-syntax">,  -1, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"Card&lt;%d"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">more_than_quantifier</span><span class="plain-syntax">   = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"&gt;"</span><span class="plain-syntax">,  -1, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"Card&gt;%d"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">other_than_quantifier</span><span class="plain-syntax">  = </span><a href="2-daq.html#SP6" class="function-link"><span class="function-syntax">Quantifiers::quant_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"~="</span><span class="plain-syntax">, -1, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="string-syntax">"Card~=%d"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">at_least_quantifier</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">can_be_used_in_assertions</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><a href="2-daq.html#SP7" class="function-link"><span class="function-syntax">Quantifiers::quants_negate_each_other</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">at_least_quantifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">less_than_quantifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP7" class="function-link"><span class="function-syntax">Quantifiers::quants_negate_each_other</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">at_most_quantifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">more_than_quantifier</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP7" class="function-link"><span class="function-syntax">Quantifiers::quants_negate_each_other</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">exactly_quantifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">other_than_quantifier</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">AT_LEAST_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">at_least_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"used to count things: 'at least five doors'"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">AT_MOST_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">at_most_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"- see &lt;/i&gt;at least&lt;i&gt;"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">EXACTLY_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">exactly_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"whereas 'if two doors are open' implicitly means 'if at least two "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"doors are open', 'if exactly two...' makes the count precise"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="constant-syntax">FEWER_THAN_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">less_than_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"pedantic way to say &lt;/i&gt;less than&lt;i&gt; when counting"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="constant-syntax">LESS_THAN_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">less_than_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"- see &lt;/i&gt;more than&lt;i&gt;"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="constant-syntax">MORE_THAN_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">more_than_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"used to count things: 'more than three rooms'"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="constant-syntax">GREATER_THAN_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">more_than_quantifier</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"used to count things: 'greater than three rooms'"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">OTHER_THAN_DET_NAME</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">other_than_quantifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><a href="2-daq.html#SP12" class="function-link"><span class="function-syntax">Quantifiers::det_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, -1, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">at_least_quantifier</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="2-daq.html#SP19">&#167;19</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP20" class="paragraph-anchor"></a><b>&#167;20.  </b>The following question is relevant when simplifying propositions:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Quantifiers::quant_requires_at_least_one_true_case</span><span class="plain-syntax">(</span><span class="reserved-syntax">quantifier</span><span class="plain-syntax"> *</span><span class="identifier-syntax">quant</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">parameter</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">quant</span><span class="plain-syntax"> == </span><span class="identifier-syntax">exists_quantifier</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (((</span><span class="identifier-syntax">quant</span><span class="plain-syntax"> == </span><span class="identifier-syntax">exactly_quantifier</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">quant</span><span class="plain-syntax"> == </span><span class="identifier-syntax">at_least_quantifier</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">parameter</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">quant</span><span class="plain-syntax"> == </span><span class="identifier-syntax">more_than_quantifier</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">parameter</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">quant</span><span class="plain-syntax"> == </span><span class="identifier-syntax">other_than_quantifier</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">parameter</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="2-art.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-lm.html">1</a></li><li class="progresscurrentchapter">2</li><li class="progresssection"><a href="2-adj.html">adj</a></li><li class="progresssection"><a href="2-art.html">art</a></li><li class="progresscurrent">daq</li><li class="progresssection"><a href="2-nns.html">nns</a></li><li class="progresssection"><a href="2-prn.html">prn</a></li><li class="progresschapter"><a href="3-vrb.html">3</a></li><li class="progresschapter"><a href="4-np.html">4</a></li><li class="progressnext"><a href="2-nns.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

