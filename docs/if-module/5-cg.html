<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Command Grammars</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script src="http://code.jquery.com/jquery-1.12.4.min.js"
	integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

<script src="../docs-assets/Bigfoot.js"></script>
<link href="../docs-assets/Bigfoot.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../compiler.html">compiler tools</a></li>
<li><a href="../other.html">other tools</a></li>
<li><a href="../extensions.html">extensions and kits</a></li>
<li><a href="../units.html">unit test tools</a></li>
</ul><h2>Compiler Webs</h2><ul>
<li><a href="../inbuild/index.html">inbuild</a></li>
<li><a href="../inform7/index.html">inform7</a></li>
<li><a href="../inter/index.html">inter</a></li>
</ul><h2>Inbuild Modules</h2><ul>
<li><a href="../supervisor-module/index.html">supervisor</a></li>
</ul><h2>Inform7 Modules</h2><ul>
<li><a href="../core-module/index.html">core</a></li>
<li><a href="../assertions-module/index.html">assertions</a></li>
<li><a href="../values-module/index.html">values</a></li>
<li><a href="../knowledge-module/index.html">knowledge</a></li>
<li><a href="../imperative-module/index.html">imperative</a></li>
<li><a href="../runtime-module/index.html">runtime</a></li>
<li><a href="index.html"><span class="selectedlink">if</span></a></li>
<li><a href="../multimedia-module/index.html">multimedia</a></li>
<li><a href="../index-module/index.html">index</a></li>
</ul><h2>Inter Modules</h2><ul>
<li><a href="../bytecode-module/index.html">bytecode</a></li>
<li><a href="../building-module/index.html">building</a></li>
<li><a href="../pipeline-module/index.html">pipeline</a></li>
<li><a href="../final-module/index.html">final</a></li>
</ul><h2>Services</h2><ul>
<li><a href="../arch-module/index.html">arch</a></li>
<li><a href="../calculus-module/index.html">calculus</a></li>
<li><a href="../html-module/index.html">html</a></li>
<li><a href="../inflections-module/index.html">inflections</a></li>
<li><a href="../kinds-module/index.html">kinds</a></li>
<li><a href="../linguistics-module/index.html">linguistics</a></li>
<li><a href="../problems-module/index.html">problems</a></li>
<li><a href="../syntax-module/index.html">syntax</a></li>
<li><a href="../words-module/index.html">words</a></li>
<li><a href="../../../inweb/docs/foundation-module/index.html">foundation</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Command Grammars' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../compiler.html">Inform7</a></li><li><a href="index.html">if</a></li><li><a href="index.html#5">Chapter 5: Command Parser</a></li><li><b>Command Grammars</b></li></ul></div>
<p class="purpose">The possible command text following a command verb, or referring to a single concept or object, is gathered into a "command grammar".</p>

<ul class="toc"><li><a href="5-cg.html#SP5">&#167;5. The CG_IS_COMMAND form</a></li><li><a href="5-cg.html#SP11">&#167;11. The CG_IS_TOKEN form</a></li><li><a href="5-cg.html#SP13">&#167;13. The CG_IS_SUBJECT form</a></li><li><a href="5-cg.html#SP14">&#167;14. The CG_IS_VALUE form</a></li><li><a href="5-cg.html#SP15">&#167;15. The CG_IS_CONSULT form</a></li><li><a href="5-cg.html#SP16">&#167;16. The CG_IS_PROPERTY_NAME form</a></li><li><a href="5-cg.html#SP17">&#167;17. The list of grammar lines</a></li><li><a href="5-cg.html#SP19">&#167;19. Slashing and determining</a></li><li><a href="5-cg.html#SP21">&#167;21. Sorting</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1.  </b>Command grammars, or CGs, are used in six excitingly different ways:
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">CG_IS_COMMAND</span><span class="plain-syntax">        </span><span class="constant-syntax">1</span><span class="plain-syntax">  </span><span class="comment-syntax"> for player-typed commands starting with a given verb</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">CG_IS_TOKEN</span><span class="plain-syntax">          </span><span class="constant-syntax">2</span><span class="plain-syntax">  </span><span class="comment-syntax"> for defining a square-bracketed token used in commands</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">CG_IS_SUBJECT</span><span class="plain-syntax">        </span><span class="constant-syntax">3</span><span class="plain-syntax">  </span><span class="comment-syntax"> for ways the player can refer to an object or kind</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">CG_IS_VALUE</span><span class="plain-syntax">          </span><span class="constant-syntax">4</span><span class="plain-syntax">  </span><span class="comment-syntax"> for ways the player can refer to a non-object value</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">CG_IS_CONSULT</span><span class="plain-syntax">        </span><span class="constant-syntax">5</span><span class="plain-syntax">  </span><span class="comment-syntax"> for topics of conversation, as used in commands like ASK or CONSULT</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">CG_IS_PROPERTY_NAME</span><span class="plain-syntax">  </span><span class="constant-syntax">6</span><span class="plain-syntax">  </span><span class="comment-syntax"> for ways to refer to property values used adjectivally</span>
</pre>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2.  </b>Fixed maxima are generally a bad idea in a compiler (what seems excessive in
one decade becomes limiting in the next), but in this plugin we have to
make data tables in formats which can be handled by the Inform 6 compiler.
And that does have two maxima which cannot easily be avoided, so we need to
respect those here as well.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">MAX_ALIASED_COMMANDS</span></span> is harmless enough: it's the maximum number of command
verbs which can be synonymous with a single other one, as for example if CONSUME
were synonymous with EAT. Few command verbs need more than four or five, and
many need none at all.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">MAX_LINES_PER_GRAMMAR</span></span> is potentially more biting, since it puts a limit on
the number of different command syntaxes which any one command verb can have.
(It applies only to <span class="extract"><span class="extract-syntax">CG_IS_COMMAND</span></span> grammars: the rest are unlimited.) Skilled
Inform 7 writers can get around this with named tokens, but still, in an ideal
world we would not impose a limit here.
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">MAX_ALIASED_COMMANDS</span><span class="plain-syntax"> </span><span class="constant-syntax">32</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">MAX_LINES_PER_GRAMMAR</span><span class="plain-syntax"> </span><span class="constant-syntax">32</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3.  </b>Many of the fields here are relevant only when the CG takes a given <span class="extract"><span class="extract-syntax">cg_is</span></span>
form, so this is not as bloated a structure as it looks.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg_is</span><span class="plain-syntax">; </span><span class="comment-syntax"> one of the </span><span class="extract"><span class="extract-syntax">CG_IS_*</span></span><span class="comment-syntax"> values above</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">where_cg_created</span><span class="plain-syntax">; </span><span class="comment-syntax"> for problem message reports</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">determination_type</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg_type</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">cg_line</span><span class="plain-syntax"> *</span><span class="identifier-syntax">first_line</span><span class="plain-syntax">; </span><span class="comment-syntax"> linked list in creation order</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">cg_line</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sorted_first_line</span><span class="plain-syntax">; </span><span class="comment-syntax"> and in logical applicability order</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">slashed</span><span class="plain-syntax">; </span><span class="comment-syntax"> slashing has been done</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">determined</span><span class="plain-syntax">; </span><span class="comment-syntax"> determination has been done</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">command</span><span class="plain-syntax">; </span><span class="comment-syntax"> </span><span class="extract"><span class="extract-syntax">CG_IS_COMMAND</span></span><span class="comment-syntax">: what command verb this belongs to</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">aliased_command</span><span class="plain-syntax">[</span><span class="constant-syntax">MAX_ALIASED_COMMANDS</span><span class="plain-syntax">]; </span><span class="comment-syntax"> ...and other commands synonymous</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">no_aliased_commands</span><span class="plain-syntax">; </span><span class="comment-syntax"> ...and how many of them there are</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">token_name</span><span class="plain-syntax">; </span><span class="comment-syntax"> </span><span class="extract"><span class="extract-syntax">CG_IS_TOKEN</span></span><span class="comment-syntax">: name of this token</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subj_understood</span><span class="plain-syntax">; </span><span class="comment-syntax"> </span><span class="extract"><span class="extract-syntax">CG_IS_SUBJECT</span></span><span class="comment-syntax">: what this provides names for</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">kind_understood</span><span class="plain-syntax">; </span><span class="comment-syntax"> </span><span class="extract"><span class="extract-syntax">CG_IS_VALUE</span></span><span class="comment-syntax">: for which type it names an instance of</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prn_understood</span><span class="plain-syntax">; </span><span class="comment-syntax"> </span><span class="extract"><span class="extract-syntax">CG_IS_PROPERTY_NAME</span></span><span class="comment-syntax">: which prn this names</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg_compilation_data</span><span class="plain-syntax"> </span><span class="identifier-syntax">compilation_data</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>The structure command_grammar is accessed in 4/ap, 4/act, 4/as, 4/nap, 4/gng, 5/pp, 5/cgl, 5/ts and here.</li></ul>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4.  </b>We begin as usual with a constructor and some debug log tracing.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="function-syntax">CommandGrammars::cg_new</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::cg_new</span></span>:<br/><a href="5-cg.html#SP7">&#167;7</a>, <a href="5-cg.html#SP11">&#167;11</a>, <a href="5-cg.html#SP13">&#167;13</a>, <a href="5-cg.html#SP14">&#167;14</a>, <a href="5-cg.html#SP15">&#167;15</a>, <a href="5-cg.html#SP16">&#167;16</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg_is</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">command</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">first_line</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_type</span><span class="plain-syntax"> = </span><a href="5-dt.html#SP2" class="function-link"><span class="function-syntax">DeterminationTypes::new</span></a><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_is</span><span class="plain-syntax"> = </span><span class="identifier-syntax">cg_is</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">token_name</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">no_aliased_commands</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">sorted_first_line</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">subj_understood</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">kind_understood</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">prn_understood</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">where_cg_created</span><span class="plain-syntax"> = </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">slashed</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">determined</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">compilation_data</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RTCommandGrammars::new_compilation_data</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CommandGrammars::log</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::log</span></span>:<br/>IF Module - <a href="1-im.html#SP2">&#167;2</a>, <a href="1-im.html#SP2_3">&#167;2.3</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"&lt;CG%d:"</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">allocation_id</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_is</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">CG_IS_COMMAND:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::empty</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">command</span><span class="plain-syntax">)) </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"command=no-verb verb"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"command=%W"</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">command</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">CG_IS_TOKEN:</span><span class="plain-syntax"> </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"token=%W"</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">token_name</span><span class="plain-syntax">); </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">CG_IS_SUBJECT:</span><span class="plain-syntax"> </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"subject=$j"</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">subj_understood</span><span class="plain-syntax">); </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">CG_IS_VALUE:</span><span class="plain-syntax"> </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"value=%u"</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">kind_understood</span><span class="plain-syntax">); </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">CG_IS_CONSULT:</span><span class="plain-syntax"> </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"consult"</span><span class="plain-syntax">); </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">CG_IS_PROPERTY_NAME:</span><span class="plain-syntax"> </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"property=$Y"</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">prn_understood</span><span class="plain-syntax">); </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">default:</span><span class="plain-syntax"> </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"&lt;unknown&gt;"</span><span class="plain-syntax">); </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"&gt;"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5. The CG_IS_COMMAND form. </b>These are the CGs for which CGs were invented, really. Each different
imperative verb a player can type has a CG of the possible syntaxes the
player's command can take after that start.
</p>

<p class="commentary">However, such a CG can also handle a number of "aliases", which are verbs
synonymous to the main one. For instance, the Standard Rules create a CG for
the command PULL but also give it one alias, DRAG.
</p>

<p class="commentary">Command verbs are of course recognised by their wording, or rather, spelling.
(We cannot have two different CGs for the verb MARK as understood in two
different senses, say for marking work and for daubing on a wall.) A special
case is the empty command verb, the one with no letters at all, which is
traditionally called the "no verb verb".<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> All other verbs are "genuinely
verbal".
</p>

<ul class="footnotetexts"><li class="footnote" id="fn:1"><p class="inwebfootnote"><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> The Standard Rules do not use the no verb verb, but Inform designers
sometimes do, to allow players to type commands which are meaningful even
when they do not start with a verb. We treat those as being commands which
do in fact start with the invisible "no verb verb".
<a href="#fnref:1" title="return to text"> &#x21A9;</a></p></li></ul>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="function-syntax">CommandGrammars::get_verb_text</span><span class="plain-syntax">(</span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">command</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">CommandGrammars::cg_is_genuinely_verbal</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::cg_is_genuinely_verbal</span></span>:<br/>Command Grammar Lines - <a href="5-cgl.html#SP16">&#167;16</a>, <a href="5-cgl.html#SP16_2">&#167;16.2</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_is</span><span class="plain-syntax"> == </span><span class="constant-syntax">CG_IS_COMMAND</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">command</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6.  </b>Here we find the CG associated with command <span class="extract"><span class="extract-syntax">W</span></span>, or return null if none
exists (i.e. because no grammar has been created for it). Note that if <span class="extract"><span class="extract-syntax">W</span></span> is
the <span class="extract"><span class="extract-syntax">EMPTY_WORDING</span></span>, then this function returns the "no verb verb".
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="function-syntax">CommandGrammars::for_command_verb</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::for_command_verb</span></span>:<br/><a href="5-cg.html#SP7">&#167;7</a><br/>Understand Sentences - <a href="5-us.html#SP15_1">&#167;15.1</a>, <a href="5-us.html#SP15_2">&#167;15.2</a>, <a href="5-us.html#SP15_3">&#167;15.3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_is</span><span class="plain-syntax"> == </span><span class="constant-syntax">CG_IS_COMMAND</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::empty</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::empty</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">command</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::match</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">command</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">i</span><span class="function-syntax">&lt;cg-&gt;</span><span class="element-syntax">no_aliased_commands</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++)</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::match</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">aliased_command</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">], </span><span class="identifier-syntax">W</span><span class="plain-syntax">))</span>
<span class="plain-syntax">                        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7.  </b>This does the same, but creating the CG if it does not already exist, so
that it is guaranteed to return a non-<span class="extract"><span class="extract-syntax">NULL</span></span> pointer:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="function-syntax">CommandGrammars::for_command_verb_creating</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::for_command_verb_creating</span></span>:<br/>Understand Sentences - <a href="5-us.html#SP19_11">&#167;19.11</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax"> = </span><a href="5-cg.html#SP6" class="function-link"><span class="function-syntax">CommandGrammars::for_command_verb</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax"> = </span><a href="5-cg.html#SP4" class="function-link"><span class="function-syntax">CommandGrammars::cg_new</span></a><span class="plain-syntax">(</span><span class="constant-syntax">CG_IS_COMMAND</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">command</span><span class="plain-syntax"> = </span><span class="identifier-syntax">W</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::empty</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">GRAMMAR</span><span class="plain-syntax">, </span><span class="string-syntax">"CG%d is the no verb verb\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">allocation_id</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">global_compilation_settings</span><span class="plain-syntax">.</span><span class="identifier-syntax">no_verb_verb_exists</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">GRAMMAR</span><span class="plain-syntax">, </span><span class="string-syntax">"CG%d is the command verb %W\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">allocation_id</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8.  </b>We now have functions to add or remove command verbs from a given CG as aliases.
Note that these cannot be called on the no verb verb.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CommandGrammars::add_alias</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::add_alias</span></span>:<br/>Understand Sentences - <a href="5-us.html#SP15_3">&#167;15.3</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"add alias to null CG"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_is</span><span class="plain-syntax"> != </span><span class="constant-syntax">CG_IS_COMMAND</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"add alias to non-command CG"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">no_aliased_commands</span><span class="plain-syntax"> == </span><span class="constant-syntax">MAX_ALIASED_COMMANDS</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_TooManyAliases</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"this 'understand the command ... as ...' makes too many aliases "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"for the same command"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"exceeding the limit of 32."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">aliased_command</span><span class="plain-syntax">[</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">no_aliased_commands</span><span class="plain-syntax">++] = </span><span class="identifier-syntax">W</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">GRAMMAR</span><span class="plain-syntax">, </span><span class="string-syntax">"Adding alias '%W' to CG%d '%W'\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">allocation_id</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">command</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9.  </b>Removing is trickier, since we might be detaching the main command verb, and
that means that one of the aliases must become the new main verb; or, in the
worst case, there might be no commands left, and in that case we need to empty
the CG of grammar lines so that it can either be ignored or re-used.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CommandGrammars::remove_command</span><button class="popup" onclick="togglePopup('usagePopup7')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup7">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::remove_command</span></span>:<br/>Understand Sentences - <a href="5-us.html#SP15_1">&#167;15.1</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"tried to detach alias command from null CG"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_is</span><span class="plain-syntax"> != </span><span class="constant-syntax">CG_IS_COMMAND</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"tried to detach alias command from non-command CG"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">GRAMMAR</span><span class="plain-syntax">, </span><span class="string-syntax">"Detaching verb '%W' from grammar\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::match</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">command</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">GRAMMAR</span><span class="plain-syntax">, </span><span class="string-syntax">"Detached verb is the head-verb\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">no_aliased_commands</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">first_line</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">GRAMMAR</span><span class="plain-syntax">, </span><span class="string-syntax">"Which had no aliases: clearing grammar to NULL\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">command</span><span class="plain-syntax"> = </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">aliased_command</span><span class="plain-syntax">[--(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">no_aliased_commands</span><span class="plain-syntax">)];</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">GRAMMAR</span><span class="plain-syntax">, </span><span class="string-syntax">"Which had aliases: making new head-verb '%W'\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">command</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">GRAMMAR</span><span class="plain-syntax">, </span><span class="string-syntax">"Detached verb is one of the aliases\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">i</span><span class="function-syntax">&lt;cg-&gt;</span><span class="element-syntax">no_aliased_commands</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::match</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">aliased_command</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">], </span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">j</span><span class="plain-syntax">=</span><span class="identifier-syntax">i</span><span class="plain-syntax">; </span><span class="identifier-syntax">j</span><span class="function-syntax">&lt;cg-&gt;</span><span class="element-syntax">no_aliased_commands</span><span class="plain-syntax">-1; </span><span class="identifier-syntax">j</span><span class="plain-syntax">++)</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">aliased_command</span><span class="plain-syntax">[</span><span class="identifier-syntax">j</span><span class="plain-syntax">] = </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">aliased_command</span><span class="plain-syntax">[</span><span class="identifier-syntax">j</span><span class="plain-syntax">+1];</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">no_aliased_commands</span><span class="plain-syntax">--;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10.  </b>This is needed when the designer asks to make actions inaccessible to
commands from the player, with a line like "Understand nothing as the
dropping action":
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CommandGrammars::remove_action</span><button class="popup" onclick="togglePopup('usagePopup8')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup8">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::remove_action</span></span>:<br/>Actions - <a href="4-act.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="reserved-syntax">action_name</span><span class="plain-syntax"> *</span><span class="identifier-syntax">an</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_is</span><span class="plain-syntax"> == </span><span class="constant-syntax">CG_IS_COMMAND</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><a href="5-cgl.html#SP6" class="function-link"><span class="function-syntax">CGLines::list_remove</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="identifier-syntax">an</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11. The CG_IS_TOKEN form. </b>These are like text substitutions in reverse. For instance, we could define
a token "[suitable colour]", which matches any colour name typed by the player.
</p>

<p class="commentary">Tokens are identified solely by their textual names. There is one and only one
token called "[suitable colour]".
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="function-syntax">CommandGrammars::new_named_token</span><button class="popup" onclick="togglePopup('usagePopup9')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup9">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::new_named_token</span></span>:<br/><a href="5-cg.html#SP12">&#167;12</a><br/>Understand Sentences - <a href="5-us.html#SP19_11">&#167;19.11</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax"> = </span><a href="5-cg.html#SP11" class="function-link"><span class="function-syntax">CommandGrammars::named_token_by_name</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">cg</span><span class="plain-syntax"> = </span><a href="5-cg.html#SP4" class="function-link"><span class="function-syntax">CommandGrammars::cg_new</span></a><span class="plain-syntax">(</span><span class="constant-syntax">CG_IS_TOKEN</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">token_name</span><span class="plain-syntax"> = </span><span class="identifier-syntax">W</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="function-syntax">CommandGrammars::named_token_by_name</span><button class="popup" onclick="togglePopup('usagePopup10')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup10">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::named_token_by_name</span></span>:<br/><a href="5-cg.html#SP12">&#167;12</a><br/>Command Grammar Tokens - <a href="5-cgt.html#SP10">&#167;10</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_is</span><span class="plain-syntax"> == </span><span class="constant-syntax">CG_IS_TOKEN</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Wordings::match</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">token_name</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12.  </b>A slight variation is provided by those which are defined by Inter functions.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CommandGrammars::new_translated_token</span><span class="plain-syntax">(</span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">id</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax"> = </span><a href="5-cg.html#SP11" class="function-link"><span class="function-syntax">CommandGrammars::named_token_by_name</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(),</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_GrammarTranslatedAlready</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"this grammar token has already been translated"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"so there must be some duplication somewhere."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax"> = </span><a href="5-cg.html#SP11" class="function-link"><span class="function-syntax">CommandGrammars::new_named_token</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">RTCommandGrammars::set_CG_IS_TOKEN_identifier</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">id</span><span class="plain-syntax">));</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13. The CG_IS_SUBJECT form. </b>Any inference subject can in theory be given a CG, used to parse unusual forms
of its name. If the source reads:
</p>

<blockquote>
    <p>Understand "frog" as the Brazilian leaping toad.</p>
</blockquote>

<p class="commentary">then "frog" is added to the CG for the toad's inference subject.
</p>

<p class="commentary">The toad is of course an object, and in fact although there are many other
inference subjects in Inform, this system is used only for objects and their
kinds.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>
</p>

<ul class="footnotetexts"><li class="footnote" id="fn:2"><p class="inwebfootnote"><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> Because in our run-time representation, objects and kinds of objects have
data which makes it convenient for them to provide their own "general parsing
routines", whereas enumeration values do not. So to give exotic names to instances
of non-object kinds we use <span class="extract"><span class="extract-syntax">CG_IS_VALUE</span></span> instead. And in any case numbers or
times of day are not inference subjects anyway, so we would need <span class="extract"><span class="extract-syntax">CG_IS_VALUE</span></span>
in any case for those.
<a href="#fnref:2" title="return to text"> &#x21A9;</a></p></li></ul>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="function-syntax">CommandGrammars::for_subject</span><button class="popup" onclick="togglePopup('usagePopup11')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup11">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::for_subject</span></span>:<br/>Understand Sentences - <a href="5-us.html#SP19_11">&#167;19.11</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subj</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">PARSING_DATA_FOR_SUBJ</span><span class="plain-syntax">(</span><span class="identifier-syntax">subj</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">understand_as_this_subject</span><span class="plain-syntax"> != </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">PARSING_DATA_FOR_SUBJ</span><span class="plain-syntax">(</span><span class="identifier-syntax">subj</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">understand_as_this_subject</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax"> = </span><a href="5-cg.html#SP4" class="function-link"><span class="function-syntax">CommandGrammars::cg_new</span></a><span class="plain-syntax">(</span><span class="constant-syntax">CG_IS_SUBJECT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PARSING_DATA_FOR_SUBJ</span><span class="plain-syntax">(</span><span class="identifier-syntax">subj</span><span class="plain-syntax">)-&gt;</span><span class="identifier-syntax">understand_as_this_subject</span><span class="plain-syntax"> = </span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">subj_understood</span><span class="plain-syntax"> = </span><span class="identifier-syntax">subj</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP14" class="paragraph-anchor"></a><b>&#167;14. The CG_IS_VALUE form. </b>This is used to store names for, say, particular numbers, or enumeration
values. The following examples both involve <span class="extract"><span class="extract-syntax">CG_IS_VALUE</span></span> grammars:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">Understand</span><span class="plain-syntax"> </span><span class="string-syntax">"deuce"</span><span class="plain-syntax"> </span><span class="identifier-syntax">as</span><span class="plain-syntax"> </span><span class="constant-syntax">2</span><span class="plain-syntax">.</span>
<span class="identifier-syntax">Colour</span><span class="plain-syntax"> </span><span class="identifier-syntax">is</span><span class="plain-syntax"> </span><span class="identifier-syntax">a</span><span class="plain-syntax"> </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> </span><span class="identifier-syntax">of</span><span class="plain-syntax"> </span><span class="identifier-syntax">value</span><span class="plain-syntax">. </span><span class="identifier-syntax">Red</span><span class="plain-syntax">, </span><span class="identifier-syntax">blue</span><span class="plain-syntax"> </span><span class="identifier-syntax">and</span><span class="plain-syntax"> </span><span class="identifier-syntax">green</span><span class="plain-syntax"> </span><span class="identifier-syntax">are</span><span class="plain-syntax"> </span><span class="identifier-syntax">colours</span><span class="plain-syntax">.</span>
<span class="identifier-syntax">Understand</span><span class="plain-syntax"> </span><span class="string-syntax">"scarlet"</span><span class="plain-syntax"> </span><span class="identifier-syntax">as</span><span class="plain-syntax"> </span><span class="identifier-syntax">red</span><span class="plain-syntax">.</span>
</pre>
<p class="commentary">Note however that a <span class="extract"><span class="extract-syntax">CG_IS_VALUE</span></span> grammar is associated with a kind: unlike
the case of <span class="extract"><span class="extract-syntax">CG_IS_SUBJECT</span></span>, there isn't a different one for each individual
value. There is just one grammar holding all possible fancy names for
different numbers, for example; the <span class="extract"><span class="extract-syntax">CG_IS_VALUE</span></span> grammar for <span class="extract"><span class="extract-syntax">K_number</span></span>.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="function-syntax">CommandGrammars::for_kind</span><button class="popup" onclick="togglePopup('usagePopup12')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup12">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::for_kind</span></span>:<br/>Understand Sentences - <a href="5-us.html#SP19_11">&#167;19.11</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">K</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"cannot get CG for null kind"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="5-cg.html#SP14" class="function-link"><span class="function-syntax">CommandGrammars::get_parsing_grammar</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">) != </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="5-cg.html#SP14" class="function-link"><span class="function-syntax">CommandGrammars::get_parsing_grammar</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax"> = </span><a href="5-cg.html#SP4" class="function-link"><span class="function-syntax">CommandGrammars::cg_new</span></a><span class="plain-syntax">(</span><span class="constant-syntax">CG_IS_VALUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">)) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"cannot set CG for K_object"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_subkind_of_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"object kinds should not have a CG_IS_VALUE grammar"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">K</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">construct</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">understand_as_values</span><span class="plain-syntax"> = </span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">kind_understood</span><span class="plain-syntax"> = </span><span class="identifier-syntax">K</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="function-syntax">CommandGrammars::get_parsing_grammar</span><span class="plain-syntax">(</span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">K</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">)) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"cannot get CG for K_object"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">K</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">construct</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">understand_as_values</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP15" class="paragraph-anchor"></a><b>&#167;15. The CG_IS_CONSULT form. </b>Consultation grammars<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> are used to handle topics of conversation and other
free-form textual parts of commands typed by the player: the player can legally
type ASK JETHRO ABOUT ... and put almost anything after ABOUT, and we need ways
to parse that material.
</p>

<p class="commentary">The model here is rather different. Because the topic being discussed could be
almost anything &mdash; maybe Jethro knows about WHEAT PRICES, the HARVEST and
QUANTUM CHROMODYNAMICS (he has hidden depths) &mdash; there is no obvious data
structure in Inform to attach such a grammar to. Instead, code wishing to
create a new consultation should first call <a href="5-cg.html#SP15" class="internal">CommandGrammars::prepare_consultation_cg</a>,
then access the current one being made using <a href="5-cg.html#SP15" class="internal">CommandGrammars::get_consultation_cg</a>.
Note that exactly one consultation can be made at a time.
</p>

<ul class="footnotetexts"><li class="footnote" id="fn:3"><p class="inwebfootnote"><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> The term "consultation" goes back to the origins of this feature in the
CONSULT command, which in turn goes right back to a game called "Curses" (1993),
in which players consulted a biographical dictionary of the Meldrew family.
<a href="#fnref:3" title="return to text"> &#x21A9;</a></p></li></ul>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">consultation_gv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CommandGrammars::prepare_consultation_cg</span><button class="popup" onclick="togglePopup('usagePopup13')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup13">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::prepare_consultation_cg</span></span>:<br/>Understand Sentences - <a href="5-us.html#SP18">&#167;18</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">consultation_gv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="function-syntax">CommandGrammars::get_consultation_cg</span><button class="popup" onclick="togglePopup('usagePopup14')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup14">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::get_consultation_cg</span></span>:<br/>Understand Sentences - <a href="5-us.html#SP18">&#167;18</a>, <a href="5-us.html#SP19_11">&#167;19.11</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">consultation_gv</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">consultation_gv</span><span class="plain-syntax"> = </span><a href="5-cg.html#SP4" class="function-link"><span class="function-syntax">CommandGrammars::cg_new</span></a><span class="plain-syntax">(</span><span class="constant-syntax">CG_IS_CONSULT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">consultation_gv</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP16" class="paragraph-anchor"></a><b>&#167;16. The CG_IS_PROPERTY_NAME form. </b>A few properties can be recognised by adjectives in the player's commands.
For example, we might allow OPEN or CLOSED in connection with doors. If so,
we may want to allow synonyms or other ways to express this, and so a
property value used adjectivally like this can be given a CG.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="function-syntax">CommandGrammars::for_prn</span><button class="popup" onclick="togglePopup('usagePopup15')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup15">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::for_prn</span></span>:<br/>Understand Sentences - <a href="5-us.html#SP19_11">&#167;19.11</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prn</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">EitherOrProperties::get_parsing_grammar</span><span class="plain-syntax">(</span><span class="identifier-syntax">prn</span><span class="plain-syntax">) != </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">EitherOrProperties::get_parsing_grammar</span><span class="plain-syntax">(</span><span class="identifier-syntax">prn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax"> = </span><a href="5-cg.html#SP4" class="function-link"><span class="function-syntax">CommandGrammars::cg_new</span></a><span class="plain-syntax">(</span><span class="constant-syntax">CG_IS_PROPERTY_NAME</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">EitherOrProperties::set_parsing_grammar</span><span class="plain-syntax">(</span><span class="identifier-syntax">prn</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">prn_understood</span><span class="plain-syntax"> = </span><span class="identifier-syntax">prn</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP17" class="paragraph-anchor"></a><b>&#167;17. The list of grammar lines. </b>Every CG has a list of CGLs: indeed, this list is the point of the grammar. Here
we test this for emptiness, and provide for adding to it. In general removals
are not possible, but see <a href="5-cg.html#SP10" class="internal">CommandGrammars::remove_action</a> above.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">CommandGrammars::is_empty</span><button class="popup" onclick="togglePopup('usagePopup16')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup16">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::is_empty</span></span>:<br/>Understand Sentences - <a href="5-us.html#SP15_2">&#167;15.2</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">cg</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">first_line</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CommandGrammars::add_line</span><button class="popup" onclick="togglePopup('usagePopup17')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup17">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::add_line</span></span>:<br/>Understand Sentences - <a href="5-us.html#SP19">&#167;19</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="reserved-syntax">cg_line</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cgl</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">GRAMMAR</span><span class="plain-syntax">, </span><span class="string-syntax">"$G + line: $g\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="identifier-syntax">cgl</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_is</span><span class="plain-syntax"> == </span><span class="constant-syntax">CG_IS_COMMAND</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><a href="5-cgl.html#SP4" class="function-link"><span class="function-syntax">CGLines::list_length</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">) &gt;= </span><span class="constant-syntax">MAX_LINES_PER_GRAMMAR</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_TooManyGrammarLines</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"this command verb now has too many Understand possibilities"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"that is, there are too many 'Understand \"whatever ...\" as ...' "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"which share the same initial word 'whatever'. The best way to "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"get around this is to try to consolidate some of those lines "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"together, perhaps by using slashes to combine alternative "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"wordings, or by defining new grammar tokens [in square brackets]."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><a href="5-cgl.html#SP5" class="function-link"><span class="function-syntax">CGLines::list_add</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="identifier-syntax">cgl</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP18" class="paragraph-anchor"></a><b>&#167;18.  </b>As noted above, some CGs are used to refer to objects or values: others not.
This returns the kind if so, or <span class="extract"><span class="extract-syntax">NULL</span></span> if not.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="function-syntax">CommandGrammars::get_kind_matched</span><button class="popup" onclick="togglePopup('usagePopup18')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup18">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::get_kind_matched</span></span>:<br/>Command Grammar Tokens - <a href="5-cgt.html#SP14">&#167;14</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="5-dt.html#SP4" class="function-link"><span class="function-syntax">DeterminationTypes::get_single_kind</span></a><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_type</span><span class="plain-syntax">));</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP19" class="paragraph-anchor"></a><b>&#167;19. Slashing and determining. </b>CGs are created and then gradually accumulate grammar lines in response to the
stream of "Understand... as..." sentences. Once all of that is done, we have to
make sense of it all, which we do in two phases: "slashing" and "determining".
</p>

<p class="commentary">Slashing is really a grammar-line based activity, so we do no more than pass
the buck down to <a href="5-cgl.html" class="internal">Command Grammar Lines</a>.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CommandGrammars::prepare</span><button class="popup" onclick="togglePopup('usagePopup19')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup19">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::prepare</span></span>:<br/>Parsing Plugin - <a href="5-pp.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Log::new_stage</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"Slashing command grammar"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">slashed</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">first_line</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">GRAMMAR_CONSTRUCTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Slashing $G\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><a href="5-cgl.html#SP15" class="function-link"><span class="function-syntax">CGLines::slash</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">slashed</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Log::new_stage</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="string-syntax">"Determining command grammar"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER</span><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><a href="5-cg.html#SP20" class="function-link"><span class="function-syntax">CommandGrammars::determine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="constant-syntax">0</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP20" class="paragraph-anchor"></a><b>&#167;20.  </b>Determining is more involved, and is also recursive. What we are doing is
trying to work values a CG can produce, in terms of what value it refers to &mdash;
if any. For <span class="extract"><span class="extract-syntax">CG_IS_COMMAND</span></span> grammars, for example, it will be <span class="extract"><span class="extract-syntax">NULL</span></span>, but
for <span class="extract"><span class="extract-syntax">CG_IS_VALUE</span></span>, it might for example be a description meaning "any value
with kind <span class="extract"><span class="extract-syntax">K_number</span></span>.
</p>

<p class="commentary">Determination is hierarchical. To determine a CG we determine each of its
lines, and they in turn determine each of their tokens. But some of those tokens
will themselves be defined by <span class="extract"><span class="extract-syntax">CG_IS_TOKEN</span></span> grammars, and determining those
recurses back here.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">CommandGrammars::determine</span><button class="popup" onclick="togglePopup('usagePopup20')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup20">Usage of <span class="code-font"><span class="function-syntax">CommandGrammars::determine</span></span>:<br/><a href="5-cg.html#SP19">&#167;19</a><br/>Command Grammar Tokens - <a href="5-cgt.html#SP12">&#167;12</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">depth</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax"> = </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">where_cg_created</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-cg.html#SP20_1" class="named-paragraph-link"><span class="named-paragraph">If this CG produces a value we have determined already, return that</span><span class="named-paragraph-number">20.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-cg.html#SP20_2" class="named-paragraph-link"><span class="named-paragraph">If recursion went impossibly deep, the CG grammar must be ill-founded</span><span class="named-paragraph-number">20.2</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">GRAMMAR_CONSTRUCTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Determining $G\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOG_INDENT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_THROUGH_UNSORTED_CG_LINES</span><span class="plain-syntax">(</span><span class="identifier-syntax">cgl</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><a href="5-cgl.html#SP16" class="function-link"><span class="function-syntax">CGLines::cgl_determine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">cgl</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">, </span><span class="identifier-syntax">depth</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOG_OUTDENT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec_union</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-cg.html#SP20_3" class="named-paragraph-link"><span class="named-paragraph">Take the union of the single-term results of each line</span><span class="named-paragraph-number">20.3</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-cg.html#SP20_4" class="named-paragraph-link"><span class="named-paragraph">Cache the answer so that we need not determine it again</span><span class="named-paragraph-number">20.4</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">spec_union</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP20_1" class="paragraph-anchor"></a><b>&#167;20.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">If this CG produces a value we have determined already, return that</span><span class="named-paragraph-number">20.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">determined</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="5-dt.html#SP4" class="function-link"><span class="function-syntax">DeterminationTypes::get_single_term</span></a><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_type</span><span class="plain-syntax">));</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-cg.html#SP20">&#167;20</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP20_2" class="paragraph-anchor"></a><b>&#167;20.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">If recursion went impossibly deep, the CG grammar must be ill-founded</span><span class="named-paragraph-number">20.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">depth</span><span class="plain-syntax"> &gt; </span><span class="identifier-syntax">NUMBER_CREATED</span><span class="plain-syntax">(</span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_GrammarIllFounded</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"grammar tokens are not allowed to be defined in terms of themselves"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"either directly or indirectly."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-cg.html#SP20">&#167;20</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP20_3" class="paragraph-anchor"></a><b>&#167;20.3.  </b>The "union" referred to below is the widest possible description which
matches the single term of the determination type of each CGL in the list.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Take the union of the single-term results of each line</span><span class="named-paragraph-number">20.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">GRAMMAR_CONSTRUCTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Taking union on $G\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOG_INDENT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">first_flag</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_THROUGH_UNSORTED_CG_LINES</span><span class="plain-syntax">(</span><span class="identifier-syntax">cgl</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec_of_line</span><span class="plain-syntax"> = </span><a href="5-dt.html#SP4" class="function-link"><span class="function-syntax">DeterminationTypes::get_single_term</span></a><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">cgl</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cgl_type</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">first_flag</span><span class="plain-syntax">) { </span><span class="comment-syntax"> initially no expectations: </span><span class="extract"><span class="extract-syntax">spec_union</span></span><span class="comment-syntax"> is meaningless</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">spec_union</span><span class="plain-syntax"> = </span><span class="identifier-syntax">spec_of_line</span><span class="plain-syntax">; </span><span class="comment-syntax"> so we set it to the first result</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">first_flag</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">spec_union</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">spec_of_line</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">))</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">continue</span><span class="plain-syntax">; </span><span class="comment-syntax"> we expected to find no result, and did: so no problem</span>

<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">spec_union</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">spec_of_line</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Dash::compatible_with_description</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec_union</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec_of_line</span><span class="plain-syntax">) == </span><span class="identifier-syntax">ALWAYS_MATCH</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">spec_union</span><span class="plain-syntax"> = </span><span class="identifier-syntax">spec_of_line</span><span class="plain-syntax">; </span><span class="comment-syntax"> here </span><span class="extract"><span class="extract-syntax">spec_of_line</span></span><span class="comment-syntax"> was a wider type</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Dash::compatible_with_description</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec_of_line</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec_union</span><span class="plain-syntax">) == </span><span class="identifier-syntax">ALWAYS_MATCH</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">continue</span><span class="plain-syntax">; </span><span class="comment-syntax"> here </span><span class="extract"><span class="extract-syntax">spec_union</span></span><span class="comment-syntax"> was already wide enough</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="5-cg.html#SP20_3_1" class="named-paragraph-link"><span class="named-paragraph">It is now evident that the lines have incompatible determination types</span><span class="named-paragraph-number">20.3.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">; </span><span class="comment-syntax"> to prevent the problem being repeated for the same grammar</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOG_OUTDENT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">GRAMMAR_CONSTRUCTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Result is $P\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec_union</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-cg.html#SP20">&#167;20</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP20_3_1" class="paragraph-anchor"></a><b>&#167;20.3.1.  </b>In some CGs, it doesn't matter if the lines do different things: for example,
in the CG_IS_COMMAND for the command verb TAKE, "inventory" (void determination
type) and "[things]" (single term determination type) can happily co-exist.
</p>

<p class="commentary">CG_IS_VALUE and CG_IS_SUBJECT are also exceptions because they include grammars
associated with kinds, in which different CGLs may describe different specific
values of that kind. For example, the one for the kind <span class="extract"><span class="extract-syntax">K_number</span></span> might have one
CGL describing the number 17, and another describing 22. There's no good way to
take the union of those numbers.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">It is now evident that the lines have incompatible determination types</span><span class="named-paragraph-number">20.3.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_is</span><span class="plain-syntax"> == </span><span class="constant-syntax">CG_IS_CONSULT</span><span class="plain-syntax">) ||</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_is</span><span class="plain-syntax"> == </span><span class="constant-syntax">CG_IS_SUBJECT</span><span class="plain-syntax">) ||</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_is</span><span class="plain-syntax"> == </span><span class="constant-syntax">CG_IS_COMMAND</span><span class="plain-syntax">) ||</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_is</span><span class="plain-syntax"> == </span><span class="constant-syntax">CG_IS_VALUE</span><span class="plain-syntax">)) </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax"> = </span><span class="identifier-syntax">cgl</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">where_grammar_specified</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"Offending CGL is $g in $G\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">cgl</span><span class="plain-syntax">, </span><span class="identifier-syntax">cg</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_MixedOutcome</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="string-syntax">"grammar tokens must have the same outcome whatever the way they are reached"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"so writing a line like 'Understand \"within\" or \"next to [something]\" "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"as \"[my token]\" must be wrong: one way it produces a thing, the other "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"way it doesn't."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec_union</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-cg.html#SP20_3">&#167;20.3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP20_4" class="paragraph-anchor"></a><b>&#167;20.4.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Cache the answer so that we need not determine it again</span><span class="named-paragraph-number">20.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">determined</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><a href="5-dt.html#SP4" class="function-link"><span class="function-syntax">DeterminationTypes::set_single_term</span></a><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">cg_type</span><span class="plain-syntax">), </span><span class="identifier-syntax">spec_union</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-cg.html#SP20">&#167;20</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP21" class="paragraph-anchor"></a><b>&#167;21. Sorting. </b>The list of lines in a CG needs to be sorted into order before compilation,
to ensure that the player's commands are interpreted correctly whatever order
in which the designer wrote the "Understand... as..." sentences setting it up.
</p>

<p class="commentary">Note that some grammars are compiled more than once, but that we only want to
sort once, so:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">CommandGrammars::sort_command_grammar</span><span class="plain-syntax">(</span><span class="reserved-syntax">command_grammar</span><span class="plain-syntax"> *</span><span class="identifier-syntax">cg</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">sorted_first_line</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">cg</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">sorted_first_line</span><span class="plain-syntax"> = </span><a href="5-cgl.html#SP17" class="function-link"><span class="function-syntax">CGLines::list_sort</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">cg</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="5-us.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-im.html">1</a></li><li class="progresschapter"><a href="2-bd.html">2</a></li><li class="progresschapter"><a href="3-sm.html">3</a></li><li class="progresschapter"><a href="4-ap.html">4</a></li><li class="progresscurrentchapter">5</li><li class="progresssection"><a href="5-pp.html">pp</a></li><li class="progresssection"><a href="5-us.html">us</a></li><li class="progresscurrent">cg</li><li class="progresssection"><a href="5-cgl.html">cgl</a></li><li class="progresssection"><a href="5-cgt.html">cgt</a></li><li class="progresssection"><a href="5-dt.html">dt</a></li><li class="progresssection"><a href="5-pv.html">pv</a></li><li class="progresssection"><a href="5-ts.html">ts</a></li><li class="progressnext"><a href="5-cgl.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

