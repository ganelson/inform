<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Sentence Conversions</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
	tex: {
		inlineMath: '$', '$'], ['\\(', '\\)'
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../index.html">home</a></li>
</ul><h2>Compiler</h2><ul>
<li><a href="../structure.html">structure</a></li>
<li><a href="../inbuildn.html">inbuild</a></li>
<li><a href="../inform7n.html">inform7</a></li>
<li><a href="../intern.html">inter</a></li>
<li><a href="../services.html">services</a></li>
<li><a href="../secrets.html">secrets</a></li>
</ul><h2>Other Tools</h2><ul>
<li><a href="../inblorbn.html">inblorb</a></li>
<li><a href="../indocn.html">indoc</a></li>
<li><a href="../inform6.html">inform6</a></li>
<li><a href="../inpolicyn.html">inpolicy</a></li>
</ul><h2>Resources</h2><ul>
<li><a href="../extensions.html">extensions</a></li>
<li><a href="../kits.html">kits</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=18> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="../../../inweb/index.html">inweb</a></li>
<li><a href="../../../intest/index.html">intest</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Sentence Conversions' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../services.html">Services</a></li><li><a href="index.html">calculus</a></li><li><a href="index.html#5">Chapter 5: Sentences</a></li><li><b>Sentence Conversions</b></li></ul></div>
<p class="purpose">Turning parse trees from English sentences into logical propositions.</p>

<ul class="toc"><li><a href="5-sc.html#SP1">&#167;1. The meaning of a sentence</a></li><li><a href="5-sc.html#SP2">&#167;2. S-subtrees</a></li><li><a href="5-sc.html#SP2_14">&#167;2.14. Simplification</a></li><li><a href="5-sc.html#SP3">&#167;3. The meaning of a noun phrase</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. The meaning of a sentence. </b>"Again and again Haddon thought he had found the key to the strange writings,
but always he was disappointed. And then one day &mdash; he was an old man of seventy
now &mdash; he fed a trial programme into his computer, and for the first time a
translated sentence was delivered &mdash; his life-long task was rewarded. Yes,
but for the fact that one man had been prepared to devote every spare hour of
his life to solving the riddle, the amazing story of the Trigan Empire would
never have been given to the world. WHAT FOLLOWS IS THAT STORY."
("The Rise and Fall of the Trigan Empire", 1965)
</p>

<p class="commentary">Inform turns sentences into parse trees: see <a href="../linguistics-module/P-asd.html" class="internal">About Sentence Diagrams (in linguistics)</a>
for many examples. In such parse trees,
</p>

<ul class="items"><li>&#9679; an "S-subtree" is one representing a verb phrase (VP) or relative phrase (RP), and
</li><li>&#9679; an "SN-subtree" is one representing a noun phrase (NP).
</li></ul>
<p class="commentary">An S-subtree typically contains two SN-subtrees within it, the "subject phrase" (SP)
and the "object phrase" (OP). In the S-subtree for "Katy examines the painting",
"Katy" would be one SN-subtree, the SP, and "painting" the other, the OP. But
note that an S-subtree can also represent a noun, if it expresses a relative
phrase: for example, "an animal which can see the player".
</p>

<p class="commentary">In this section we provide relatively simple, but crucial, functions which
convert these subtrees into logical propositions.
</p>

<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2. S-subtrees. </b>To begin with: S-subtrees.
</p>

<ul class="items"><li>&#9679; If <span class="extract"><span class="extract-syntax">SV_not_SN</span></span> is set, then this expects a complete sentence, and produces
a proposition with no free variables; otherwise this expects a relative phrase
and produces a proposition \(\phi(x)\) with a single free variable \(x\). Thus,
"an animal which can see the player" produces a proposition which expresses
that \(x\) is such an animal without specifying a value of \(x\).
</li><li>&#9679; Rather than being given just one tree location, we have two, <span class="extract"><span class="extract-syntax">A</span></span> and <span class="extract"><span class="extract-syntax">B</span></span>.
<span class="extract"><span class="extract-syntax">A</span></span> is the subject phrase and <span class="extract"><span class="extract-syntax">B</span></span> either the object phrase or some relationship
beneath which is the object phrase. Again, see <a href="../linguistics-module/P-asd.html" class="internal">About Sentence Diagrams (in linguistics)</a>
for the idea.
</li><li>&#9679; A side-effect of the function is to record a copy of the subject term of
the resulting proposition by writing to the term pointed to by <span class="extract"><span class="extract-syntax">subject_of_sentence</span></span>,
if this is not null.
</li></ul>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">; </span><span class="comment-syntax"> recursion depth: used only to clarify the debugging log</span>

<span class="reserved-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="function-syntax">SentencePropositions::S_subtree</span><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">B</span><span class="plain-syntax">, </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subject_of_sentence</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">verb_phrase_negated</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subject_phrase_subtree</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, *</span><span class="identifier-syntax">object_phrase_subtree</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subject_phrase_prop</span><span class="plain-syntax">, *</span><span class="identifier-syntax">object_phrase_prop</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="comment-syntax"> unnecessary initialization to pacify clang, which can't prove it's unnecessary:</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">subject_phrase_term</span><span class="plain-syntax"> = </span><a href="4-trm.html#SP4" class="function-link"><span class="function-syntax">Terms::new_constant</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">object_phrase_term</span><span class="plain-syntax"> = </span><a href="4-trm.html#SP4" class="function-link"><span class="function-syntax">Terms::new_constant</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">verb_phrase_relation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP2_1" class="named-paragraph-link"><span class="named-paragraph">Check the tree position makes sense, and tell the debugging log</span><span class="named-paragraph-number">2.1</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">A</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP2_3" class="named-paragraph-link"><span class="named-paragraph">Handle a THERE subtree, used for "there is/are NP"</span><span class="named-paragraph-number">2.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP2_4" class="named-paragraph-link"><span class="named-paragraph">Find meaning of the VP as a relation and a parity</span><span class="named-paragraph-number">2.4</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP2_8" class="named-paragraph-link"><span class="named-paragraph">Find meanings of the SP and OP as propositions and terms</span><span class="named-paragraph-number">2.8</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP2_9" class="named-paragraph-link"><span class="named-paragraph">Bind up any free variable in the OP and sometimes the SP, too</span><span class="named-paragraph-number">2.9</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP2_13" class="named-paragraph-link"><span class="named-paragraph">Combine the SP, VP and OP meanings into a single proposition for the sentence</span><span class="named-paragraph-number">2.13</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>

<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP2_14" class="named-paragraph-link"><span class="named-paragraph">Simplify the resultant proposition</span><span class="named-paragraph-number">2.14</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP2_2" class="named-paragraph-link"><span class="named-paragraph">Tell the debugging log what the outcome of the sentence was</span><span class="named-paragraph-number">2.2</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">A</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">subject_of_sentence</span><span class="plain-syntax">)) *</span><span class="identifier-syntax">subject_of_sentence</span><span class="plain-syntax"> = </span><span class="identifier-syntax">subject_phrase_term</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP2_1" class="paragraph-anchor"></a><b>&#167;2.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Check the tree position makes sense, and tell the debugging log</span><span class="named-paragraph-number">2.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">A</span><span class="plain-syntax">) </span><a href="5-sc.html#SP5" class="function-link"><span class="function-syntax">SentencePropositions::set_position</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">, </span><span class="string-syntax">"-----------\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">, </span><span class="string-syntax">"[%d] Starting fs on: &lt;%W&gt;\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP2">&#167;2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2_2" class="paragraph-anchor"></a><b>&#167;2.2.  </b>And similarly, on the way out:
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Tell the debugging log what the outcome of the sentence was</span><span class="named-paragraph-number">2.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">, </span><span class="string-syntax">"[%d] fs: %W --&gt; $D\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">--;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP2">&#167;2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2_3" class="paragraph-anchor"></a><b>&#167;2.3.  </b>The English verb "to be" has the syntactic quirk that it likes to have
both SP and OP, even when only one thing is being discussed. We say "it is
raining" and "there are seven continents", inserting "it" and "there"
even though they refer to nothing at all, because we don't like to say
"raining is" or "seven continents are".
</p>

<p class="commentary">At any rate Inform parses a sentence in the form "There is X" or "There
are Y" into a simpler form of tree with just one noun phrase, and no verb
phrase at all. We convert the noun phrase to a proposition \(\phi\) in which
\(x\) is free, then bind it with \(\exists x\) to form \(\exists x: \phi(x)\).
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Handle a THERE subtree, used for "there is/are NP"</span><span class="named-paragraph-number">2.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"THERE subtree misplaced"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><span class="identifier-syntax">B</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax"> = </span><a href="5-sc.html#SP4" class="function-link"><span class="function-syntax">SentencePropositions::from_spec</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax"> = </span><a href="4-bas.html#SP10" class="function-link"><span class="function-syntax">Binding::bind_existential</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP2">&#167;2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2_4" class="paragraph-anchor"></a><b>&#167;2.4.  </b>Here we only locate the subject and object subtrees &mdash; their meanings we
leave for later &mdash; but we do find the content of the verb phrase. Given
the combination of verb and preposition usage (the latter optional), we
extract a binary predicate \(B\). Note that we ignore the parity (whether
negated or not), because we've been told that from above.
</p>

<p class="commentary">Of course a VU also records the tense of the verb, but we ignore that here.
It has no effect on the proposition, only on the moment in history to which
it can be applied.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Find meaning of the VP as a relation and a parity</span><span class="named-paragraph-number">2.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">subject_phrase_subtree</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">subject_phrase_subtree</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><a href="5-sc.html#SP5" class="function-link"><span class="function-syntax">SentencePropositions::error</span></a><span class="plain-syntax">(</span><span class="string-syntax">"SP subtree null"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax"> = </span><span class="identifier-syntax">B</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><a href="5-sc.html#SP5" class="function-link"><span class="function-syntax">SentencePropositions::error</span></a><span class="plain-syntax">(</span><span class="string-syntax">"VP subtree null"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><a href="5-sc.html#SP5" class="function-link"><span class="function-syntax">SentencePropositions::error</span></a><span class="plain-syntax">(</span><span class="string-syntax">"VP subtree broken"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">object_phrase_subtree</span><span class="plain-syntax"> = </span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">verb_usage</span><span class="plain-syntax"> *</span><span class="identifier-syntax">vu</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_verb</span><span class="plain-syntax">(</span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">vu</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><a href="5-sc.html#SP5" class="function-link"><span class="function-syntax">SentencePropositions::error</span></a><span class="plain-syntax">(</span><span class="string-syntax">"verb null"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">VerbUsages::get_tense_used</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">) != </span><span class="identifier-syntax">IS_TENSE</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP2_4_1" class="named-paragraph-link"><span class="named-paragraph">Disallow the past tenses in relative clauses</span><span class="named-paragraph-number">2.4.1</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">preposition</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prep</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_preposition</span><span class="plain-syntax">(</span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">preposition</span><span class="plain-syntax"> *</span><span class="identifier-syntax">second_prep</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_second_preposition</span><span class="plain-syntax">(</span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">verb_phrase_relation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">VerbUsages::get_regular_meaning</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">, </span><span class="identifier-syntax">prep</span><span class="plain-syntax">, </span><span class="identifier-syntax">second_prep</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP2">&#167;2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2_4_1" class="paragraph-anchor"></a><b>&#167;2.4.1.  </b>A sad necessity for Inform, at least:
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Disallow the past tenses in relative clauses</span><span class="named-paragraph-number">2.4.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">SPVerb::throw_past_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP2_4">&#167;2.4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2_5" class="paragraph-anchor"></a><b>&#167;2.5.  </b>First Rule. The "meaning" of a noun phrase is a pair \((\phi, t)\),
where \(\phi\) is a proposition and \(t\) is a term. We read this as "\(t\) such
that \(\phi\) is true". Exactly one of the following will always be true:
</p>

<ul class="items"><li>(a) If the NP talks about a single definite thing \(C\), then \(t=C\) and \(\phi = T\),
the empty proposition.
</li><li>(b) If the NP talks about a single definite thing \(C\) but imposes conditions about its current
situation, then \(t=v\) for some variable \(v\) and \(\phi = \exists v: {\it is}(v, C)\land\psi\)
where \(\psi\) is a description of the conditions with no free variables and which
does not use \(v\).
</li><li>(c) If the NP talks about a single but vague thing, identifying it only by its
current situation, then \(t=v\) for some variable \(v\) and \(\phi\) is a proposition having
\(v\) as its unique free variable.
</li><li>(d) If the NP talks about a range, number or proportion of things, then \(t=v\)
for some variable \(v\) and \(\phi = Qv : v\in\lbrace v\mid \psi(v)\rbrace\), where
\(v\) is the unique free variable of \(\psi\), and \(Q\) is a generalised quantifier which
is not \(\exists\).
</li></ul>
<p class="commentary firstcommentary"><a id="SP2_6" class="paragraph-anchor"></a><b>&#167;2.6.  </b>As examples of all four cases:
</p>

<ul class="items"><li>(a) "Reverend Green" returns \(t=RG\), \(\phi = T\) &mdash; a single definite thing.
</li><li>(b) "Colonel Mustard in the Library" returns \(t=x\) such that
\(\phi = \exists x: {\it is}(x, CM)\land{\it in}(CM, L)\) &mdash; a single definite
thing but subject to conditions.
</li><li>(c) "A suspect carrying the lead piping" returns \(t=x\) and
\(\phi = {\it suspect}(x)\land{\it carries}(x, LP)\) &mdash; a single but vague thing.
</li><li>(d) "All the weapons in the Billiard Room" returns \(t=x\) and
\(\phi = \forall x: x\in\lbrace x\mid {\it weapon}(x)\land{\it in}(x, BR)\rbrace\) &mdash;
a range of things.
</li></ul>
<p class="commentary firstcommentary"><a id="SP2_7" class="paragraph-anchor"></a><b>&#167;2.7.  </b>Thus \(\phi\) can contain at most 1 free variable, and then only in case (c).
But why does it do so at all? Why do we return "an open door" as
\({\it open}(x)\land{\it door}(x)\)? It would be more consistent with the way we
handle "two open doors" to return it as \(\exists x: {\it open}(x)\land{\it door}(x)\).
The answer is that if we were only parsing whole sentences (SV-trees) then
it would make no difference, because \(x\) ends up bound by \(\exists x\)
anyway when the final sentence is being put together. But we also want to
parse descriptions. Consider:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">(1) </span><span class="identifier-syntax">let</span><span class="plain-syntax"> </span><span class="identifier-syntax">L</span><span class="plain-syntax"> </span><span class="identifier-syntax">be</span><span class="plain-syntax"> </span><span class="identifier-syntax">the</span><span class="plain-syntax"> </span><span class="identifier-syntax">list</span><span class="plain-syntax"> </span><span class="identifier-syntax">of</span><span class="plain-syntax"> </span><span class="identifier-syntax">open</span><span class="plain-syntax"> </span><span class="identifier-syntax">doors</span><span class="plain-syntax"> </span><span class="identifier-syntax">in</span><span class="plain-syntax"> </span><span class="identifier-syntax">the</span><span class="plain-syntax"> </span><span class="identifier-syntax">Dining</span><span class="plain-syntax"> </span><span class="identifier-syntax">Room</span><span class="plain-syntax">;</span>
<span class="plain-syntax">(2) </span><span class="identifier-syntax">let</span><span class="plain-syntax"> </span><span class="identifier-syntax">L</span><span class="plain-syntax"> </span><span class="identifier-syntax">be</span><span class="plain-syntax"> </span><span class="identifier-syntax">the</span><span class="plain-syntax"> </span><span class="identifier-syntax">list</span><span class="plain-syntax"> </span><span class="identifier-syntax">of</span><span class="plain-syntax"> </span><span class="identifier-syntax">two</span><span class="plain-syntax"> </span><span class="identifier-syntax">open</span><span class="plain-syntax"> </span><span class="identifier-syntax">doors</span><span class="plain-syntax"> </span><span class="identifier-syntax">in</span><span class="plain-syntax"> </span><span class="identifier-syntax">the</span><span class="plain-syntax"> </span><span class="identifier-syntax">Dining</span><span class="plain-syntax"> </span><span class="identifier-syntax">Room</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary">Here (1) is legal in Inform, (2) is not, because it implies a requirement about
the list which will probably not be satisfied. (Maybe there are three open
doors there, maybe none.) In case (1), <span class="extract"><span class="extract-syntax">NPstp</span></span> applied to "open doors" will
return \({\it open}(x)\land{\it door}(x)\), whose free variable \(x\) can
become any single object we might want to test for open-door-ness. But in
case (2), <span class="extract"><span class="extract-syntax">NPstp</span></span> applied to "two open doors" will return
\(V_{=2} x: {\it open}(x)\land{\it door}(x)\), and here \(x\) is bound, and
can't be set equal to some object being tested.
</p>

<p class="commentary">Or to put this more informally: it's possible for a single item to be an
"open door", but it's not possible for a single item to be (say) "more
than three open doors". So \(\phi\) contains a free variable if and only if
the NP describes a single but vague thing.
</p>

<p class="commentary firstcommentary"><a id="SP2_8" class="paragraph-anchor"></a><b>&#167;2.8.  </b>The First Rule is implemented by <span class="extract"><span class="extract-syntax">SentencePropositions::NP_subtree</span></span> below, and
we apply it independently to the SP and OP:
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Find meanings of the SP and OP as propositions and terms</span><span class="named-paragraph-number">2.8</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subject_K</span><span class="plain-syntax"> = </span><a href="3-bp.html#SP7" class="function-link"><span class="function-syntax">BinaryPredicates::term_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">verb_phrase_relation</span><span class="plain-syntax">, </span><span class="constant-syntax">0</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_subkind_of_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">subject_K</span><span class="plain-syntax">)) </span><span class="identifier-syntax">subject_K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">subject_phrase_prop</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">        </span><a href="5-sc.html#SP3" class="function-link"><span class="function-syntax">SentencePropositions::NP_subtree</span></a><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">subject_phrase_term</span><span class="plain-syntax">, </span><span class="identifier-syntax">subject_phrase_subtree</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">subject_K</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">object_K</span><span class="plain-syntax"> = </span><a href="3-bp.html#SP7" class="function-link"><span class="function-syntax">BinaryPredicates::term_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">verb_phrase_relation</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_subkind_of_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">object_K</span><span class="plain-syntax">)) </span><span class="identifier-syntax">object_K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">object_phrase_prop</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">        </span><a href="5-sc.html#SP3" class="function-link"><span class="function-syntax">SentencePropositions::NP_subtree</span></a><span class="plain-syntax">(&amp;</span><span class="identifier-syntax">object_phrase_term</span><span class="plain-syntax">, </span><span class="identifier-syntax">object_phrase_subtree</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">object_K</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">, </span><span class="string-syntax">"[%d] subject NP: $0 such that: $D\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">subject_phrase_term</span><span class="plain-syntax">, </span><span class="identifier-syntax">subject_phrase_prop</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">, </span><span class="string-syntax">"[%d] object NP: $0 such that: $D\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">object_phrase_term</span><span class="plain-syntax">, </span><span class="identifier-syntax">object_phrase_prop</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP2">&#167;2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2_9" class="paragraph-anchor"></a><b>&#167;2.9.  </b>The First Rule tells us that SP and OP are now each represented by
propositions with either no free variables, or just one, and then only if
the phrase refers to a single but vague thing.
</p>

<p class="commentary">So far we have treated the subject and object exactly alike, running the
same computation on meaning lists generated by the same method. This is
the first point at which the placement as subject rather than object will
start to make a difference:
</p>

<ul class="items"><li>(i) we always bind a free variable in the object, but
</li><li>(ii) we only bind a free variable in the subject in <span class="extract"><span class="extract-syntax">SV_not_SN</span></span>-mode, i.e.,
when our text represents an entire sentence rather than a relative clause.
</li></ul>
<p class="commentary">The SP is called the "subject phrase" because it contributes the subject of
a sentence: what it is a sentence about.
For instance, for an SV-subtree for "a woman is carrying an animal", we
produce \(\phi_S = \exists x: {\it woman}(x)\) and \(\phi_O = \exists x: {\it animal}(x)\).
But for an SN-subtree for "a woman carrying an animal" &mdash; which vaguely
describes something, in a way that can be tested for any given candidate \(x\) &mdash;
we produce \(\phi_S = {\it woman}(x)\) with \(x\) remaining free.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Bind up any free variable in the OP and sometimes the SP, too</span><span class="named-paragraph-number">2.9</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">subject_phrase_prop</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">            </span><a href="4-bas.html#SP10" class="function-link"><span class="function-syntax">Binding::bind_existential</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">subject_phrase_prop</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">subject_phrase_term</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">object_phrase_prop</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">        </span><a href="4-bas.html#SP10" class="function-link"><span class="function-syntax">Binding::bind_existential</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">object_phrase_prop</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">object_phrase_term</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP2">&#167;2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2_10" class="paragraph-anchor"></a><b>&#167;2.10.  </b>Of all the thousands of paragraphs of code in Inform, this is the one which
most sums up "how it works". We started with a sentence in
the source text, and have now extracted the following components of its
meaning: the subject phrase (SP) has become the term \(t_S\) subject to the
proposition \(\phi_S\) being true; the object phrase (OP) is similarly now a
pair \(t_O\) such that \(\phi_O\). From the verb phrase (VP), we have found a
binary relation \(B\), meant either in a positive sense (\(B\) does hold) or a
negative one (it doesn't). And now:
</p>

<p class="commentary">Second Rule. The combined "meaning" \(\Sigma\) is as follows:
</p>

<ul class="items"><li>(1) if we are parsing a whole sentence, or \(\phi_S\) is
not in the form \(Q x\in\lbrace x\mid\theta(x)\rbrace\) for some quantifier \(Q\), then
according to whether the sense is positive or negative we have:
$$ \Sigma = \phi_S \land \phi'_O \land B(t_S, t'_O) \qquad \Sigma = \phi_S \land \lnot(\phi'_O \land B(t_S, t'_O)) $$
</li><li>(2) if we are parsing a relative clause, and \(\phi_S\) is of the form
\(Q x\in\lbrace x\mid\theta(x)\rbrace\), then according to whether the sense is
positive or negative we have:
$$ \Sigma = Q x\in\lbrace x\mid\theta(x) \land \phi'_O \land B(t_S, t'_O)\rbrace \qquad \Sigma = Q x\in\lbrace x\mid\theta(x) \land \lnot(\phi'_O \land B(t_S, t'_O)) $$
Here \(\phi'_O\) and \(t'_O\) are \(\phi_O\) and \(t_O\) modified to relabel its
variables so that there are no accidental clashes with variables in \(\phi_S\).
</li></ul>
<p class="commentary firstcommentary"><a id="SP2_11" class="paragraph-anchor"></a><b>&#167;2.11.  </b>That simple rule took the author a long, long time to work out,
so it may be worth a little discussion:
</p>

<ul class="items"><li>(a) The Second Rule is a generalisation of the way comparison operators like
<span class="extract"><span class="extract-syntax">==</span></span> or <span class="extract"><span class="extract-syntax">&gt;=</span></span> work in conventional programming languages. For if
\(t_S\) and \(t_O\) are both constants, and \(\phi_S\) and \(\phi_O\) both
empty, we obtain just \(B(t_S, t_O)\) and \(\lnot(B(t_S, t_O))\). For instance,
"s is 10" becomes just \({\it is}(s, 10)\), which compiles just to <span class="extract"><span class="extract-syntax">(s == 10)</span></span>.
</li><li>(b) In general, though, the meaning of an English sentence is not just that
the verb is true, but also that the subject and object make sense. For
"a woman is carrying an animal" to be true, there has to be such a woman,
and such an animal. This is the content of \(\phi_S\) and \(\phi_O\). So the
formula above can be read as "the subject makes sense, and the object makes
sense, and they relate to each other in the way that the verb claims".
</li><li>(c) In the case of negation, it's important that we produce
\(\phi_S \land \lnot(\phi'_O \land B(t_S, t_O))\) rather than
\(\phi_S\land\phi'_O\land\lnot(B(t_S, t_O))\). To see the difference, consider
the sentence "The box does not contain three coins". The first formula,
which is correct, means roughly "it's not true that there are three coins
\(x\) such that \(x\) is in the box", whereas the second, wrong, means
"three coins \(x\) exist such that \(x\) is not in the box".
</li><li>(d) Case (2) arises only when a relative clause is qualifying the range of a
collection of things: for instance, in "every man who is in the Garden", we have
\(\phi_S = \forall x\in\lbrace x\mid {\it man}(x)\rbrace\) and then need to
apply the relation \({\it in}(x, G)\). If we used formula (1)
we would then have
$$ \Sigma = \forall x\in\lbrace x\mid {\it man}(x)\rbrace: {\it in}(x, G) $$
which means "every man is in the Garden" &mdash; making a statement about
everything covered by \(\phi_S\), not restricting the coverage of \(\phi_S\),
as a relative clause should. Using formula (2), however, we get:
$$ \Sigma = \forall x\in\lbrace x\mid {\it man}(x)\land {\it in}(x, G)\rbrace $$
</li><li>(e) The modification needed to make \(\phi'_O\) out of \(\phi_O\) does not change
its meaning. Consider the example "a woman is carrying an animal" once again.
\(t_S = x\) and \(\phi_S = {\it woman}(x)\), which use \(x\); and on the other
hand \(t_O = x\) and \(\phi_O = {\it animal}(x)\), which also use \(x\). Clearly
we don't mean the same \(x\) on both sides, so we relabel the OP to get \(y\)
such that \({\it animal}(y)\). There is not really any asymmetry between the
SP and OP here, because it would have been just as good to relabel the SP.
</li></ul>
<p class="commentary firstcommentary"><a id="SP2_12" class="paragraph-anchor"></a><b>&#167;2.12.  </b>Lemma. The result \(\Sigma\) of the Second Rule is a proposition containing
either 0 or 1 free variables; \(\Sigma\) has 1 free variable if and only if we
are converting an SN-subtree, and the subject phrase of the sentence describes
a single thing vaguely.
</p>

<p class="commentary">Proof. \(\phi_O\) contains no free variables, since we bound it up above,
and the same must be true of its relabelled version \(\phi'_O\). If we have
an SV-subtree then \(\phi_S\) similarly contains no free variables; we only
leave it unbound for an SN-subtree. In that case, the First Rule tells us that
it has a free variable if and only if the SP describes a single thing vaguely.
The only other content of \(\Sigma\) is the predicate \(B(t_S, t'_O)\), so extra
free variables can only appear if either \(t_S\) or \(t'_O\) contains a variable
not already seen in \(\phi_S\) and \(\phi'_O\). But cases (b), (c) and (d) of
the First Rule make clear that in any pair \((t, \phi)\) arising from a noun
phrase, either \(t\) is a constant or else it is a variable appearing in \(\phi\).
So the terms of the final \(B\) predicate in \(\Sigma\) cannot add new free
variables, and the lemma is proved.
</p>

<p class="commentary">By similar argument, if \(\phi_S\) and \(\phi_O\) are well-formed propositions
(syntactically valid and using variables either freely or within the scope
of quantification) then so is \(\Sigma\).
</p>

<p class="commentary firstcommentary"><a id="SP2_13" class="paragraph-anchor"></a><b>&#167;2.13.  </b>Now to implement the Second Rule:
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Combine the SP, VP and OP meanings into a single proposition for the sentence</span><span class="named-paragraph-number">2.13</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">use_case_2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">subject_phrase_prop</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">            </span><a href="4-prp.html#SP36" class="function-link"><span class="function-syntax">Propositions::remove_final_close_domain</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">subject_phrase_prop</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">use_case_2</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP2_13_1" class="named-paragraph-link"><span class="named-paragraph">Deal with the English irregularity concerning -where words</span><span class="named-paragraph-number">2.13.1</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">, </span><span class="string-syntax">"[%d] Before renumbering of OP: t = $0, phi = $D\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">object_phrase_term</span><span class="plain-syntax">, </span><span class="identifier-syntax">object_phrase_prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">object_phrase_term</span><span class="plain-syntax">.</span><span class="element-syntax">variable</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">        </span><a href="4-bas.html#SP8" class="function-link"><span class="function-syntax">Binding::renumber_bound</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">object_phrase_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">subject_phrase_prop</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">object_phrase_term</span><span class="plain-syntax">.</span><span class="element-syntax">variable</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">object_phrase_term</span><span class="plain-syntax">.</span><span class="element-syntax">variable</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">26</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"bad OP renumbering"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">, </span><span class="string-syntax">"[%d] After renumbering of OP: t = $0, phi = $D\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">object_phrase_term</span><span class="plain-syntax">, </span><span class="identifier-syntax">object_phrase_prop</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">subject_phrase_prop</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">verb_phrase_negated</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">            </span><a href="4-prp.html#SP14" class="function-link"><span class="function-syntax">Propositions::concatenate</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="4-ap.html#SP4" class="function-link"><span class="function-syntax">Atoms::new</span></a><span class="plain-syntax">(</span><span class="constant-syntax">NEGATION_OPEN_ATOM</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax"> = </span><a href="4-prp.html#SP14" class="function-link"><span class="function-syntax">Propositions::concatenate</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">object_phrase_prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax"> = </span><a href="4-prp.html#SP14" class="function-link"><span class="function-syntax">Propositions::concatenate</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><a href="4-ap.html#SP10" class="function-link"><span class="function-syntax">Atoms::binary_PREDICATE_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">verb_phrase_relation</span><span class="plain-syntax">, </span><span class="identifier-syntax">subject_phrase_term</span><span class="plain-syntax">, </span><span class="identifier-syntax">object_phrase_term</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">verb_phrase_negated</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">            </span><a href="4-prp.html#SP14" class="function-link"><span class="function-syntax">Propositions::concatenate</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="4-ap.html#SP4" class="function-link"><span class="function-syntax">Atoms::new</span></a><span class="plain-syntax">(</span><span class="constant-syntax">NEGATION_CLOSE_ATOM</span><span class="plain-syntax">));</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">use_case_2</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">            </span><a href="4-prp.html#SP14" class="function-link"><span class="function-syntax">Propositions::concatenate</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="4-ap.html#SP4" class="function-link"><span class="function-syntax">Atoms::new</span></a><span class="plain-syntax">(</span><span class="constant-syntax">DOMAIN_CLOSE_ATOM</span><span class="plain-syntax">));</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">, </span><span class="string-syntax">"[%d] Initial meaning: $D\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">, </span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP2">&#167;2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2_13_1" class="paragraph-anchor"></a><b>&#167;2.13.1.  </b>The following provides for the fact that when one says "X is somewhere",
"X is anywhere", "X is nowhere", or "X is everywhere", one is talking about
the location of X and not X itself. Thus, "the keys are somewhere" means
that they have some location, not that they literally are a location. (This
is irregular because it differs from "something" and "someone".)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Deal with the English irregularity concerning -where words</span><span class="named-paragraph-number">2.13.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">IF_MODULE</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">k_atom</span><span class="plain-syntax"> = </span><a href="4-prp.html#SP24" class="function-link"><span class="function-syntax">Propositions::composited_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">object_phrase_prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">k_atom</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Kinds::eq</span><span class="plain-syntax">(</span><a href="2-kp.html#SP3" class="function-link"><span class="function-syntax">KindPredicates::get_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">k_atom</span><span class="plain-syntax">), </span><span class="identifier-syntax">K_room</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">verb_phrase_relation</span><span class="plain-syntax"> == </span><span class="identifier-syntax">R_equality</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">R_room_containment</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><a href="2-kp.html#SP4" class="function-link"><span class="function-syntax">KindPredicates::set_composited</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">k_atom</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">verb_phrase_relation</span><span class="plain-syntax"> = </span><a href="3-bp.html#SP16" class="function-link"><span class="function-syntax">BinaryPredicates::get_reversal</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">R_room_containment</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">, </span><span class="string-syntax">"[%d] Decompositing object: $D\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">, </span><span class="identifier-syntax">object_phrase_prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP2_13">&#167;2.13</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2_14" class="paragraph-anchor"></a><b>&#167;2.14. Simplification. </b>Every proposition generated here, whether it arises as "there is/are" plus a
noun phrase or by the Second Rule, is simplified before being returned.
Because of the way the recursion is set up, this means that intermediate
propositions for relative clauses within a sentence are always simplified
before being used to build the whole sentence.
</p>

<p class="commentary">What happens here is that we try a sequence of tactical moves to change
the proposition for the better &mdash; which usually means eliminating bound
variables, where we can: they are a bad thing because they compile to loops
which may be slow and awkward to construct.
</p>

<p class="commentary">Simplifications are allowed to change \(\Sigma\) &mdash; indeed that's the whole
idea &mdash; but not \(t_S\), the term representing what the sentence talks about.
(Indeed, they aren't even shown what it is.) Moreover, a simplification can
only turn \(\Sigma\) to \(\Sigma'\) if:
</p>

<ul class="items"><li>(i) \(\Sigma'\) remains a syntactically correct proposition with well-formed
quantifiers,
</li><li>(ii) \(\Sigma'\) has the same number of free variables as \(\Sigma\), and
</li><li>(iii) in all situations and for all possible values of any free variables,
\(\Sigma'\) is true if and only if \(\Sigma\) is.
</li></ul>
<p class="commentary">Rules (i) and (ii) are checked as we go, with internal errors thrown if ever
they should fail; the checking takes only a trivial amount of time, and I
generally agree with Tony Hoare's maxim that removing checks like this
in the program as shipped to users is like wearing a life-jacket while
learning to sail on dry land, and then taking it off when going to sea.
Still, rule (iii) can only be ensured by writing the routines carefully.
</p>

<p class="commentary">The simplification functions can all be found in <a href="5-smp.html" class="internal">Simplifications</a>.
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">proposition</span><span class="plain-syntax">, </span><span class="identifier-syntax">simp</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">changed</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">NF</span><span class="plain-syntax"> = </span><a href="4-bas.html#SP4" class="function-link"><span class="function-syntax">Binding::number_free</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">proposition</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">proposition</span><span class="plain-syntax">) </span><span class="identifier-syntax">proposition</span><span class="plain-syntax"> = </span><span class="identifier-syntax">simp</span><span class="plain-syntax">(</span><span class="identifier-syntax">proposition</span><span class="plain-syntax">, &amp;</span><span class="identifier-syntax">changed</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">changed</span><span class="plain-syntax">) </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">, </span><span class="string-syntax">"[%d] %s: $D\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">, #</span><span class="identifier-syntax">simp</span><span class="plain-syntax">, </span><span class="identifier-syntax">proposition</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="4-bas.html#SP2" class="function-link"><span class="function-syntax">Binding::is_well_formed</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">proposition</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) ||</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">NF</span><span class="plain-syntax"> != </span><a href="4-bas.html#SP4" class="function-link"><span class="function-syntax">Binding::number_free</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">proposition</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"Failed after applying %s: $D"</span><span class="plain-syntax">, #</span><span class="identifier-syntax">simp</span><span class="plain-syntax">, </span><span class="identifier-syntax">proposition</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(#</span><span class="identifier-syntax">simp</span><span class="plain-syntax"> </span><span class="string-syntax">" simplified proposition into one which is not well-formed"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Simplify the resultant proposition</span><span class="named-paragraph-number">2.14</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="4-bas.html#SP2" class="function-link"><span class="function-syntax">Binding::is_well_formed</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"Failed before simplification: $D"</span><span class="plain-syntax">, </span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"tried to simplify proposition which is not well-formed"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP2" class="function-link"><span class="function-syntax">Simplifications::nothing_constant</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP3" class="function-link"><span class="function-syntax">Simplifications::use_listed_in</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP4" class="function-link"><span class="function-syntax">Simplifications::negated_determiners_nonex</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP6" class="function-link"><span class="function-syntax">Simplifications::negated_satisfiable</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP7" class="function-link"><span class="function-syntax">Simplifications::make_kinds_of_value_explicit</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP8" class="function-link"><span class="function-syntax">Simplifications::redundant_kinds</span></a><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP10" class="function-link"><span class="function-syntax">Simplifications::turn_right_way_round</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP11" class="function-link"><span class="function-syntax">Simplifications::region_containment</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP19" class="function-link"><span class="function-syntax">Simplifications::everywhere_and_nowhere</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP12" class="function-link"><span class="function-syntax">Simplifications::reduce_predicates</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP13" class="function-link"><span class="function-syntax">Simplifications::eliminate_redundant_variables</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP14" class="function-link"><span class="function-syntax">Simplifications::not_related_to_something</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP15" class="function-link"><span class="function-syntax">Simplifications::convert_gerunds</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP16" class="function-link"><span class="function-syntax">Simplifications::eliminate_to_have</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP18" class="function-link"><span class="function-syntax">Simplifications::is_all_rooms</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">APPLY_SIMP</span><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><a href="5-smp.html#SP8" class="function-link"><span class="function-syntax">Simplifications::redundant_kinds</span></a><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><a href="4-bas.html#SP7" class="function-link"><span class="function-syntax">Binding::renumber</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sentence_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">); </span><span class="comment-syntax"> just for the sake of tidiness</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP2">&#167;2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3. The meaning of a noun phrase. </b>The First Rule tells us to translate a noun phrase (NP) into a pair of a term \(t\)
and a proposition \(\phi\). We read this as "\(t\) such that \(\phi\) is true".
</p>

<p class="commentary">For reasons explained below, a small amount of context is supplied: if the
term will need to have a particular kind of value, then that kind is given
to us. (But if it only needs to be an object, or if we don't know anything
about its kind, the <span class="extract"><span class="extract-syntax">K</span></span> argument will be <span class="extract"><span class="extract-syntax">NULL</span></span>.)
</p>

<p class="commentary">As can be seen, an NP subtree consists either of an SN subtree representing
two further NPs joined by a verb to make a relative clause, or one of
three basic noun phrases: a value, a description, or a marker for an implied
but missing noun.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="function-syntax">SentencePropositions::NP_subtree</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">SentencePropositions::NP_subtree</span></span>:<br/><a href="5-sc.html#SP2_8">&#167;2.8</a>, <a href="5-sc.html#SP3_1">&#167;3.1</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP3_1" class="named-paragraph-link"><span class="named-paragraph">Tell the debugging log about the NP-subtree</span><span class="named-paragraph-number">3.1</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">st</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_subject_term</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">st</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        *</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax"> = *</span><span class="identifier-syntax">st</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax"> = </span><a href="4-prp.html#SP13" class="function-link"><span class="function-syntax">Propositions::copy</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NP_TO_PROPOSITION</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">NP_IS_DESCRIPTIVE</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">)) </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP3_4" class="named-paragraph-link"><span class="named-paragraph">This NP was parsed as a description</span><span class="named-paragraph-number">3.4</span></a></span>
<span class="plain-syntax">        </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">) == </span><span class="identifier-syntax">UNKNOWN_NT</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP3_5" class="named-paragraph-link"><span class="named-paragraph">This NP is only a ghostly presence</span><span class="named-paragraph-number">3.5</span></a></span>
<span class="plain-syntax">        </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP3_3" class="named-paragraph-link"><span class="named-paragraph">This NP was parsed as a value</span><span class="named-paragraph-number">3.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>

<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP3_6" class="named-paragraph-link"><span class="named-paragraph">If we have a single adjective which could also be a noun, and a value is required, convert it to a noun</span><span class="named-paragraph-number">3.6</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP3_7" class="named-paragraph-link"><span class="named-paragraph">If we have a constant qualified by a substantive proposition, rewrite in terms of variable</span><span class="named-paragraph-number">3.7</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP3_8" class="named-paragraph-link"><span class="named-paragraph">Close any open domain group</span><span class="named-paragraph-number">3.8</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP3_2" class="named-paragraph-link"><span class="named-paragraph">Verify that the output satisfies the First Rule, throwing internal errors if not</span><span class="named-paragraph-number">3.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3_1" class="paragraph-anchor"></a><b>&#167;3.1.  </b>Just as for SV-subtrees, we tell the debugging log at the start...
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Tell the debugging log about the NP-subtree</span><span class="named-paragraph-number">3.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">, </span><span class="string-syntax">"[%d] Starting SentencePropositions::NP_subtree on: &lt;%W&gt;\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP3">&#167;3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP3_2" class="paragraph-anchor"></a><b>&#167;3.2.  </b>...and also at the end.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Verify that the output satisfies the First Rule, throwing internal errors if not</span><span class="named-paragraph-number">3.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="4-bas.html#SP2" class="function-link"><span class="function-syntax">Binding::is_well_formed</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"malformed NP proposition"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">NF</span><span class="plain-syntax"> = </span><a href="4-bas.html#SP4" class="function-link"><span class="function-syntax">Binding::number_free</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">NF</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">2</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"two or more free variables from NP"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">constant</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"constant plus substantive prop from NP"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">NF</span><span class="plain-syntax"> == </span><span class="constant-syntax">1</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">v</span><span class="plain-syntax"> = </span><a href="4-trm.html#SP8" class="function-link"><span class="function-syntax">Terms::variable_underlying</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="4-bas.html#SP3" class="function-link"><span class="function-syntax">Binding::status</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">v</span><span class="plain-syntax">) != </span><span class="constant-syntax">FREE_VST</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"free variable from NP but not the preferred term"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"[%d] SentencePropositions::NP_subtree: %W --&gt; t = $0, phi = $D\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax">, </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">--;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP3">&#167;3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP3_3" class="paragraph-anchor"></a><b>&#167;3.3.  </b>Here we find a constant \(C\) and return \(t=C\) with a null \(\phi\), except
in one case: where \(C\) is the name of an either/or property, such as
"closed". In the context of a value, this is a noun &mdash; it identifies
which property we are talking about. But inside a sentence, it
has to be considered an adjective, so rather than returning
\(t = {\it closed}, \phi = T\), we return \(t=x\) and \(\phi = {\it closed}(x)\).
If we didn't do this, text like "the trapdoor is closed" would translate to the
proposition \({\it is}({\it trapdoor}, {\it closed})\), which would then fail in
type-checking.
</p>

<p class="commentary">(Note that this is a different sort of noun/adjective ambiguity than the
one arising below, which is to do with enumerated value properties.)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">This NP was parsed as a value</span><span class="named-paragraph-number">3.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax"> = </span><a href="4-trm.html#SP4" class="function-link"><span class="function-syntax">Terms::new_constant</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Rvalues::is_CONSTANT_construction</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">CON_property</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prn</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::to_property</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Properties::is_either_or</span><span class="plain-syntax">(</span><span class="identifier-syntax">prn</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            *</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax"> = </span><a href="4-trm.html#SP4" class="function-link"><span class="function-syntax">Terms::new_variable</span></a><span class="plain-syntax">(0);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">AdjectivalPredicates::new_atom_on_x</span><span class="plain-syntax">(</span><span class="identifier-syntax">EitherOrProperties::as_adjective</span><span class="plain-syntax">(</span><span class="identifier-syntax">prn</span><span class="plain-syntax">), </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ValueProperties::coincides_with_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">prn</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            *</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax"> = </span><a href="4-trm.html#SP4" class="function-link"><span class="function-syntax">Terms::new_variable</span></a><span class="plain-syntax">(0);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">ValueProperties::kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">prn</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax"> = </span><a href="2-kp.html#SP3" class="function-link"><span class="function-syntax">KindPredicates::new_atom</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">, </span><a href="4-trm.html#SP4" class="function-link"><span class="function-syntax">Terms::new_variable</span></a><span class="plain-syntax">(0));</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP3">&#167;3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP3_4" class="paragraph-anchor"></a><b>&#167;3.4.  </b>If <span class="extract"><span class="extract-syntax">SentencePropositions::from_spec</span></span> is given a constant value \(C\) then it returns the
proposition \({\it is}(x, C)\): we look out for this and translate it to
\(t=C, \phi = T\). Otherwise, \(\phi\) can be exactly the proposition returned,
and the first term occurring in it will be chosen as the subject \(t\). (In
particular, if \(\phi\) opens with a quantifier then \(t\) will be the variable
it binds.)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">This NP was parsed as a description</span><span class="named-paragraph-number">3.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax"> = </span><a href="4-prp.html#SP13" class="function-link"><span class="function-syntax">Propositions::copy</span></a><span class="plain-syntax">(</span><a href="5-sc.html#SP4" class="function-link"><span class="function-syntax">SentencePropositions::from_spec</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">));</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="4-prp.html#SP22" class="function-link"><span class="function-syntax">Propositions::match</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">, </span><span class="constant-syntax">2</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="constant-syntax">PREDICATE_ATOM</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="constant-syntax">END_PROP_HERE</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pt</span><span class="plain-syntax"> = </span><a href="4-ap.html#SP12" class="function-link"><span class="function-syntax">Atoms::is_x_equals</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pt</span><span class="plain-syntax">) { *</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax"> = *</span><span class="identifier-syntax">pt</span><span class="plain-syntax">; </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; }</span>
<span class="plain-syntax">    }</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="4-prp.html#SP22" class="function-link"><span class="function-syntax">Propositions::match</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">, </span><span class="constant-syntax">2</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="constant-syntax">PREDICATE_ATOM</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind_up_family</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="constant-syntax">END_PROP_HERE</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="function-syntax">&lt;k-formal-variable-singular&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><a href="2-kp.html#SP5" class="function-link"><span class="function-syntax">KindPredicates::set_unarticled</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">) *</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax"> = </span><a href="4-prp.html#SP28" class="function-link"><span class="function-syntax">Propositions::get_first_cited_term</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP3">&#167;3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP3_5" class="paragraph-anchor"></a><b>&#167;3.5.  </b>When Inform reads a condition so abbreviated that both the subject and
the verb have been left out, it assumes the verb is "to be" and that the
subject will be whatever is being worked on. For instance,
</p>

<blockquote>
    <p>if an unlocked container, ...</p>
</blockquote>

<p class="commentary">is read as the verb phrase "is" with <span class="extract"><span class="extract-syntax">ABSENT_SUBJECT_NT</span></span> as SP
and "an unlocked container" as OP.
</p>

<p class="commentary"><span class="extract"><span class="extract-syntax">ABSENT_SUBJECT_NT</span></span> nodes are easy to deal with since they translate to the I6
variable <span class="extract"><span class="extract-syntax">self</span></span> in the final compiled code. From a predicate calculus point
of view, this is just another constant.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">This NP is only a ghostly presence</span><span class="named-paragraph-number">3.5</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax"> = </span><a href="4-trm.html#SP4" class="function-link"><span class="function-syntax">Terms::new_constant</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">Rvalues::new_self_object_constant</span><span class="plain-syntax">());</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP3">&#167;3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP3_6" class="paragraph-anchor"></a><b>&#167;3.6.  </b>Suppose we have a situation like this:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">Texture</span><span class="plain-syntax"> </span><span class="identifier-syntax">is</span><span class="plain-syntax"> </span><span class="identifier-syntax">a</span><span class="plain-syntax"> </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> </span><span class="identifier-syntax">of</span><span class="plain-syntax"> </span><span class="identifier-syntax">value</span><span class="plain-syntax">. </span><span class="identifier-syntax">Rough</span><span class="plain-syntax">, </span><span class="identifier-syntax">smooth</span><span class="plain-syntax"> </span><span class="identifier-syntax">and</span><span class="plain-syntax"> </span><span class="identifier-syntax">jagged</span><span class="plain-syntax"> </span><span class="identifier-syntax">are</span><span class="plain-syntax"> </span><span class="identifier-syntax">textures</span><span class="plain-syntax">.  </span><span class="identifier-syntax">A</span><span class="plain-syntax"> </span><span class="identifier-syntax">thing</span><span class="plain-syntax"> </span><span class="identifier-syntax">has</span><span class="plain-syntax"> </span><span class="identifier-syntax">a</span><span class="plain-syntax"> </span><span class="identifier-syntax">texture</span><span class="plain-syntax">.</span>
<span class="identifier-syntax">Feeling</span><span class="plain-syntax"> </span><span class="identifier-syntax">relates</span><span class="plain-syntax"> </span><span class="identifier-syntax">various</span><span class="plain-syntax"> </span><span class="identifier-syntax">rooms</span><span class="plain-syntax"> </span><span class="identifier-syntax">to</span><span class="plain-syntax"> </span><span class="identifier-syntax">one</span><span class="plain-syntax"> </span><span class="identifier-syntax">texture</span><span class="plain-syntax">. </span><span class="identifier-syntax">The</span><span class="plain-syntax"> </span><span class="identifier-syntax">verb</span><span class="plain-syntax"> </span><span class="identifier-syntax">to</span><span class="plain-syntax"> </span><span class="identifier-syntax">feel</span><span class="plain-syntax"> (</span><span class="identifier-syntax">he</span><span class="plain-syntax"> </span><span class="identifier-syntax">feels</span><span class="plain-syntax">) </span><span class="identifier-syntax">implies</span><span class="plain-syntax"> </span><span class="identifier-syntax">the</span><span class="plain-syntax"> </span><span class="identifier-syntax">feeling</span><span class="plain-syntax"> </span><span class="identifier-syntax">relation</span><span class="plain-syntax">.</span>
</pre>
<p class="commentary">and consider the sentences:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="comment-syntax">[1]</span><span class="plain-syntax"> </span><span class="identifier-syntax">the</span><span class="plain-syntax"> </span><span class="identifier-syntax">broken</span><span class="plain-syntax"> </span><span class="identifier-syntax">bottle</span><span class="plain-syntax"> </span><span class="identifier-syntax">is</span><span class="plain-syntax"> </span><span class="identifier-syntax">jagged</span>
<span class="comment-syntax">[2]</span><span class="plain-syntax"> </span><span class="identifier-syntax">the</span><span class="plain-syntax"> </span><span class="identifier-syntax">Spiky</span><span class="plain-syntax"> </span><span class="identifier-syntax">Cavern</span><span class="plain-syntax"> </span><span class="identifier-syntax">feels</span><span class="plain-syntax"> </span><span class="identifier-syntax">jagged</span>
</pre>
<p class="commentary">Now suppose we are working on the NP "jagged". In (1), it's an adjective: we
are talking about a quality of the bottle. But in (2), it's a noun: we are
establishing a relation between two values, the Cavern and the jagged texture.
</p>

<p class="commentary">Up to this point, "jagged" will have produced \(t=x\), \(\phi={\it jagged}(x)\)
in both cases &mdash; the adjectival reading of the word. The way we can tell if we
are in case (2) is if a value of a specific kind (and not an object) is
expected as the outcome. In the case of the equality relation used in (1),
"is", the terms can be anything; but in the case of the feeling relation
used in (2), the second term, corresponding to the noun phrase "jagged" in
this sentence, has to have the kind of value "texture". So we convert it
into noun form, and return \(t={\it texture}, \phi = T\).
</p>

<p class="commentary">(Note that this is a different sort of noun/adjective ambiguity than the
one arising above, which is to do with either/or properties.)
</p>

<p class="commentary">Another case which can occur is:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">the</span><span class="plain-syntax"> </span><span class="identifier-syntax">bottle</span><span class="plain-syntax"> </span><span class="identifier-syntax">provides</span><span class="plain-syntax"> </span><span class="identifier-syntax">the</span><span class="plain-syntax"> </span><span class="identifier-syntax">property</span><span class="plain-syntax"> </span><span class="identifier-syntax">closed</span>
</pre>
<p class="commentary">where the presence of the words "the property" needs to alert us that
"closed" is a noun referring to the property itself, not to a nameless
object possessing that property. When the S-parser matches a property in
that way, it assigns a score value of <span class="extract"><span class="extract-syntax">TRUE</span></span> to the relevant ML entry to
show this. (Score values otherwise aren't used for property names.)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">If we have a single adjective which could also be a noun, and a value is required, convert it to a noun</span><span class="named-paragraph-number">3.6</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (((</span><span class="identifier-syntax">Rvalues::is_CONSTANT_construction</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">CON_property</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">property_name_used_as_noun_ANNOT</span><span class="plain-syntax">))) || (</span><span class="identifier-syntax">K</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">pcalc_term</span><span class="plain-syntax"> </span><span class="identifier-syntax">pct</span><span class="plain-syntax"> = </span><a href="4-prp.html#SP29" class="function-link"><span class="function-syntax">Propositions::convert_adj_to_noun</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pct</span><span class="plain-syntax">.</span><span class="element-syntax">constant</span><span class="plain-syntax">) { *</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax"> = </span><span class="identifier-syntax">pct</span><span class="plain-syntax">; </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP3">&#167;3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP3_7" class="paragraph-anchor"></a><b>&#167;3.7.  </b>If we have so far produced a constant term \(t = C\) and a non-null proposition
\(\phi\), then we convert \(t\) to a new free variable, say \(t = y\), we then bind
any free variable in the old \(\phi\) and then change to \(\exists y: {\it is}(y, C)\land\phi\).
For instance, if we are working on the OP "the box in a room" from this:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">a</span><span class="plain-syntax"> </span><span class="identifier-syntax">thing</span><span class="plain-syntax"> </span><span class="identifier-syntax">in</span><span class="plain-syntax"> </span><span class="identifier-syntax">the</span><span class="plain-syntax"> </span><span class="identifier-syntax">box</span><span class="plain-syntax"> </span><span class="identifier-syntax">in</span><span class="plain-syntax"> </span><span class="identifier-syntax">a</span><span class="plain-syntax"> </span><span class="identifier-syntax">room</span>
</pre>
<p class="commentary">then the constant is $C = <span class="extract"><span class="extract-syntax">box</span></span>$, and Sstp returned
$\phi = \exists x: {\it room}(x)\land{\it is}(x, <span class="extract"><span class="extract-syntax">ContainerOf(box)</span></span>)$.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">If we have a constant qualified by a substantive proposition, rewrite in terms of variable</span><span class="named-paragraph-number">3.7</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">constant</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">y</span><span class="plain-syntax"> = </span><a href="4-bas.html#SP5" class="function-link"><span class="function-syntax">Binding::find_unused</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"[%d] Rewriting qualified constant t = $0 (new var %d)\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">, </span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax">, </span><span class="identifier-syntax">y</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax"> = </span><a href="4-prp.html#SP14" class="function-link"><span class="function-syntax">Propositions::concatenate</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">            </span><a href="4-ap.html#SP10" class="function-link"><span class="function-syntax">Atoms::binary_PREDICATE_new</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">R_equality</span><span class="plain-syntax">, *</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax">, </span><a href="4-trm.html#SP4" class="function-link"><span class="function-syntax">Terms::new_variable</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">y</span><span class="plain-syntax">)),</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        *</span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax"> = </span><a href="4-trm.html#SP4" class="function-link"><span class="function-syntax">Terms::new_variable</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">y</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax"> = </span><a href="4-bas.html#SP10" class="function-link"><span class="function-syntax">Binding::bind_existential</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PREDICATE_CALCULUS</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"[%d] Rewriting qualified constant: &lt;%W&gt; --&gt; t = $0, phi = $D\n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">conv_log_depth</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">subject_of_NP</span><span class="plain-syntax">, </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP3">&#167;3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP3_8" class="paragraph-anchor"></a><b>&#167;3.8.  </b>If the NP was something like "at least four open doors", we will so far
have built <span class="extract"><span class="extract-syntax">QUANTIFIER --&gt; DOMAIN_OPEN --&gt; KIND --&gt; PREDICATE</span></span>, and now that
we have reached the end of the noun phrase we need to add a <span class="extract"><span class="extract-syntax">DOMAIN_CLOSE</span></span>
atom. The following is written in a way that guarantees all such open groups
are closed, but in fact there should only ever be one open, so <span class="extract"><span class="extract-syntax">nq</span></span> should
always evaluate to 0 or 1.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Close any open domain group</span><span class="named-paragraph-number">3.8</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">, </span><span class="identifier-syntax">nq</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">TRAVERSE_VARIABLE</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">TRAVERSE_PROPOSITION</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">element</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">DOMAIN_OPEN_ATOM:</span><span class="plain-syntax"> </span><span class="identifier-syntax">nq</span><span class="plain-syntax">++; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">DOMAIN_CLOSE_ATOM:</span><span class="plain-syntax"> </span><span class="identifier-syntax">nq</span><span class="plain-syntax">--; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">nq</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"malformed proposition with too many domain ends"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">i</span><span class="plain-syntax">=1; </span><span class="identifier-syntax">i</span><span class="plain-syntax">&lt;=</span><span class="identifier-syntax">nq</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax"> = </span><a href="4-prp.html#SP14" class="function-link"><span class="function-syntax">Propositions::concatenate</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NP_prop</span><span class="plain-syntax">, </span><a href="4-ap.html#SP4" class="function-link"><span class="function-syntax">Atoms::new</span></a><span class="plain-syntax">(</span><span class="constant-syntax">DOMAIN_CLOSE_ATOM</span><span class="plain-syntax">));</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP3">&#167;3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4.  </b>The following routine takes a SP and returns the best proposition it can,
with a single unbound variable, to represent SP.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="function-syntax">SentencePropositions::from_spec</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">SentencePropositions::from_spec</span></span>:<br/><a href="5-sc.html#SP2_3">&#167;2.3</a>, <a href="5-sc.html#SP3_4">&#167;3.4</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="comment-syntax"> the null description is universally true</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NP_TO_PROPOSITION</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">prop</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">prop</span><span class="plain-syntax">; </span><span class="comment-syntax"> a propositional form is already made</span>

<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP4_1" class="named-paragraph-link"><span class="named-paragraph">If this is an instance of a kind, but can be used adjectivally, convert it as such</span><span class="named-paragraph-number">4.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP4_2" class="named-paragraph-link"><span class="named-paragraph">If it's an either-or property name, it must be being used adjectivally</span><span class="named-paragraph-number">4.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP4_3" class="named-paragraph-link"><span class="named-paragraph">It must be an ordinary noun</span><span class="named-paragraph-number">4.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4_1" class="paragraph-anchor"></a><b>&#167;4.1.  </b>For example, if we have written:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">Colour</span><span class="plain-syntax"> </span><span class="identifier-syntax">is</span><span class="plain-syntax"> </span><span class="identifier-syntax">a</span><span class="plain-syntax"> </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> </span><span class="identifier-syntax">of</span><span class="plain-syntax"> </span><span class="identifier-syntax">value</span><span class="plain-syntax">. </span><span class="identifier-syntax">The</span><span class="plain-syntax"> </span><span class="identifier-syntax">colours</span><span class="plain-syntax"> </span><span class="identifier-syntax">are</span><span class="plain-syntax"> </span><span class="identifier-syntax">pink</span><span class="plain-syntax">, </span><span class="identifier-syntax">green</span><span class="plain-syntax"> </span><span class="identifier-syntax">and</span><span class="plain-syntax"> </span><span class="identifier-syntax">black</span><span class="plain-syntax">. </span><span class="identifier-syntax">A</span><span class="plain-syntax"> </span><span class="identifier-syntax">thing</span><span class="plain-syntax"> </span><span class="identifier-syntax">has</span><span class="plain-syntax"> </span><span class="identifier-syntax">a</span><span class="plain-syntax"> </span><span class="identifier-syntax">colour</span><span class="plain-syntax">.</span>
</pre>
<p class="commentary">then "pink" is both a noun and an adjective. If SP is its representation as a
noun, we return the proposition testing it adjectivally: {\it pink}(\(x\)).
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">If this is an instance of a kind, but can be used adjectivally, convert it as such</span><span class="named-paragraph-number">4.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::to_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pname</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Properties::property_with_same_name_as</span><span class="plain-syntax">(</span><span class="identifier-syntax">Instances::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pname</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">AdjectivalPredicates::new_atom_on_x</span><span class="plain-syntax">(</span><span class="identifier-syntax">Instances::as_adjective</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP4_1_1" class="named-paragraph-link"><span class="named-paragraph">Typecheck the propositional form, and return</span><span class="named-paragraph-number">4.1.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP4">&#167;4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP4_2" class="paragraph-anchor"></a><b>&#167;4.2.  </b>For example, if the SP is "scenery", we return the proposition {\it scenery}(\(x\)).
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">If it's an either-or property name, it must be being used adjectivally</span><span class="named-paragraph-number">4.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Rvalues::is_CONSTANT_construction</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">CON_property</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prn</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::to_property</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Properties::is_either_or</span><span class="plain-syntax">(</span><span class="identifier-syntax">prn</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">AdjectivalPredicates::new_atom_on_x</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">EitherOrProperties::as_adjective</span><span class="plain-syntax">(</span><span class="identifier-syntax">prn</span><span class="plain-syntax">), </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP4_1_1" class="named-paragraph-link"><span class="named-paragraph">Typecheck the propositional form, and return</span><span class="named-paragraph-number">4.1.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP4">&#167;4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP4_3" class="paragraph-anchor"></a><b>&#167;4.3.  </b>For example, if the SP is the number 17, we return the proposition {\it is}(\(x\), 17).
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">It must be an ordinary noun</span><span class="named-paragraph-number">4.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">prop</span><span class="plain-syntax"> = </span><a href="4-ap.html#SP11" class="function-link"><span class="function-syntax">Atoms::prop_x_is_constant</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">Node::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="5-sc.html#SP4_1_1" class="named-paragraph-link"><span class="named-paragraph">Typecheck the propositional form, and return</span><span class="named-paragraph-number">4.1.1</span></a></span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP4">&#167;4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP4_1_1" class="paragraph-anchor"></a><b>&#167;4.1.1.  </b>In all cases, we finish by doing the following. In the one-atom noun cases
it's a formality, but we want to enforce the rule that all propositions
created in Inform go through type-checking, so:
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Typecheck the propositional form, and return</span><span class="named-paragraph-number">4.1.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><a href="4-tcp.html#SP4" class="function-link"><span class="function-syntax">TypecheckPropositions::type_check</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">prop</span><span class="plain-syntax">, </span><a href="4-tcp.html#SP2" class="function-link"><span class="function-syntax">TypecheckPropositions::tc_no_problem_reporting</span></a><span class="plain-syntax">());</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">prop</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="5-sc.html#SP4_1">&#167;4.1</a>, <a href="5-sc.html#SP4_2">&#167;4.2</a>, <a href="5-sc.html#SP4_3">&#167;4.3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5.  </b>These are failed assertions, not for problem messages the user will ever see,
touch wood.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">SentencePropositions::set_position</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">SentencePropositions::set_position</span></span>:<br/><a href="5-sc.html#SP2_1">&#167;2.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::s_subtree_error_set_position</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">A</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">}</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">SentencePropositions::error</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">SentencePropositions::error</span></span>:<br/><a href="5-sc.html#SP2_4">&#167;2.4</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">char</span><span class="plain-syntax"> *</span><span class="identifier-syntax">plaint</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::s_subtree_error</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">plaint</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifndef</span><span class="plain-syntax"> </span><span class="identifier-syntax">CORE_MODULE</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="identifier-syntax">plaint</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="4-tcp.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-cm.html">1</a></li><li class="progresschapter"><a href="2-up.html">2</a></li><li class="progresschapter"><a href="3-bpf.html">3</a></li><li class="progresschapter"><a href="4-trm.html">4</a></li><li class="progresscurrentchapter">5</li><li class="progresscurrent">sc</li><li class="progresssection"><a href="5-smp.html">smp</a></li><li class="progressnext"><a href="5-smp.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

