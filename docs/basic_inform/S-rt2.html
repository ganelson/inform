<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>S/rkt</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">
		<link href="inweb.css" rel="stylesheet" rev="stylesheet" type="text/css">
	</head>
	<body>

<!--Weave of 'S/rt2' generated by 7-->
<ul class="crumbs"><li><a href="../webs.html">&#9733;</a></li><li><a href="index.html">basic_inform Template Library</a></li><li><b>Relations Template</b></li></ul><p class="purpose">To manage run-time storage for relations between objects, and to find routes through relations and the map.</p>

<ul class="toc"><li><a href="#SP1">&#167;1. Relation Records</a></li><li><a href="#SP2">&#167;2. Valency Adjectives</a></li><li><a href="#SP3">&#167;3. One To One Relations</a></li><li><a href="#SP4">&#167;4. Symmetric One To One Relations</a></li><li><a href="#SP5">&#167;5. Various To Various Relations</a></li><li><a href="#SP6">&#167;6. Equivalence Relations</a></li><li><a href="#SP7">&#167;7. Show Various to Various</a></li><li><a href="#SP8">&#167;8. Show One to One</a></li><li><a href="#SP9">&#167;9. Show Reversed One to One</a></li><li><a href="#SP10">&#167;10. Show Equivalence</a></li><li><a href="#SP11">&#167;11. Relation Emptying</a></li><li><a href="#SP12">&#167;12. Relation Route-Finding</a></li><li><a href="#SP13">&#167;13. One To Various Route-Finding</a></li><li><a href="#SP14">&#167;14. Various To One Route-Finding</a></li><li><a href="#SP15">&#167;15. Slow Various To Various Route-Finding</a></li><li><a href="#SP16">&#167;16. Fast Various To Various Route-Finding</a></li><li><a href="#SP17">&#167;17. Iterating Relations</a></li></ul><hr class="tocbar">

<p class="inwebparagraph"><a id="SP1"></a><b>&#167;1. Relation Records. </b>See "RelationKind.i6t" for further explanation.
</p>


<pre class="display">
    <span class="plain">Constant RR_NAME     		5;</span>
    <span class="plain">Constant RR_PERMISSIONS		6;</span>
    <span class="plain">Constant RR_STORAGE			7;</span>
    <span class="plain">Constant RR_KIND			8;</span>
    <span class="plain">Constant RR_HANDLER			9;</span>
    <span class="plain">Constant RR_DESCRIPTION		10;</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP2"></a><b>&#167;2. Valency Adjectives. </b>These are defined in the Standard Rules; the following routines must either
test the state (if <code class="display"><span class="extract">set</span></code> is negative), or change the state to <code class="display"><span class="extract">set</span></code>.
</p>


<pre class="display">
    <span class="plain">Constant VALENCY_MASK = RELS_EQUIVALENCE+RELS_SYMMETRIC+RELS_X_UNIQUE+RELS_Y_UNIQUE;</span>
    <span class="plain">[ RELATION_TY_EquivalenceAdjective rel set  perms state handler;</span>
        <span class="plain">perms = RlnGetF(rel, RR_PERMISSIONS);</span>
        <span class="plain">if (perms &amp; RELS_EQUIVALENCE) state = true;</span>
        <span class="plain">if (set &lt; 0) return state;</span>
        <span class="plain">if ((set) &amp;&amp; (state == false)) {</span>
            <span class="plain">perms = perms + RELS_EQUIVALENCE;</span>
            <span class="plain">if (perms &amp; RELS_SYMMETRIC == 0) perms = perms + RELS_SYMMETRIC;</span>
        <span class="plain">}</span>
        <span class="plain">if ((set == false) &amp;&amp; (state)) {</span>
            <span class="plain">perms = perms - RELS_EQUIVALENCE;</span>
            <span class="plain">if (perms &amp; RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;</span>
        <span class="plain">}</span>
        <span class="plain">RlnSetF(rel, RR_PERMISSIONS, perms);</span>
        <span class="plain">handler = RlnGetF(rel, RR_HANDLER);</span>
        <span class="plain">if (handler(rel, RELS_SET_VALENCY, perms &amp; VALENCY_MASK) == 0)</span>
            <span class="plain">"*** Can't change this to an equivalence relation ***";</span>
    <span class="plain">];</span>

    <span class="plain">[ RELATION_TY_SymmetricAdjective rel set  perms state handler;</span>
        <span class="plain">perms = RlnGetF(rel, RR_PERMISSIONS);</span>
        <span class="plain">if (perms &amp; RELS_SYMMETRIC) state = true;</span>
        <span class="plain">if (set &lt; 0) return state;</span>
        <span class="plain">if ((set) &amp;&amp; (state == false)) perms = perms + RELS_SYMMETRIC;</span>
        <span class="plain">if ((set == false) &amp;&amp; (state)) perms = perms - RELS_SYMMETRIC;</span>
        <span class="plain">RlnSetF(rel, RR_PERMISSIONS, perms);</span>
        <span class="plain">handler = RlnGetF(rel, RR_HANDLER);</span>
        <span class="plain">if (handler(rel, RELS_SET_VALENCY, perms &amp; VALENCY_MASK) == 0)</span>
            <span class="plain">"*** Can't change this to a symmetric relation ***";</span>
    <span class="plain">];</span>

    <span class="plain">[ RELATION_TY_OToOAdjective rel set  perms state handler i;</span>
        <span class="plain">perms = RlnGetF(rel, RR_PERMISSIONS);</span>
        <span class="plain">if (perms &amp; (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE+RELS_Y_UNIQUE) state = true;</span>
        <span class="plain">if (set &lt; 0) return state;</span>
        <span class="plain">if ((set) &amp;&amp; (state == false)) {</span>
            <span class="plain">if (perms &amp; RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;</span>
            <span class="plain">if (perms &amp; RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;</span>
            <span class="plain">if (perms &amp; RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;</span>
        <span class="plain">}</span>
        <span class="plain">if ((set == false) &amp;&amp; (state)) {</span>
            <span class="plain">if (perms &amp; RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;</span>
            <span class="plain">if (perms &amp; RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;</span>
        <span class="plain">}</span>
        <span class="plain">RlnSetF(rel, RR_PERMISSIONS, perms);</span>
        <span class="plain">handler = RlnGetF(rel, RR_HANDLER);</span>
        <span class="plain">if (handler(rel, RELS_SET_VALENCY, perms &amp; VALENCY_MASK) == 0)</span>
            <span class="plain">"*** Can't change this to a one-to-one relation ***";</span>
    <span class="plain">];</span>

    <span class="plain">[ RELATION_TY_OToVAdjective rel set  perms state handler;</span>
        <span class="plain">perms = RlnGetF(rel, RR_PERMISSIONS);</span>
        <span class="plain">if (perms &amp; (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_X_UNIQUE) state = true;</span>
        <span class="plain">if (set &lt; 0) return state;</span>
        <span class="plain">if ((set) &amp;&amp; (state == false)) {</span>
            <span class="plain">if (perms &amp; RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;</span>
            <span class="plain">if (perms &amp; RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;</span>
            <span class="plain">if (perms &amp; RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;</span>
            <span class="plain">if (perms &amp; RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;</span>
        <span class="plain">}</span>
        <span class="plain">if ((set == false) &amp;&amp; (state)) {</span>
            <span class="plain">if (perms &amp; RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;</span>
            <span class="plain">if (perms &amp; RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;</span>
        <span class="plain">}</span>
        <span class="plain">RlnSetF(rel, RR_PERMISSIONS, perms);</span>
        <span class="plain">handler = RlnGetF(rel, RR_HANDLER);</span>
        <span class="plain">if (handler(rel, RELS_SET_VALENCY, perms &amp; VALENCY_MASK) == 0)</span>
            <span class="plain">"*** Can't change this to a one-to-various relation ***";</span>
    <span class="plain">];</span>

    <span class="plain">[ RELATION_TY_VToOAdjective rel set  perms state handler;</span>
        <span class="plain">perms = RlnGetF(rel, RR_PERMISSIONS);</span>
        <span class="plain">if (perms &amp; (RELS_X_UNIQUE+RELS_Y_UNIQUE) == RELS_Y_UNIQUE) state = true;</span>
        <span class="plain">if (set &lt; 0) return state;</span>
        <span class="plain">if ((set) &amp;&amp; (state == false)) {</span>
            <span class="plain">if (perms &amp; RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;</span>
            <span class="plain">if (perms &amp; RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;</span>
            <span class="plain">if (perms &amp; RELS_SYMMETRIC) perms = perms - RELS_SYMMETRIC;</span>
            <span class="plain">if (perms &amp; RELS_EQUIVALENCE) perms = perms - RELS_EQUIVALENCE;</span>
        <span class="plain">}</span>
        <span class="plain">if ((set == false) &amp;&amp; (state)) {</span>
            <span class="plain">if (perms &amp; RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;</span>
            <span class="plain">if (perms &amp; RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;</span>
        <span class="plain">}</span>
        <span class="plain">RlnSetF(rel, RR_PERMISSIONS, perms);</span>
        <span class="plain">handler = RlnGetF(rel, RR_HANDLER);</span>
        <span class="plain">if (handler(rel, RELS_SET_VALENCY, perms &amp; VALENCY_MASK) == 0)</span>
            <span class="plain">"*** Can't change this to a various-to-one relation ***";</span>
    <span class="plain">];</span>

    <span class="plain">[ RELATION_TY_VToVAdjective rel set  perms state handler;</span>
        <span class="plain">perms = RlnGetF(rel, RR_PERMISSIONS);</span>
        <span class="plain">if (perms &amp; (RELS_X_UNIQUE+RELS_Y_UNIQUE) == 0) state = true;</span>
        <span class="plain">if (set &lt; 0) return state;</span>
        <span class="plain">if ((set) &amp;&amp; (state == false)) {</span>
            <span class="plain">if (perms &amp; RELS_X_UNIQUE) perms = perms - RELS_X_UNIQUE;</span>
            <span class="plain">if (perms &amp; RELS_Y_UNIQUE) perms = perms - RELS_Y_UNIQUE;</span>
        <span class="plain">}</span>
        <span class="plain">if ((set == false) &amp;&amp; (state)) {</span>
            <span class="plain">if (perms &amp; RELS_X_UNIQUE == 0) perms = perms + RELS_X_UNIQUE;</span>
            <span class="plain">if (perms &amp; RELS_Y_UNIQUE == 0) perms = perms + RELS_Y_UNIQUE;</span>
        <span class="plain">}</span>
        <span class="plain">RlnSetF(rel, RR_PERMISSIONS, perms);</span>
        <span class="plain">handler = RlnGetF(rel, RR_HANDLER);</span>
        <span class="plain">if (handler(rel, RELS_SET_VALENCY, perms &amp; VALENCY_MASK) == 0)</span>
            <span class="plain">"*** Can't change this to a various-to-various relation ***";</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP3"></a><b>&#167;3. One To One Relations. </b>We provide routines to assert a 1-to-1 relation true, or to assert it false.
The relation <code class="display"><span class="extract">rel</span></code> is represented by a property number, and the property in
question is used to store the fact of a relationship: O_1~ O_2 if and
only if <code class="display"><span class="extract">O1.rel == O2</span></code>.
</p>

<p class="inwebparagraph">There is no routine to test a 1-to-1 relation, since the predicate calculus
code in NI simplifies propositions which test these into direct looking up
of the property relation.
</p>


<pre class="display">
    <span class="plain">[ Relation_Now1to1 obj1 relation_property obj2 ol; ! Assert 1-1 true</span>
        <span class="plain">if (obj2) objectloop (ol provides relation_property)</span>
            <span class="plain">if (ol.relation_property == obj2) ol.relation_property = nothing;</span>
        <span class="plain">if (obj1) obj1.relation_property = obj2;</span>
    <span class="plain">];</span>

    <span class="plain">[ Relation_NowN1toV obj1 relation_property obj2; ! Assert 1-1 false</span>
        <span class="plain">if ((obj1) &amp;&amp; (obj1.relation_property == obj2)) obj1.relation_property = nothing;</span>
    <span class="plain">];</span>

    <span class="plain">[ Relation_Now1to1V obj1 obj2 KOV relation_property ol N; ! Assert 1-1 true</span>
        <span class="plain">if (obj2) {</span>
            <span class="plain">N = KOVDomainSize(KOV);</span>
            <span class="plain">for (ol=1: ol&lt;=N: ol++)</span>
                <span class="plain">if (GProperty(KOV, ol, relation_property) == obj2)</span>
                    <span class="plain">WriteGProperty(KOV, ol, relation_property, 0);</span>
        <span class="plain">}</span>
        <span class="plain">if (obj1) WriteGProperty(KOV, obj1, relation_property, obj2);</span>
    <span class="plain">];</span>

    <span class="plain">[ Relation_NowN1toVV obj1 obj2 KOV relation_property; ! Assert 1-1 false</span>
        <span class="plain">if ((obj1) &amp;&amp; (GProperty(KOV, obj1, relation_property) == obj2))</span>
            <span class="plain">WriteGProperty(KOV, obj1, relation_property, 0);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP4"></a><b>&#167;4. Symmetric One To One Relations. </b>Here the relation is used for both objects: O_1~ O_2 if and only if
both <code class="display"><span class="extract">O1.relation_property == O2</span></code> and <code class="display"><span class="extract">O2.relation_property == O1</span></code>.
</p>


<pre class="display">
    <span class="plain">[ Relation_NowS1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 true</span>
        <span class="plain">if ((obj1 ofclass Object) &amp;&amp; (obj1 provides relation_property) &amp;&amp;</span>
            <span class="plain">(obj2 ofclass Object) &amp;&amp; (obj2 provides relation_property)) {</span>
            <span class="plain">if (obj1.relation_property) { (obj1.relation_property).relation_property = 0; }</span>
            <span class="plain">if (obj2.relation_property) { (obj2.relation_property).relation_property = 0; }</span>
            <span class="plain">obj1.relation_property = obj2; obj2.relation_property = obj1;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ Relation_NowSN1to1 obj1 relation_property obj2; ! Assert symmetric 1-1 false</span>
        <span class="plain">if ((obj1 ofclass Object) &amp;&amp; (obj1 provides relation_property) &amp;&amp;</span>
            <span class="plain">(obj2 ofclass Object) &amp;&amp; (obj2 provides relation_property) &amp;&amp;</span>
            <span class="plain">(obj1.relation_property == obj2)) {</span>
            <span class="plain">obj1.relation_property = 0; obj2.relation_property = 0;</span>
        <span class="plain">}</span>
    <span class="plain">];</span>

    <span class="plain">[ Relation_NowS1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 true</span>
        <span class="plain">if (GProperty(KOV, obj1, relation_property))</span>
            <span class="plain">WriteGProperty(KOV, GProperty(KOV, obj1, relation_property), relation_property, 0);</span>
        <span class="plain">if (GProperty(KOV, obj2, relation_property))</span>
            <span class="plain">WriteGProperty(KOV, GProperty(KOV, obj2, relation_property), relation_property, 0);</span>
        <span class="plain">WriteGProperty(KOV, obj1, relation_property, obj2);</span>
        <span class="plain">WriteGProperty(KOV, obj2, relation_property, obj1);</span>
    <span class="plain">];</span>

    <span class="plain">[ Relation_NowSN1to1V obj1 obj2 KOV relation_property; ! Assert symmetric 1-1 false</span>
        <span class="plain">if (GProperty(KOV, obj1, relation_property) == obj2) {</span>
            <span class="plain">WriteGProperty(KOV, obj1, relation_property, 0);</span>
            <span class="plain">WriteGProperty(KOV, obj2, relation_property, 0);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP5"></a><b>&#167;5. Various To Various Relations. </b>Here the relation is represented by an array holding its metadata. Each
object in the domain of the relation provides two properties, holding its
left index and its right index. The index is its position in the left or
right domain. For instance, suppose we relate things to doors, and there
are five things in the world, two of which are doors; then the left
indexes will range from 0 to 4, while the right indexes will range from
0 to 1. It's very likely that the doors will have different left and
right indexes. (If the relation relates a given kind to itself, say
doors to doors, then left and right indexes will always be equal.)
</p>

<p class="inwebparagraph">It is possible for either the left or right domain set to be an enumerated
kind of value, where the I6 representation of values is 1, 2, 3, ..., N,
where there are N possibilities. In that case we obtain the index
simply by subtracting 1 in order to begin from 0. We mark the domain set
as being a KOV rather than a kind of object by storing 0 instead of a
property in the relevant part of the relation metadata: note that 0 is
not a valid property number.
</p>

<p class="inwebparagraph">The structure for a relation consists of eight <code class="display"><span class="extract">--&gt;</span></code> words, followed by a
bitmap in which we store 16 bits in each <code class="display"><span class="extract">--&gt;</span></code> word. (Yes, this is wasteful
in Glulx, where <code class="display"><span class="extract">--&gt;</span></code> words store 32 bits, but memory is not in short supply
in Glulx and the total cost of relations is in practice small; we prefer
to keep all the code involved simple.) The structure is precompiled by the
Inform compiler: we do not create new ones on the fly.
</p>

<p class="inwebparagraph">In the case of a symmetric various to various relation, we could in theory
save memory once again by storing only the lower triangle of the bitmap,
but the time and complexity overhead are not worth it. When asserting that
O_1~ O_2 for a symmetric V-to-V, we also automatically assert that
O_2~ O_1, thus maintaining the bitmap as a symmetric matrix; but in
reading the bitmap, we look only at the lower triangle. This costs a little
time, but has the advantage of allowing the route-finding routine for
V-to-V to use the same code for symmetric and asymmetric relations.
</p>

<p class="inwebparagraph">If this all seems rather suboptimally programmed in order to reduce code
complexity, I can only say that careless drafts here were the source of
some extremely difficult bugs to find.
</p>


<pre class="display">
    <span class="plain">Constant VTOVS_LEFT_INDEX_PROP = 0;</span>
    <span class="plain">Constant VTOVS_RIGHT_INDEX_PROP = 1;</span>
    <span class="plain">Constant VTOVS_LEFT_DOMAIN_SIZE = 2;</span>
    <span class="plain">Constant VTOVS_RIGHT_DOMAIN_SIZE = 3;</span>
    <span class="plain">Constant VTOVS_LEFT_PRINTING_ROUTINE = 4;</span>
    <span class="plain">Constant VTOVS_RIGHT_PRINTING_ROUTINE = 5;</span>
    <span class="plain">Constant VTOVS_CACHE_BROKEN = 6;</span>
    <span class="plain">Constant VTOVS_CACHE = 7;</span>

    <span class="plain">[ Relation_NowVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;</span>
        <span class="plain">if (sym &amp;&amp; (obj2 ~= obj1)) { Relation_NowVtoV(obj2, relation, obj1, false); }</span>
        <span class="plain">vtov_structure = RlnGetF(relation, RR_STORAGE);</span>
        <span class="plain">pr = vtov_structure--&gt;VTOVS_LEFT_INDEX_PROP;</span>
        <span class="plain">pr2 = vtov_structure--&gt;VTOVS_RIGHT_INDEX_PROP;</span>
        <span class="plain">vtov_structure--&gt;VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken</span>
        <span class="plain">if (pr) {</span>
            <span class="plain">if ((obj1 ofclass Object) &amp;&amp; (obj1 provides pr)) i1 = obj1.pr;</span>
            <span class="plain">else return RunTimeProblem(RTP_IMPREL, obj1, relation);</span>
        <span class="plain">} else i1 = obj1-1;</span>
        <span class="plain">if (pr2) {</span>
            <span class="plain">if ((obj2 ofclass Object) &amp;&amp; (obj2 provides pr2)) i2 = obj2.pr2;</span>
            <span class="plain">else return RunTimeProblem(RTP_IMPREL, obj2, relation);</span>
        <span class="plain">} else i2 = obj2-1;</span>
        <span class="plain">pr = i1*(vtov_structure--&gt;VTOVS_RIGHT_DOMAIN_SIZE) + i2;</span>
        <span class="plain">i1 = IncreasingPowersOfTwo_TB--&gt;(pr%16);</span>
        <span class="plain">pr = pr/16 + 8;</span>
        <span class="plain">vtov_structure--&gt;pr = (vtov_structure--&gt;pr) | i1;</span>
    <span class="plain">];</span>

    <span class="plain">[ Relation_NowNVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;</span>
        <span class="plain">if (sym &amp;&amp; (obj2 ~= obj1)) { Relation_NowNVtoV(obj2, relation, obj1, false); }</span>
        <span class="plain">vtov_structure = RlnGetF(relation, RR_STORAGE);</span>
        <span class="plain">pr = vtov_structure--&gt;VTOVS_LEFT_INDEX_PROP;</span>
        <span class="plain">pr2 = vtov_structure--&gt;VTOVS_RIGHT_INDEX_PROP;</span>
        <span class="plain">vtov_structure--&gt;VTOVS_CACHE_BROKEN = true; ! Mark any cache as broken</span>
        <span class="plain">if (pr) {</span>
            <span class="plain">if ((obj1 ofclass Object) &amp;&amp; (obj1 provides pr)) i1 = obj1.pr;</span>
            <span class="plain">else return RunTimeProblem(RTP_IMPREL, obj1, relation);</span>
        <span class="plain">} else i1 = obj1-1;</span>
        <span class="plain">if (pr2) {</span>
            <span class="plain">if ((obj2 ofclass Object) &amp;&amp; (obj2 provides pr2)) i2 = obj2.pr2;</span>
            <span class="plain">else return RunTimeProblem(RTP_IMPREL, obj2, relation);</span>
        <span class="plain">} else i2 = obj2-1;</span>
        <span class="plain">pr = i1*(vtov_structure--&gt;VTOVS_RIGHT_DOMAIN_SIZE) + i2;</span>
        <span class="plain">i1 = IncreasingPowersOfTwo_TB--&gt;(pr%16);</span>
        <span class="plain">pr = pr/16 + 8;</span>
        <span class="plain">if ((vtov_structure--&gt;pr) &amp; i1) vtov_structure--&gt;pr = vtov_structure--&gt;pr - i1;</span>
    <span class="plain">];</span>

    <span class="plain">[ Relation_TestVtoV obj1 relation obj2 sym pr pr2 i1 i2 vtov_structure;</span>
        <span class="plain">vtov_structure = RlnGetF(relation, RR_STORAGE);</span>
        <span class="plain">pr = vtov_structure--&gt;VTOVS_LEFT_INDEX_PROP;</span>
        <span class="plain">pr2 = vtov_structure--&gt;VTOVS_RIGHT_INDEX_PROP;</span>
        <span class="plain">if (sym &amp;&amp; (obj2 &gt; obj1)) { sym = obj1; obj1 = obj2; obj2 = sym; }</span>
        <span class="plain">if (pr) {</span>
            <span class="plain">if ((obj1 ofclass Object) &amp;&amp; (obj1 provides pr)) i1 = obj1.pr;</span>
            <span class="plain">else { RunTimeProblem(RTP_IMPREL, obj1, relation); rfalse; }</span>
        <span class="plain">} else i1 = obj1-1;</span>
        <span class="plain">if (pr2) {</span>
            <span class="plain">if ((obj2 ofclass Object) &amp;&amp; (obj2 provides pr2)) i2 = obj2.pr2;</span>
            <span class="plain">else { RunTimeProblem(RTP_IMPREL, obj2, relation); rfalse; }</span>
        <span class="plain">} else i2 = obj2-1;</span>
        <span class="plain">pr = i1*(vtov_structure--&gt;VTOVS_RIGHT_DOMAIN_SIZE) + i2;</span>
        <span class="plain">i1 = IncreasingPowersOfTwo_TB--&gt;(pr%16);</span>
        <span class="plain">pr = pr/16 + 8;</span>
        <span class="plain">if ((vtov_structure--&gt;pr) &amp; i1) rtrue; rfalse;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP6"></a><b>&#167;6. Equivalence Relations. </b>For every equivalence relation there is a corresponding function f such
that x~ y if and only if f(x)=f(y), where f(x) is a number identifying
the equivalence class of x. Rather than inefficiently storing a large
relation bitmap (and then having a very complicated time updating it to
keep the relation transitive), we store f: that is, for every object in
the domain set, there is a property <code class="display"><span class="extract">prop</span></code> such that <code class="display"><span class="extract">O.prop</span></code> is the value
f(O).
</p>


<pre class="display">
    <span class="plain">[ Relation_NowEquiv obj1 relation_property obj2 big little;</span>
        <span class="plain">big = obj1.relation_property; little = obj2.relation_property;</span>
        <span class="plain">if (big == little) return;</span>
        <span class="plain">if (big &lt; little) { little = obj1.relation_property; big = obj2.relation_property; }</span>
        <span class="plain">objectloop (obj1 provides relation_property)</span>
            <span class="plain">if (obj1.relation_property == big) obj1.relation_property = little;</span>
    <span class="plain">];</span>

    <span class="plain">[ Relation_NowNEquiv obj1 relation_property obj2 old new;</span>
        <span class="plain">old = obj1.relation_property; new = obj2.relation_property;</span>
        <span class="plain">if (old ~= new) return;</span>
        <span class="plain">new = 0;</span>
        <span class="plain">objectloop (obj2 provides relation_property)</span>
            <span class="plain">if (obj2.relation_property &gt; new) new = obj2.relation_property;</span>
        <span class="plain">new++;</span>
        <span class="plain">obj1.relation_property = new;</span>
    <span class="plain">];</span>

    <span class="plain">[ Relation_NowEquivV obj1 obj2 KOV relation_property n big little i;</span>
        <span class="plain">big = GProperty(KOV, obj1, relation_property);</span>
        <span class="plain">little = GProperty(KOV, obj2, relation_property);</span>
        <span class="plain">if (big == little) return;</span>
        <span class="plain">if (big &lt; little) {</span>
            <span class="plain">little = GProperty(KOV, obj1, relation_property);</span>
            <span class="plain">big = GProperty(KOV, obj2, relation_property);</span>
        <span class="plain">}</span>
        <span class="plain">n = KOVDomainSize(KOV);</span>
        <span class="plain">for (i=1: i&lt;=n: i++)</span>
            <span class="plain">if (GProperty(KOV, i, relation_property) == big)</span>
                <span class="plain">WriteGProperty(KOV, i, relation_property, little);</span>
    <span class="plain">];</span>

    <span class="plain">[ Relation_NowNEquivV obj1 obj2 KOV relation_property n old new i;</span>
        <span class="plain">old = GProperty(KOV, obj1, relation_property);</span>
        <span class="plain">new = GProperty(KOV, obj2, relation_property);</span>
        <span class="plain">if (old ~= new) return;</span>
        <span class="plain">new = 0;</span>
        <span class="plain">n = KOVDomainSize(KOV);</span>
        <span class="plain">for (i=1: i&lt;=n: i++)</span>
            <span class="plain">if (GProperty(KOV, i, relation_property) &gt; new)</span>
                <span class="plain">new = GProperty(KOV, i, relation_property);</span>
        <span class="plain">new++;</span>
        <span class="plain">WriteGProperty(KOV, obj1, relation_property, new);</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP7"></a><b>&#167;7. Show Various to Various. </b>The rest of the code for relations has no use except for debugging: it
implements the RELATIONS testing command. Speed is unimportant here.
</p>


<pre class="display">
    <span class="plain">[ Relation_ShowVtoV relation sym x obj1 obj2 pr pr2 proutine1 proutine2 vtov_structure;</span>
        <span class="plain">vtov_structure = RlnGetF(relation, RR_STORAGE);</span>
        <span class="plain">pr = vtov_structure--&gt;VTOVS_LEFT_INDEX_PROP;</span>
        <span class="plain">pr2 = vtov_structure--&gt;VTOVS_RIGHT_INDEX_PROP;</span>
        <span class="plain">proutine1 = vtov_structure--&gt;VTOVS_LEFT_PRINTING_ROUTINE;</span>
        <span class="plain">proutine2 = vtov_structure--&gt;VTOVS_RIGHT_PRINTING_ROUTINE;</span>

        <span class="plain">if (pr &amp;&amp; pr2) {</span>
            <span class="plain">objectloop (obj1 provides pr)</span>
            <span class="plain">objectloop (obj2 provides pr2) {</span>
                    <span class="plain">if (sym &amp;&amp; obj2 &gt; obj1) continue;</span>
                    <span class="plain">if (Relation_TestVtoV(obj1, relation, obj2)) {</span>
                        <span class="plain">if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }</span>
                        <span class="plain">print "  ", (The) obj1;</span>
                        <span class="plain">if (sym) print "  &lt;=&gt;  "; else print "  &gt;=&gt;  ";</span>
                        <span class="plain">print (the) obj2, "^";</span>
                    <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">if (pr &amp;&amp; (pr2==0)) {</span>
            <span class="plain">objectloop (obj1 provides pr)</span>
            <span class="plain">for (obj2=1:obj2&lt;=vtov_structure--&gt;VTOVS_RIGHT_DOMAIN_SIZE:obj2++) {</span>
                    <span class="plain">if (Relation_TestVtoV(obj1, relation, obj2)) {</span>
                        <span class="plain">if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }</span>
                        <span class="plain">print "  ", (The) obj1, "  &gt;=&gt;  ";</span>
                        <span class="plain">proutine2.call(obj2);</span>
                        <span class="plain">print "^";</span>
                    <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">if ((pr==0) &amp;&amp; (pr2)) {</span>
            <span class="plain">for (obj1=1:obj1&lt;=vtov_structure--&gt;2:obj1++)</span>
            <span class="plain">objectloop (obj2 provides pr2) {</span>
                    <span class="plain">if (Relation_TestVtoV(obj1, relation, obj2)) {</span>
                        <span class="plain">if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }</span>
                        <span class="plain">print "  ";</span>
                        <span class="plain">proutine1.call(obj1);</span>
                        <span class="plain">print "  &gt;=&gt;  ", (the) obj2, "^";</span>
                    <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">for (obj1=1:obj1&lt;=vtov_structure--&gt;2:obj1++)</span>
            <span class="plain">for (obj2=1:obj2&lt;=vtov_structure--&gt;VTOVS_RIGHT_DOMAIN_SIZE:obj2++)</span>
                <span class="plain">if (Relation_TestVtoV(obj1, relation, obj2)) {</span>
                    <span class="plain">if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }</span>
                    <span class="plain">print "  ";</span>
                    <span class="plain">proutine1.call(obj1);</span>
                    <span class="plain">print "  &gt;=&gt;  ";</span>
                    <span class="plain">proutine2.call(obj2);</span>
                    <span class="plain">print "^";</span>
            <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP8"></a><b>&#167;8. Show One to One. </b></p>


<pre class="display">
    <span class="plain">[ Relation_ShowOtoO relation sym x relation_property t N obj1 obj2;</span>
        <span class="plain">relation_property = RlnGetF(relation, RR_STORAGE);</span>
        <span class="plain">t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term</span>
        <span class="plain">N = KOVDomainSize(t);</span>
        <span class="plain">if (t == OBJECT_TY) {</span>
            <span class="plain">objectloop (obj1 provides relation_property) {</span>
                <span class="plain">obj2 = obj1.relation_property;</span>
                <span class="plain">if (sym &amp;&amp; obj2 &lt; obj1) continue;</span>
                <span class="plain">if (obj2 == 0) continue;</span>
                <span class="plain">if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }</span>
                <span class="plain">print "  ", (The) obj1;</span>
                <span class="plain">if (sym) print "  ==  "; else print "  &gt;=&gt;  ";</span>
                <span class="plain">print (the) obj2, "^";</span>
            <span class="plain">}</span>
        <span class="plain">} else {</span>
            <span class="plain">for (obj1=1: obj1&lt;=N: obj1++) {</span>
                <span class="plain">obj2 = GProperty(t, obj1, relation_property);</span>
                <span class="plain">if (sym &amp;&amp; obj2 &lt; obj1) continue;</span>
                <span class="plain">if (obj2 == 0) continue;</span>
                <span class="plain">if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }</span>
                <span class="plain">print "  ";</span>
                <span class="plain">PrintKindValuePair(t, obj1);</span>
                <span class="plain">if (sym) print "  ==  "; else print "  &gt;=&gt;  ";</span>
                <span class="plain">PrintKindValuePair(t, obj2);</span>
                <span class="plain">print "^";</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP9"></a><b>&#167;9. Show Reversed One to One. </b>There's no such kind of relation as this: but the same code used to show
1-to-1 relations is also used to show various-to-1 relations, since the
storage is the same. To show 1-to-various relations, we need a transposed
form of the same code in which left and right are exchanged: this is it.
</p>


<pre class="display">
    <span class="plain">[ Relation_RShowOtoO relation sym x relation_property obj1 obj2 t1 t2 N1 N2;</span>
        <span class="plain">relation_property = RlnGetF(relation, RR_STORAGE);</span>
        <span class="plain">t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term</span>
        <span class="plain">t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1); ! Kind of right term</span>
        <span class="plain">if (t2 == OBJECT_TY) {</span>
            <span class="plain">if (t1 == OBJECT_TY) {</span>
                <span class="plain">objectloop (obj1) {</span>
                    <span class="plain">objectloop (obj2 provides relation_property) {</span>
                        <span class="plain">if (obj2.relation_property ~= obj1) continue;</span>
                        <span class="plain">if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }</span>
                        <span class="plain">print "  ", (The) obj1;</span>
                        <span class="plain">print "  &gt;=&gt;  ";</span>
                        <span class="plain">print (the) obj2, "^";</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">} else {</span>
                <span class="plain">N1 = KOVDomainSize(t1);</span>
                <span class="plain">for (obj1=1: obj1&lt;=N1: obj1++) {</span>
                    <span class="plain">objectloop (obj2 provides relation_property) {</span>
                        <span class="plain">if (obj2.relation_property ~= obj1) continue;</span>
                        <span class="plain">if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }</span>
                        <span class="plain">print "  "; PrintKindValuePair(t1, obj1);</span>
                        <span class="plain">print "  &gt;=&gt;  ";</span>
                        <span class="plain">print (the) obj2, "^";</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">} else {</span>
            <span class="plain">N2 = KOVDomainSize(t2);</span>
            <span class="plain">if (t1 == OBJECT_TY) {</span>
                <span class="plain">objectloop (obj1) {</span>
                    <span class="plain">for (obj2=1: obj2&lt;=N2: obj2++) {</span>
                        <span class="plain">if (GProperty(t2, obj2, relation_property) ~= obj1) continue;</span>
                        <span class="plain">if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }</span>
                        <span class="plain">print "  ", (The) obj1;</span>
                        <span class="plain">print "  &gt;=&gt;  ";</span>
                        <span class="plain">PrintKindValuePair(t2, obj2);</span>
                        <span class="plain">print "^";</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">} else {</span>
                <span class="plain">N1 = KOVDomainSize(t1);</span>
                <span class="plain">for (obj1=1: obj1&lt;=N1: obj1++) {</span>
                    <span class="plain">for (obj2=1: obj2&lt;=N2: obj2++) {</span>
                        <span class="plain">if (GProperty(t2, obj2, relation_property) ~= obj1) continue;</span>
                        <span class="plain">if (x == 0) { print (string) RlnGetF(relation, RR_DESCRIPTION), ":^"; x=1; }</span>
                        <span class="plain">print "  ";</span>
                        <span class="plain">PrintKindValuePair(t1, obj1);</span>
                        <span class="plain">print "  &gt;=&gt;  ";</span>
                        <span class="plain">PrintKindValuePair(t2, obj2);</span>
                        <span class="plain">print "^";</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP10"></a><b>&#167;10. Show Equivalence. </b></p>


<pre class="display">
    <span class="plain">[ RSE_Flip KOV v relation_property x;</span>
        <span class="plain">x = GProperty(KOV, v, relation_property); x = -x;</span>
        <span class="plain">WriteGProperty(KOV, v, relation_property, x);</span>
    <span class="plain">];</span>
    <span class="plain">[ RSE_Set KOV v relation_property;</span>
        <span class="plain">if (GProperty(KOV, v, relation_property) &lt; 0) rtrue; rfalse;</span>
    <span class="plain">];</span>
    <span class="plain">[ Relation_ShowEquiv relation relation_property obj1 obj2 v c d somegroups t N x;</span>
        <span class="plain">print (string) RlnGetF(relation, RR_DESCRIPTION), ":^";</span>
        <span class="plain">relation_property = RlnGetF(relation, RR_STORAGE);</span>
        <span class="plain">t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term</span>
        <span class="plain">N = KOVDomainSize(t);</span>
        <span class="plain">if (t == OBJECT_TY) {</span>
            <span class="plain">objectloop (obj1 provides relation_property)</span>
                <span class="plain">obj1.relation_property = -(obj1.relation_property);</span>
            <span class="plain">objectloop (obj1 provides relation_property) {</span>
                <span class="plain">if (obj1.relation_property &lt; 0) {</span>
                    <span class="plain">v = obj1.relation_property; c = 0;</span>
                    <span class="plain">objectloop (obj2 has workflag2) give obj2 ~workflag2;</span>
                    <span class="plain">objectloop (obj2 provides relation_property) {</span>
                        <span class="plain">if (obj2.relation_property == v) {</span>
                            <span class="plain">give obj2 workflag2;</span>
                            <span class="plain">obj2.relation_property = -v;</span>
                            <span class="plain">c++;</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                    <span class="plain">if (c&gt;1) {</span>
                        <span class="plain">somegroups = true;</span>
                        <span class="plain">print "  { ";</span>
                        <span class="plain">WriteListOfMarkedObjects(ENGLISH_BIT);</span>
                        <span class="plain">print " }^";</span>
                    <span class="plain">} else obj1.relation_property = v;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">objectloop (obj2 has workflag2) give obj2 ~workflag2;</span>
            <span class="plain">c = 0; objectloop (obj1 provides relation_property)</span>
                <span class="plain">if (obj1.relation_property &lt; 0) { c++; give obj1 workflag2; }</span>
            <span class="plain">if (c == 0) return;</span>
            <span class="plain">if (somegroups) print "  and "; else print "  ";</span>
            <span class="plain">if (c &lt; 4) { WriteListOfMarkedObjects(ENGLISH_BIT); print " in"; }</span>
            <span class="plain">else print c;</span>
            <span class="plain">if (c == 1) print " a";</span>
            <span class="plain">print " single-member group";</span>
            <span class="plain">if (c &gt; 1) print "s";</span>
            <span class="plain">print "^";</span>
            <span class="plain">objectloop (obj1 provides relation_property)</span>
                <span class="plain">if (obj1.relation_property &lt; 0)</span>
                    <span class="plain">obj1.relation_property = -(obj1.relation_property);</span>
        <span class="plain">} else {</span>
            <span class="plain">! A slower method, since we have less efficient storage:</span>
            <span class="plain">for (obj1 = 1: obj1 &lt;= N: obj1++)</span>
                <span class="plain">RSE_Flip(t, obj1, relation_property);</span>
            <span class="plain">for (obj1 = 1: obj1 &lt;= N: obj1++) {</span>
                <span class="plain">if (RSE_Set(t, obj1, relation_property)) {</span>
                    <span class="plain">v = GProperty(t, obj1, relation_property);</span>
                    <span class="plain">c = 0;</span>
                    <span class="plain">for (obj2 = 1: obj2 &lt;= N: obj2++)</span>
                        <span class="plain">if (GProperty(t, obj2, relation_property) == v)</span>
                            <span class="plain">c++;</span>
                    <span class="plain">if (c&gt;1) {</span>
                        <span class="plain">somegroups = true;</span>
                        <span class="plain">print "  {";</span>
                        <span class="plain">d = 0;</span>
                        <span class="plain">for (obj2 = 1: obj2 &lt;= N: obj2++) {</span>
                            <span class="plain">if (GProperty(t, obj2, relation_property) == v) {</span>
                                <span class="plain">print " "; PrintKindValuePair(t, obj2);</span>
                                <span class="plain">if (d &lt; c-1) print ","; print " ";</span>
                                <span class="plain">RSE_Flip(t, obj2, relation_property);</span>
                                <span class="plain">d++;</span>
                            <span class="plain">}</span>
                        <span class="plain">}</span>
                        <span class="plain">print "}^";</span>
                    <span class="plain">} else WriteGProperty(t, obj1, relation_property, v);</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
            <span class="plain">objectloop (obj2 has workflag2) give obj2 ~workflag2;</span>
            <span class="plain">c = 0;</span>
            <span class="plain">for (obj1 = 1: obj1 &lt;= N: obj1++)</span>
                <span class="plain">if (RSE_Set(t, obj1, relation_property)) c++;</span>
            <span class="plain">if (c == 0) return;</span>
            <span class="plain">if (somegroups) print "  and "; else print "  ";</span>
            <span class="plain">if (c == 1) print "a"; else print c;</span>
            <span class="plain">print " single-member group";</span>
            <span class="plain">if (c &gt; 1) print "s";</span>
            <span class="plain">print "^";</span>
            <span class="plain">for (obj1 = 1: obj1 &lt;= N: obj1++)</span>
                <span class="plain">if (RSE_Set(t, obj1, relation_property))</span>
                    <span class="plain">RSE_Flip(t, obj1, relation_property);</span>
        <span class="plain">}</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP11"></a><b>&#167;11. Relation Emptying. </b>These routines, mercifully a little simpler, define the adjective "empty" as
it applied to relations. Each routine has to forcibly empty the relation if
the clear flag is set, and in any case return either true or false to say
whether the relation is empty at the end of the call. For relations in groups,
"empty" is understood to mean that each object relates only to itself.
</p>


<pre class="display">
    <span class="plain">[ Relation_EmptyOtoO relation sym clear relation_property obj1 obj2 t1 t2 N1 N2;</span>
        <span class="plain">relation_property = RlnGetF(relation, RR_STORAGE);</span>
        <span class="plain">t1 = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term</span>
        <span class="plain">t2 = KindBaseTerm(RlnGetF(relation, RR_KIND), 1); ! Kind of right term</span>
        <span class="plain">if (t2 == OBJECT_TY) {</span>
            <span class="plain">objectloop (obj2 provides relation_property) {</span>
                <span class="plain">obj1 = obj2.relation_property;</span>
                <span class="plain">if (obj1) {</span>
                    <span class="plain">if (clear) obj2.relation_property = nothing;</span>
                    <span class="plain">else rfalse;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">} else {</span>
            <span class="plain">for (obj2=1: obj2&lt;=N2: obj2++) {</span>
                <span class="plain">obj1 = GProperty(t2, obj2, relation_property);</span>
                <span class="plain">if (obj1) {</span>
                    <span class="plain">if (clear) WriteGProperty(t2, obj2, relation_property, 0);</span>
                    <span class="plain">else rfalse;</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">if (t1 ~= t2) {</span>
            <span class="plain">if (t1 == OBJECT_TY) {</span>
                <span class="plain">objectloop (obj1 provides relation_property) {</span>
                    <span class="plain">obj2 = obj1.relation_property;</span>
                    <span class="plain">if (obj2) {</span>
                        <span class="plain">if (clear) obj1.relation_property = nothing;</span>
                        <span class="plain">else rfalse;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">} else {</span>
                <span class="plain">for (obj1=1: obj1&lt;=N2: obj1++) {</span>
                    <span class="plain">obj2 = GProperty(t1, obj1, relation_property);</span>
                    <span class="plain">if (obj2) {</span>
                        <span class="plain">if (clear) WriteGProperty(t1, obj1, relation_property, 0);</span>
                        <span class="plain">else rfalse;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
    <span class="plain">[ Relation_EmptyEquiv relation sym clear</span>
        <span class="plain">relation_property obj1 obj2 t N v;</span>
        <span class="plain">relation_property = RlnGetF(relation, RR_STORAGE);</span>
        <span class="plain">t = KindBaseTerm(RlnGetF(relation, RR_KIND), 0); ! Kind of left term</span>
        <span class="plain">N = KOVDomainSize(t);</span>
        <span class="plain">if (clear) {</span>
            <span class="plain">v = 1;</span>
            <span class="plain">if (t == OBJECT_TY) {</span>
                <span class="plain">objectloop (obj1 provides relation_property)</span>
                    <span class="plain">obj1.relation_property = v++;</span>
            <span class="plain">} else {</span>
                <span class="plain">for (obj1=1: obj1&lt;=N: obj1++)</span>
                    <span class="plain">WriteGProperty(t, obj1, relation_property, v++);</span>
            <span class="plain">}</span>
            <span class="plain">rtrue;</span>
        <span class="plain">}</span>
        <span class="plain">if (t == OBJECT_TY) {</span>
            <span class="plain">objectloop (obj1 provides relation_property)</span>
                <span class="plain">objectloop (obj2 provides relation_property)</span>
                    <span class="plain">if ((obj1 &lt; obj2) &amp;&amp; (obj1.relation_property == obj2.relation_property))</span>
                        <span class="plain">rfalse;</span>
        <span class="plain">} else {</span>
            <span class="plain">for (obj1=1: obj1&lt;=N: obj1++)</span>
                <span class="plain">for (obj2=obj1+1: obj1&lt;=N: obj1++)</span>
                    <span class="plain">if (GProperty(t, obj1, relation_property) == GProperty(t, obj2, relation_property))</span>
                        <span class="plain">rfalse;</span>
        <span class="plain">}</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
    <span class="plain">[ Relation_EmptyVtoV relation sym clear vtov_structure obj1 obj2 pr pr2 proutine1 proutine2;</span>
        <span class="plain">vtov_structure = RlnGetF(relation, RR_STORAGE);</span>
        <span class="plain">pr = vtov_structure--&gt;VTOVS_LEFT_INDEX_PROP;</span>
        <span class="plain">pr2 = vtov_structure--&gt;VTOVS_RIGHT_INDEX_PROP;</span>
        <span class="plain">proutine1 = vtov_structure--&gt;VTOVS_LEFT_PRINTING_ROUTINE;</span>
        <span class="plain">proutine2 = vtov_structure--&gt;VTOVS_RIGHT_PRINTING_ROUTINE;</span>

        <span class="plain">if (pr &amp;&amp; pr2) {</span>
            <span class="plain">objectloop (obj1 provides pr)</span>
                <span class="plain">objectloop (obj2 provides pr2) {</span>
                    <span class="plain">if (sym &amp;&amp; obj2 &gt; obj1) continue;</span>
                    <span class="plain">if (Relation_TestVtoV(obj1, relation, obj2)) {</span>
                        <span class="plain">if (clear) Relation_NowNVtoV(obj1, relation, obj2, sym);</span>
                        <span class="plain">else rfalse;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">if (pr &amp;&amp; (pr2==0)) {</span>
            <span class="plain">objectloop (obj1 provides pr)</span>
                <span class="plain">for (obj2=1:obj2&lt;=vtov_structure--&gt;VTOVS_RIGHT_DOMAIN_SIZE:obj2++) {</span>
                    <span class="plain">if (Relation_TestVtoV(obj1, relation, obj2)) {</span>
                        <span class="plain">if (clear) Relation_NowNVtoV(obj1, relation, obj2, sym);</span>
                        <span class="plain">else rfalse;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">if ((pr==0) &amp;&amp; (pr2)) {</span>
            <span class="plain">for (obj1=1:obj1&lt;=vtov_structure--&gt;2:obj1++)</span>
                <span class="plain">objectloop (obj2 provides pr2) {</span>
                    <span class="plain">if (Relation_TestVtoV(obj1, relation, obj2)) {</span>
                        <span class="plain">if (clear) Relation_NowNVtoV(obj1, relation, obj2, sym);</span>
                        <span class="plain">else rfalse;</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">return;</span>
        <span class="plain">}</span>
        <span class="plain">for (obj1=1:obj1&lt;=vtov_structure--&gt;2:obj1++)</span>
            <span class="plain">for (obj2=1:obj2&lt;=vtov_structure--&gt;VTOVS_RIGHT_DOMAIN_SIZE:obj2++)</span>
                <span class="plain">if (Relation_TestVtoV(obj1, relation, obj2)) {</span>
                    <span class="plain">if (Relation_TestVtoV(obj1, relation, obj2)) {</span>
                        <span class="plain">if (clear) Relation_NowNVtoV(obj1, relation, obj2, sym);</span>
                        <span class="plain">else rfalse;</span>
                    <span class="plain">}</span>
            <span class="plain">}</span>
        <span class="plain">rtrue;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP12"></a><b>&#167;12. Relation Route-Finding. </b>The general problem we have to solve here is: given x, y D, where ~
is a relation on a domain set D of objects,
</p>

<p class="inwebparagraph"></p>

<ul class="items"><li>(i) find the smallest n such that there exist x = r_1~ r_2~ ...~
r_n = y D such that r_i~ r_{i+1}, or determine that no such n exists,
and if so
</li><li>(ii) find a value of r_2 in such a "route" between x and y, or
set r_2=0 if x=y so that n=1.
</li></ul>
<p class="inwebparagraph">While in general a relation can have different left and right domains (a
relation between doors and rooms, say), route-finding on those relations is
unlikely to be very useful, so is discouraged. (In the case of doors and
rooms, a route could never be longer than 1 step, since no object is both a
door and a room, for instance.) The "fast" V-to-V algorithm requires D
to have the same left and right domains; NI compiles the memory caches for
V-to-V relations to force any cases with different domains into using the
"slow" algorithm.
</p>

<p class="inwebparagraph"><code class="display"><span class="extract">MAX_ROUTE_LENGTH</span></code> is used simply as a sanity check to prevent hangs if
something should go wrong, for instance if the property of a 1-to-V
relation has been modified by some third-party code in such a way that
it loses its defining invariant.
</p>


<pre class="display">
    <span class="plain">Constant MAX_ROUTE_LENGTH = ICOUNT_OBJECT + 32;</span>

    <span class="plain">[ RelationRouteTo relation from to count  handler;</span>
        <span class="plain">if (count) {</span>
            <span class="plain">if (from == nothing) return -1;</span>
            <span class="plain">if (to == nothing) return -1;</span>
            <span class="plain">if (relation == 0) return -1;</span>
        <span class="plain">} else {</span>
            <span class="plain">if (from == nothing) return nothing;</span>
            <span class="plain">if (to == nothing) return nothing;</span>
            <span class="plain">if (relation == 0) return nothing;</span>
        <span class="plain">}</span>
        <span class="plain">if (from == to) return nothing;</span>
        <span class="plain">if (((RlnGetF(relation, RR_PERMISSIONS)) &amp; RELS_ROUTE_FIND) == 0) {</span>
            <span class="plain">RunTimeProblem(RTP_ROUTELESS);</span>
            <span class="plain">return nothing;</span>
        <span class="plain">}</span>
        <span class="plain">if (RlnGetF(relation, RR_STORAGE) == 0) return nothing;</span>
        <span class="plain">handler = RlnGetF(relation, RR_HANDLER);</span>
        <span class="plain">if (count) return handler(relation, RELS_ROUTE_FIND_COUNT, from, to);</span>
        <span class="plain">return handler(relation, RELS_ROUTE_FIND, from, to);</span>
    <span class="plain">];</span>

    <span class="plain">[ RelFollowVector rv from to  obj i;</span>
        <span class="plain">if (rv == nothing) return -1;</span>
        <span class="plain">i = 0; obj = from;</span>
        <span class="plain">while ((obj ~= to) &amp;&amp; (i&lt;=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }</span>
        <span class="plain">return i;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP13"></a><b>&#167;13. One To Various Route-Finding. </b>Here we can immediately determine, given y, the unique y' such that
y'~ y, so finding a path from x to y is a matter of following the
only path leading to y and seeing if it ever passed through x; thus the
running time is O(n), where n is the size of the domain. It would be
pointless to cache this.
</p>

<p class="inwebparagraph">Note that we can assume here that x!= y, or rather, that <code class="display"><span class="extract">from ~= to</span></code>,
because that case has already been taken care of.
</p>


<pre class="display">
    <span class="plain">[ OtoVRelRouteTo relation_property from to previous;</span>
        <span class="plain">while ((to) &amp;&amp; (to provides relation_property) &amp;&amp; (to.relation_property)) {</span>
            <span class="plain">previous = to.relation_property;</span>
            <span class="plain">previous.vector = to;</span>
            <span class="plain">if (previous == from) return to;</span>
            <span class="plain">to = previous;</span>
        <span class="plain">}</span>
        <span class="plain">return nothing;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP14"></a><b>&#167;14. Various To One Route-Finding. </b>This time the simplifying assumption is that, given x, we can immediately
determine the unique x' such that x~ x', so it suffices to follow
the only path forwards from x and see if it ever reaches y. The routine
is not quite a mirror image of the one above, because both have the same
return requirements: we have to ensure that the <code class="display"><span class="extract">vector</span></code> properties lay out
the path, and also return the next step after x.
</p>


<pre class="display">
    <span class="plain">[ VtoORelRouteTo relation_property from to next  start;</span>
        <span class="plain">start = from;</span>
        <span class="plain">while ((from) &amp;&amp; (from provides relation_property) &amp;&amp; (from.relation_property)) {</span>
            <span class="plain">next = from.relation_property;</span>
            <span class="plain">from.vector = next;</span>
            <span class="plain">if (next == to) return start.vector;</span>
            <span class="plain">from = next;</span>
        <span class="plain">}</span>
        <span class="plain">return nothing;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP15"></a><b>&#167;15. Slow Various To Various Route-Finding. </b>Now there are no simplifying assumptions and the problem is essentially the
same as the one solved for route-finding in the map, above. Once again we
present two different algorithms: first, a form of Prim's algorithm for
minimal spanning trees. Note that, whereas this algorithm was not always
so "slow" for the map &mdash; because of the fairly low vertex degrees involved,
i.e., because most rooms had few connections to other rooms &mdash; here the
relation might well be almost complete, with almost all the objects related
to each other, and then the algorithm will indeed be "slow". So it is
likely that the "fast" algorithm will always be better, if the memory
can be spared for it.
</p>

<p class="inwebparagraph">We use the fast algorithm for a given relation if and only if the NI compiler
has allocated the necessary cache memory; the two use options above, for
map route-finding, don't control this.
</p>


<pre class="display">
    <span class="plain">[ VtoVRelRouteTo relation from to count obj obj2 related progressed left_ix pr2 i vtov_structure;</span>
        <span class="plain">vtov_structure = RlnGetF(relation, RR_STORAGE);</span>
        <span class="plain">if (vtov_structure--&gt;VTOVS_CACHE)</span>
            <span class="plain">return FastVtoVRelRouteTo(relation, from, to, count);</span>
        <span class="plain">left_ix = vtov_structure--&gt;VTOVS_LEFT_INDEX_PROP;</span>
        <span class="plain">pr2 = vtov_structure--&gt;VTOVS_RIGHT_INDEX_PROP;</span>
        <span class="plain">objectloop (obj ofclass Object &amp;&amp; obj provides vector) obj.vector = 0;</span>
        <span class="plain">to.vector = 1;</span>
        <span class="plain">while (true) {</span>
            <span class="plain">progressed = false;</span>
            <span class="plain">objectloop (obj ofclass Object &amp;&amp; obj provides left_ix)</span>
                <span class="plain">if (obj.vector == 0) {</span>
                    <span class="plain">objectloop (obj2 ofclass Object &amp;&amp; obj2 provides pr2 &amp;&amp; obj2.vector &gt; 0) {</span>
                        <span class="plain">if (Relation_TestVtoV(obj, relation, obj2)) {</span>
                            <span class="plain">obj.vector = obj2 | WORD_HIGHBIT;</span>
                            <span class="plain">progressed = true;</span>
                            <span class="plain">continue;</span>
                        <span class="plain">}</span>
                    <span class="plain">}</span>
                <span class="plain">}</span>
            <span class="plain">objectloop (obj ofclass Object &amp;&amp; obj provides left_ix)</span>
                <span class="plain">obj.vector = obj.vector &amp;~ WORD_HIGHBIT;</span>
            <span class="plain">if (from.vector) break;</span>
            <span class="plain">if (progressed == false) break;</span>
        <span class="plain">}</span>
        <span class="plain">if (count) {</span>
            <span class="plain">if (from.vector == nothing) return -1;</span>
            <span class="plain">i = 0; obj = from;</span>
            <span class="plain">while ((obj ~= to) &amp;&amp; (i&lt;=MAX_ROUTE_LENGTH)) { i++; obj = obj.vector; }</span>
            <span class="plain">return i;</span>
        <span class="plain">}</span>
        <span class="plain">return from.vector;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP16"></a><b>&#167;16. Fast Various To Various Route-Finding. </b>Now, as above, a form of the Floyd-Warshall algorithm. The matrix is here
stored in the cache of memory pointed to in the V-to-V relation structure.
We are unable to combine a_{ij} and d_{ij} into a single cell of
memory, so in fact we store two separate matrices: one for a_{ij}
(this is <code class="display"><span class="extract">cache</span></code> below), the other for n_{ij}, where n_{ij} is the
next object in the shortest path from O_i to O_j (this is <code class="display"><span class="extract">cache2</span></code>
below).
</p>

<p class="inwebparagraph">Where n&lt;256 a shortest path must be such that a_{ij}&lt;= 255, so can
be stored in a single byte, and we similarly store n_{ij} as the index
of the object rather than the object value itself: the index ranges from
0 to n-1, so that 0&lt;= n_{ij} &lt; 255 and we can use n_{ij} = 255
as a sentinel value meaning "no path". Although the reconversion of
n_{ij} back into a valid object value takes a little time, it is only
O(n), and of course we know n is relatively small; and in this way
we reduce the storage overhead to only n^2 bytes.
</p>

<p class="inwebparagraph">Where n&gt;= 256, we resign ourselves to storing two words for each pair
(i,j), making 2n^2 bytes of storage on the Z-machine and 4n^2 bytes
of storage on Glulx, but lookup of a cached result is slightly faster.
</p>


<pre class="display">
    <span class="plain">[ FastVtoVRelRouteTo relation from to count</span>
        <span class="plain">domainsize cache cache2 left_ix ox oy oj offset axy axj ayj;</span>
        <span class="plain">domainsize = RlnGetF(relation, RR_STORAGE)--&gt;2; ! Number of left instances</span>
        <span class="plain">left_ix = RlnGetF(relation, RR_STORAGE)--&gt;VTOVS_LEFT_INDEX_PROP;</span>
        <span class="plain">if ((from provides left_ix) &amp;&amp; (to provides left_ix)) {</span>
            <span class="plain">if (domainsize &lt; 256) {</span>
                <span class="plain">cache = RlnGetF(relation, RR_STORAGE)--&gt;VTOVS_CACHE;</span>
                <span class="plain">cache2 = cache + domainsize*domainsize;</span>
                <span class="plain">if (RlnGetF(relation, RR_STORAGE)--&gt;VTOVS_CACHE_BROKEN == true) {</span>
                    <span class="plain">RlnGetF(relation, RR_STORAGE)--&gt;VTOVS_CACHE_BROKEN = false;</span>
                    <span class="plain">objectloop (oy provides left_ix)</span>
                        <span class="plain">objectloop (ox provides left_ix)</span>
                            <span class="plain">if (Relation_TestVtoV(oy, relation, ox)) {</span>
                                <span class="plain">offset = ((oy.left_ix)*domainsize + (ox.left_ix));</span>
                                <span class="plain">cache-&gt;offset = 1;</span>
                                <span class="plain">cache2-&gt;offset = ox.left_ix;</span>
                            <span class="plain">} else {</span>
                                <span class="plain">offset = ((oy.left_ix)*domainsize + (ox.left_ix));</span>
                                <span class="plain">cache-&gt;offset = 0;</span>
                                <span class="plain">cache2-&gt;offset = 255;</span>
                            <span class="plain">}</span>
                    <span class="plain">for (oy=0: oy&lt;domainsize: oy++)</span>
                        <span class="plain">for (ox=0: ox&lt;domainsize: ox++) {</span>
                            <span class="plain">axy = cache-&gt;(ox*domainsize + oy);</span>
                            <span class="plain">if (axy &gt; 0)</span>
                                <span class="plain">for (oj=0: oj&lt;domainsize: oj++) {</span>
                                    <span class="plain">ayj = cache-&gt;(oy*domainsize + oj);</span>
                                    <span class="plain">if (ayj &gt; 0) {</span>
                                        <span class="plain">offset = ox*domainsize + oj;</span>
                                        <span class="plain">axj = cache-&gt;offset;</span>
                                        <span class="plain">if ((axj == 0) || (axy + ayj &lt; axj)) {</span>
                                            <span class="plain">cache-&gt;offset = (axy + ayj);</span>
                                            <span class="plain">cache2-&gt;offset = cache2-&gt;(ox*domainsize + oy);</span>
                                        <span class="plain">}</span>
                                    <span class="plain">}</span>
                                <span class="plain">}</span>
                        <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="plain">if (count) {</span>
                    <span class="plain">count = cache-&gt;((from.left_ix)*domainsize + (to.left_ix));</span>
                    <span class="plain">if (count == 0) return -1;</span>
                    <span class="plain">return count;</span>
                <span class="plain">}</span>
                <span class="plain">oy = cache2-&gt;((from.left_ix)*domainsize + (to.left_ix));</span>
                <span class="plain">if (oy &lt; 255)</span>
                    <span class="plain">objectloop (ox provides left_ix)</span>
                        <span class="plain">if (ox.left_ix == oy) return ox;</span>
                <span class="plain">return nothing;</span>
            <span class="plain">} else {</span>
                <span class="plain">cache = RlnGetF(relation, RR_STORAGE)--&gt;VTOVS_CACHE;</span>
                <span class="plain">cache2 = cache + WORDSIZE*domainsize*domainsize;</span>
                <span class="plain">if (RlnGetF(relation, RR_STORAGE)--&gt;VTOVS_CACHE_BROKEN == true) {</span>
                    <span class="plain">RlnGetF(relation, RR_STORAGE)--&gt;VTOVS_CACHE_BROKEN = false;</span>
                    <span class="plain">objectloop (oy provides left_ix)</span>
                        <span class="plain">objectloop (ox provides left_ix)</span>
                            <span class="plain">if (Relation_TestVtoV(oy, relation, ox)) {</span>
                                <span class="plain">offset = ((oy.left_ix)*domainsize + (ox.left_ix));</span>
                                <span class="plain">cache--&gt;offset = 1;</span>
                                <span class="plain">cache2--&gt;offset = ox;</span>
                            <span class="plain">} else {</span>
                                <span class="plain">offset = ((oy.left_ix)*domainsize + (ox.left_ix));</span>
                                <span class="plain">cache--&gt;offset = 0;</span>
                                <span class="plain">cache2--&gt;offset = nothing;</span>
                            <span class="plain">}</span>
                    <span class="plain">for (oy=0: oy&lt;domainsize: oy++)</span>
                        <span class="plain">for (ox=0: ox&lt;domainsize: ox++) {</span>
                            <span class="plain">axy = cache--&gt;(ox*domainsize + oy);</span>
                            <span class="plain">if (axy &gt; 0)</span>
                                <span class="plain">for (oj=0: oj&lt;domainsize: oj++) {</span>
                                    <span class="plain">ayj = cache--&gt;(oy*domainsize + oj);</span>
                                    <span class="plain">if (ayj &gt; 0) {</span>
                                        <span class="plain">offset = ox*domainsize + oj;</span>
                                        <span class="plain">axj = cache--&gt;offset;</span>
                                        <span class="plain">if ((axj == 0) || (axy + ayj &lt; axj)) {</span>
                                            <span class="plain">cache--&gt;offset = (axy + ayj);</span>
                                            <span class="plain">cache2--&gt;offset = cache2--&gt;(ox*domainsize + oy);</span>
                                        <span class="plain">}</span>
                                    <span class="plain">}</span>
                                <span class="plain">}</span>
                        <span class="plain">}</span>
                <span class="plain">}</span>
                <span class="plain">if (count) {</span>
                    <span class="plain">count = cache--&gt;((from.left_ix)*domainsize + (to.left_ix));</span>
                    <span class="plain">if (count == 0) return -1;</span>
                    <span class="plain">return count;</span>
                <span class="plain">}</span>
                <span class="plain">return cache2--&gt;((from.left_ix)*domainsize + (to.left_ix));</span>
            <span class="plain">}</span>
        <span class="plain">}</span>
        <span class="plain">if (count) return -1;</span>
        <span class="plain">return nothing;</span>
    <span class="plain">];</span>
</pre>

<p class="inwebparagraph"></p>

<p class="inwebparagraph"><a id="SP17"></a><b>&#167;17. Iterating Relations. </b>The following is provided to make it possible to run an I6 routine on each
relation in turn. (Each right-way-round relation, at any rate.)
</p>

<p class="inwebparagraph"></p>

<hr class="tocbar">
<ul class="toc"><li><a href="S-rkt.html">Back to 'Relation Kind Template'</a></li><li><a href="S-rt3.html">Continue with 'RTP Template'</a></li></ul><hr class="tocbar">
<!--End of weave-->
	</body>
</html>

