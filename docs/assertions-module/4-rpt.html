<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Refine Parse Tree</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Preform-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../index.html">home</a></li>
</ul><h2>Compiler</h2><ul>
<li><a href="../structure.html">structure</a></li>
<li><a href="../inbuildn.html">inbuild</a></li>
<li><a href="../inform7n.html">inform7</a></li>
<li><a href="../intern.html">inter</a></li>
<li><a href="../services.html">services</a></li>
<li><a href="../secrets.html">secrets</a></li>
</ul><h2>Other Tools</h2><ul>
<li><a href="../inblorbn.html">inblorb</a></li>
<li><a href="../indocn.html">indoc</a></li>
<li><a href="../inform6.html">inform6</a></li>
<li><a href="../inpolicyn.html">inpolicy</a></li>
</ul><h2>Resources</h2><ul>
<li><a href="../extensions.html">extensions</a></li>
<li><a href="../kits.html">kits</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=18> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="../../../inweb/index.html">inweb</a></li>
<li><a href="../../../intest/index.html">intest</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Refine Parse Tree' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../inform7n.html">Inform7</a></li><li><a href="index.html">assertions</a></li><li><a href="index.html#4">Chapter 4: Assertions</a></li><li><b>Refine Parse Tree</b></li></ul></div>
<p class="purpose">To determine which subjects are referred to by noun phrases such as "the table" or "a paper cup" found in assertion sentences.</p>

<ul class="toc"><li><a href="4-rpt.html#SP1">&#167;1. How individual nouns are represented after refinement</a></li><li><a href="4-rpt.html#SP4">&#167;4. The player is not yourself</a></li><li><a href="4-rpt.html#SP5">&#167;5. Representation of single adjectives</a></li><li><a href="4-rpt.html#SP7">&#167;7. Simple descriptions</a></li><li><a href="4-rpt.html#SP8">&#167;8. Refining couplings</a></li><li><a href="4-rpt.html#SP9">&#167;9. The refinery itself</a></li><li><a href="4-rpt.html#SP12">&#167;12. About surgeries</a></li><li><a href="4-rpt.html#SP14">&#167;14. Un-WITH</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. How individual nouns are represented after refinement. </b></p>

<ul class="items"><li>(a) In general, noun phrases in the parse tree divide into "proper" and "common".
Before refinement they generally have node type <span class="extract"><span class="extract-syntax">UNPARSED_NOUN_NT</span></span>: afterwards,
either <span class="extract"><span class="extract-syntax">PROPER_NOUN_NT</span></span> or <span class="extract"><span class="extract-syntax">COMMON_NOUN_NT</span></span>.
</li><li>(b) A noun phrase node has a "subject" annotation, identifying what if anything
it refers to. For example, "a door" refers to the kind "door".
</li><li>(c) It also has an "evaluation" annotation. For example, "35" evaluates to
the number 33, but has no subject.
</li><li>(d) If the noun phrase gives a number of items, the <span class="extract"><span class="extract-syntax">multiplicity</span></span> annotation
records how many; thus, for "six lorries" it would be 6.
</li><li>(e) If the noun phrase describes some properties or relations which must be
true &mdash; "an open door", say, or "a woman in London" &mdash; these are recorded
in a <span class="extract"><span class="extract-syntax">creation_proposition</span></span> annotation.
</li></ul>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::give_subject_to_noun</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">Refiner::give_subject_to_noun</span></span>:<br/><a href="4-rpt.html#SP4">&#167;4</a>, <a href="4-rpt.html#SP7_1">&#167;7.1</a>, <a href="4-rpt.html#SP11_5_1">&#167;11.5.1</a>, <a href="4-rpt.html#SP11_7">&#167;11.7</a><br/>The Creator - <a href="4-tc.html#SP4_4">&#167;4.4</a>, <a href="4-tc.html#SP7_4">&#167;7.4</a>, <a href="4-tc.html#SP7_4_1">&#167;7.4.1</a><br/>Assemblies - <a href="4-ass2.html#SP13">&#167;13</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">eval</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InferenceSubjects::as_constant</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP1_1" class="named-paragraph-link"><span class="named-paragraph">Make a common or proper noun as appropriate</span><span class="named-paragraph-number">1.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::give_spec_to_noun</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">Refiner::give_spec_to_noun</span></span>:<br/><a href="4-rpt.html#SP6">&#167;6</a>, <a href="4-rpt.html#SP11_8_2">&#167;11.8.2</a>, <a href="4-rpt.html#SP11_8_2_5">&#167;11.8.2.5</a><br/>Define by Table Requests - <a href="3-dbtr.html#SP4_1_3">&#167;4.1.3</a>, <a href="3-dbtr.html#SP4_2_3_1">&#167;4.2.3.1</a><br/>The Creator - <a href="4-tc.html#SP4_4">&#167;4.4</a>, <a href="4-tc.html#SP4_4_1_1">&#167;4.4.1.1</a><br/>Relation Knowledge - <a href="4-rk.html#SP2">&#167;2</a><br/>Tables - <a href="7-tbl.html#SP23_1">&#167;23.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">eval</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Specifications::to_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">eval</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP1_1" class="named-paragraph-link"><span class="named-paragraph">Make a common or proper noun as appropriate</span><span class="named-paragraph-number">1.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP1_1" class="paragraph-anchor"></a><b>&#167;1.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make a common or proper noun as appropriate</span><span class="named-paragraph-number">1.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">KindSubjects::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs</span><span class="plain-syntax">)) </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">COMMON_NOUN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="4-rpt.html#SP2" class="function-link"><span class="function-syntax">Refiner::apply_description</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">eval</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">infs</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_evaluation</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">eval</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP1">&#167;1</a> (twice).</li></ul>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2.  </b>This can be performed either on noun or <span class="extract"><span class="extract-syntax">ADJECTIVE_NT</span></span> nodes. It transfers
the details of a description to the node.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::apply_description</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">Refiner::apply_description</span></span>:<br/><a href="4-rpt.html#SP1_1">&#167;1.1</a>, <a href="4-rpt.html#SP5">&#167;5</a>, <a href="4-rpt.html#SP7_1">&#167;7.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">desc</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Specifications::is_description</span><span class="plain-syntax">(</span><span class="identifier-syntax">desc</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Descriptions::get_quantified_prop</span><span class="plain-syntax">(</span><span class="identifier-syntax">desc</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_creation_proposition</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">Propositions::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">prop</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">N</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Descriptions::get_quantification_parameter</span><span class="plain-syntax">(</span><span class="identifier-syntax">desc</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">N</span><span class="plain-syntax"> &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">multiplicity_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">N</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3.  </b>It's useful to have a safe way of transferring the complete noun details
from one node to another, without breaking the above invariant. (The
<span class="extract"><span class="extract-syntax">nowhere</span></span> annotation is used by the spatial feature, if active, and
it probably never needs to be copied, but we do so for safety's sake.)
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::copy_noun_details</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">Refiner::copy_noun_details</span></span>:<br/>Tables - <a href="7-tbl.html#SP26">&#167;26</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p_from</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_from</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_evaluation</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_evaluation</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_from</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_creation_proposition</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_creation_proposition</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_from</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_from</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">multiplicity_ANNOT</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">multiplicity_ANNOT</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">nowhere_ANNOT</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">nowhere_ANNOT</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_site_ANNOT</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_site_ANNOT</span><span class="plain-syntax">));</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4. The player is not yourself. </b>The following function handles a feature added to Inform to handle just one
peculiarity of syntax: that the source text will often talk about "the
player" to mean the instance which represents the player at the start of
play (properly called "yourself"), not the variable whose value is the
instance currently representing the player.
</p>

<p class="commentary">But no explicit mention of this case appears here; in theory any global
variable can be set to shadow a spcific instance in this way.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::turn_player_to_yourself</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">Refiner::turn_player_to_yourself</span></span>:<br/>Assertions - <a href="4-ass.html#SP6_3_13">&#167;6.3.13</a>, <a href="4-ass.html#SP6_3_20">&#167;6.3.20</a>, <a href="4-ass.html#SP6_3_25">&#167;6.3.25</a>, <a href="4-ass.html#SP6_3_26">&#167;6.3.26</a>, <a href="4-ass.html#SP6_3_29">&#167;6.3.29</a>, <a href="4-ass.html#SP6_3_36">&#167;6.3.36</a>, <a href="4-ass.html#SP6_3_37">&#167;6.3.37</a><br/>Relation Knowledge - <a href="4-rk.html#SP3_1">&#167;3.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pn</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">))) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">) == </span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">, </span><span class="identifier-syntax">turned_already_ANNOT</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">nonlocal_variable</span><span class="plain-syntax"> *</span><span class="identifier-syntax">q</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NonlocalVariables::parse_global</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">diversion</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NonlocalVariables::get_alias</span><span class="plain-syntax">(</span><span class="identifier-syntax">q</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">diversion</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><a href="4-rpt.html#SP1" class="function-link"><span class="function-syntax">Refiner::give_subject_to_noun</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">, </span><span class="identifier-syntax">diversion</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">, </span><span class="identifier-syntax">turned_already_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5. Representation of single adjectives. </b>Individual adjective nodes are made as follows. Note that we append noun
details to the nodes so that sentences like this one...
</p>

<blockquote>
    <p>Scenery is usually fixed in place.</p>
</blockquote>

<p class="commentary">...can work; here "scenery", though an adjective, is effectively a common
noun in disguise. (It's a deficiency of English that a surprising number of
common objects, which ought to have count nouns, in fact have mass nouns &mdash;
compare "clothing" and "clothes", which has no adequate singular.)
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::pn_make_adjective</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">Refiner::pn_make_adjective</span></span>:<br/><a href="4-rpt.html#SP7_3">&#167;7.3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ale</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">ADJECTIVE_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_predicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">ale</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_evaluation</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="4-rpt.html#SP2" class="function-link"><span class="function-syntax">Refiner::apply_description</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6.  </b>A different reason why adjective and nouns overlap is due to words like
"green", which describe a state and also suggest that something possesses it.
Context sometimes causes us to consider an adjective as a noun instead,
though only if it has a positive sense and has a nominal meaning.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::nominalise_adjective</span><button class="popup" onclick="togglePopup('usagePopup7')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup7">Usage of <span class="code-font"><span class="function-syntax">Refiner::nominalise_adjective</span></span>:<br/>Assertions - <a href="4-ass.html#SP6_3_22">&#167;6.3.22</a>, <a href="4-ass.html#SP6_3_26">&#167;6.3.26</a>, <a href="4-ass.html#SP6_3_29">&#167;6.3.29</a>, <a href="4-ass.html#SP6_3_42">&#167;6.3.42</a><br/>Property Knowledge - <a href="4-pk.html#SP3_4">&#167;3.4</a><br/>Relation Knowledge - <a href="4-rk.html#SP3_1">&#167;3.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">p</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">) == </span><span class="identifier-syntax">ADJECTIVE_NT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pred</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_predicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="8-tap.html#SP4" class="function-link"><span class="function-syntax">AdjectivalPredicates::parity</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pred</span><span class="plain-syntax">) == </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">q</span><span class="plain-syntax"> = </span><a href="8-aa.html#SP5" class="function-link"><span class="function-syntax">AdjectiveAmbiguity::has_enumerative_meaning</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><a href="8-tap.html#SP4" class="function-link"><span class="function-syntax">AdjectivalPredicates::to_adjective</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">pred</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">q</span><span class="plain-syntax">) </span><a href="4-rpt.html#SP1" class="function-link"><span class="function-syntax">Refiner::give_spec_to_noun</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">Rvalues::from_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">q</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">p</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">) == </span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7. Simple descriptions. </b>For a precise definition see <a href="../values-module/2-dsc.html" class="internal">Descriptions (in values)</a>, but roughly speaking
a "simple" description is one with only adjectives and perhaps a head noun:
thus "closed" and "a closed lockable door" are simple, but "four women in a
lighted room" is complex.
</p>

<p class="commentary">The following function should be called only on a simple description.
It turns the node <span class="extract"><span class="extract-syntax">p</span></span> into a subtree representing the content of
that simple description in <span class="extract"><span class="extract-syntax">desc</span></span>.
</p>

<p class="commentary">Depending on the circumstances, we get a subtree in which the headword if any
is represented by an <span class="extract"><span class="extract-syntax">COMMON_NOUN_NT</span></span> node (where the headword is a kind of
object) or a <span class="extract"><span class="extract-syntax">PROPER_NOUN_NT</span></span> (where the headword is a specific object), and
where the adjectives each become <span class="extract"><span class="extract-syntax">ADJECTIVE_NT</span></span> nodes.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::refine_from_simple_description</span><button class="popup" onclick="togglePopup('usagePopup8')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup8">Usage of <span class="code-font"><span class="function-syntax">Refiner::refine_from_simple_description</span></span>:<br/><a href="4-rpt.html#SP11_8_2_5_1">&#167;11.8.2.5.1</a><br/>Assemblies - <a href="4-ass2.html#SP8_3">&#167;8.3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">desc</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">head</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP7_1" class="named-paragraph-link"><span class="named-paragraph">Set the attachment node to the headword, if there is one</span><span class="named-paragraph-number">7.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Descriptions::number_of_adjectives_applied_to</span><span class="plain-syntax">(</span><span class="identifier-syntax">desc</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">head</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP7_2" class="named-paragraph-link"><span class="named-paragraph">Insert a WITH node joining adjective tree to headword</span><span class="named-paragraph-number">7.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP7_3" class="named-paragraph-link"><span class="named-paragraph">Place a subtree of adjectives at the attachment node</span><span class="named-paragraph-number">7.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7_1" class="paragraph-anchor"></a><b>&#167;7.1.  </b>Crucially, the headword node gets one extra annotation: its "full phrase
evaluation", which retains the original description information &mdash; in
particular, quantification data such as that in "four doors", which
would be lost if we simply applied <span class="extract"><span class="extract-syntax">Refiner::give_subject_to_noun</span></span> to the inference
subject for "door".
</p>

<p class="commentary">If <span class="extract"><span class="extract-syntax">head</span></span> is not set, it doesn't matter what we do, because there'll be
no headword node &mdash; this is why we don't bother to find any subject to
set for it.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Set the attachment node to the headword, if there is one</span><span class="named-paragraph-number">7.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Descriptions::to_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">desc</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">head</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">Descriptions::to_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">desc</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">head</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><a href="4-rpt.html#SP1" class="function-link"><span class="function-syntax">Refiner::give_subject_to_noun</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">head</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><a href="4-rpt.html#SP2" class="function-link"><span class="function-syntax">Refiner::apply_description</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">desc</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Descriptions::makes_kind_explicit</span><span class="plain-syntax">(</span><span class="identifier-syntax">desc</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Specifications::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">desc</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">head</span><span class="plain-syntax"> = </span><span class="identifier-syntax">KindSubjects::from_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><a href="4-rpt.html#SP1" class="function-link"><span class="function-syntax">Refiner::give_subject_to_noun</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">head</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_evaluation</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">Specifications::from_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><a href="4-rpt.html#SP2" class="function-link"><span class="function-syntax">Refiner::apply_description</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">desc</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP7">&#167;7</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP7_2" class="paragraph-anchor"></a><b>&#167;7.2.  </b>We put a WITH node in the attachment position, displacing the headword
content to its first child, and making its second child the new attachment
position &mdash; so that that is where the adjectives subtree will go.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Insert a WITH node joining adjective tree to headword</span><span class="named-paragraph-number">7.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">lower_copy</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::copy</span><span class="plain-syntax">(</span><span class="identifier-syntax">lower_copy</span><span class="plain-syntax">, </span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">WITH_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">lower_copy</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">lower_copy</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">lower_copy</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP7">&#167;7</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP7_3" class="paragraph-anchor"></a><b>&#167;7.3.  </b>When there are two or more adjectives, they must occur as leaves of a
binary tree whose non-leaf nodes are <span class="extract"><span class="extract-syntax">AND_NT</span></span>. We do this pretty inefficiently,
making no effort to balance the tree, since it has negligible effect on speed
or memory.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Place a subtree of adjectives at the attachment node</span><span class="named-paragraph-number">7.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">no_adjectives</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Descriptions::number_of_adjectives_applied_to</span><span class="plain-syntax">(</span><span class="identifier-syntax">desc</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">no_adjectives</span><span class="plain-syntax"> == </span><span class="constant-syntax">1</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><a href="4-rpt.html#SP5" class="function-link"><span class="function-syntax">Refiner::pn_make_adjective</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Descriptions::first_unary_predicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">desc</span><span class="plain-syntax">), </span><span class="identifier-syntax">desc</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_type_and_clear_annotations</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">AND_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ale</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">AND_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ale_prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOOP_THROUGH_ADJECTIVE_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">ale</span><span class="plain-syntax">, </span><span class="identifier-syntax">ale_prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">desc</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">i</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p3</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">ADJECTIVE_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><a href="4-rpt.html#SP5" class="function-link"><span class="function-syntax">Refiner::pn_make_adjective</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p3</span><span class="plain-syntax">, </span><span class="identifier-syntax">ale</span><span class="plain-syntax">, </span><span class="identifier-syntax">desc</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">i</span><span class="plain-syntax"> &lt; </span><span class="identifier-syntax">no_adjectives</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">AND_p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p3</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">i</span><span class="plain-syntax">+1 &lt; </span><span class="identifier-syntax">no_adjectives</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">p3</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">AND_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">AND_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p3</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">            } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">AND_p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p3</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP7">&#167;7</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8. Refining couplings. </b>When an assertion couples <span class="extract"><span class="extract-syntax">px</span></span> and <span class="extract"><span class="extract-syntax">py</span></span>, the following is called first to
refine them.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::refine_coupling</span><button class="popup" onclick="togglePopup('usagePopup9')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup9">Usage of <span class="code-font"><span class="function-syntax">Refiner::refine_coupling</span></span>:<br/>Passes through Major Nodes - <a href="2-ptmn.html#SP3_1_2_3">&#167;3.1.2.3</a><br/>Classifying Sentences - <a href="2-cs.html#SP7">&#167;7</a><br/>Define by Table Requests - <a href="3-dbtr.html#SP4_1_3">&#167;4.1.3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">px</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">py</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">logging</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">pc</span><span class="plain-syntax"> = </span><span class="identifier-syntax">problem_count</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><a href="4-rpt.html#SP14" class="function-link"><span class="function-syntax">Refiner::un_with</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">px</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="4-rpt.html#SP14" class="function-link"><span class="function-syntax">Refiner::un_with</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">py</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="4-rpt.html#SP10" class="function-link"><span class="function-syntax">Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">px</span><span class="plain-syntax">, </span><span class="constant-syntax">ALLOW_CREATION</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="4-rpt.html#SP10" class="function-link"><span class="function-syntax">Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">py</span><span class="plain-syntax">, </span><span class="constant-syntax">ALLOW_CREATION</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">problem_count</span><span class="plain-syntax"> &gt; </span><span class="identifier-syntax">pc</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">logging</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"Refined:\n"</span><span class="plain-syntax">); </span><span class="identifier-syntax">LOG_INDENT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"$T"</span><span class="plain-syntax">, </span><span class="identifier-syntax">px</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"$T"</span><span class="plain-syntax">, </span><span class="identifier-syntax">py</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG_OUTDENT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="4-tc.html#SP1" class="function-link"><span class="function-syntax">Assertions::Creator::consult_the_creator</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">px</span><span class="plain-syntax">, </span><span class="identifier-syntax">py</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9. The refinery itself. </b>Time to get started, then. Each subtree can be refined only once.
</p>

<p class="commentary">The <span class="extract"><span class="extract-syntax">creation_rule</span></span> can have three values:
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span><span class="plain-syntax"> </span><span class="comment-syntax"> never create an object with this name</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">ALLOW_CREATION</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax"> </span><span class="comment-syntax"> create an object with this name if that looks sensible</span>
<span class="definition-keyword">define</span> <span class="constant-syntax">MANDATE_CREATION</span><span class="plain-syntax"> </span><span class="constant-syntax">2</span><span class="plain-syntax"> </span><span class="comment-syntax"> always create an object with this name, except for "it"</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">forbid_nowhere</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::refine</span><button class="popup" onclick="togglePopup('usagePopup10')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup10">Usage of <span class="code-font"><span class="function-syntax">Refiner::refine</span></span>:<br/><a href="4-rpt.html#SP8">&#167;8</a>, <a href="4-rpt.html#SP11_1">&#167;11.1</a>, <a href="4-rpt.html#SP11_2">&#167;11.2</a>, <a href="4-rpt.html#SP11_3">&#167;11.3</a>, <a href="4-rpt.html#SP11_4">&#167;11.4</a>, <a href="4-rpt.html#SP11_5">&#167;11.5</a>, <a href="4-rpt.html#SP11_6">&#167;11.6</a><br/>New Property Requests - <a href="3-npr.html#SP5">&#167;5</a><br/>Calculus Utilities - <a href="8-cu.html#SP8_1">&#167;8.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">p</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"Refine parse tree on null pn"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">refined_ANNOT</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">refined_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">VerbPhrases::corrective_surgery</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">NOUN_RESOLUTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Refine subtree (%s creation):\n$T"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        ((</span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax"> == </span><span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax">)?</span><span class="string-syntax">"forbid"</span><span class="plain-syntax">:</span>
<span class="plain-syntax">            ((</span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax"> == </span><span class="constant-syntax">ALLOW_CREATION</span><span class="plain-syntax">)?</span><span class="string-syntax">"allow"</span><span class="plain-syntax">:</span><span class="string-syntax">"mandate"</span><span class="plain-syntax">)), </span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOG_INDENT</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><a href="4-rpt.html#SP11" class="function-link"><span class="function-syntax">Refiner::refine_parse_tree_inner</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">LOG_OUTDENT</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">NOUN_RESOLUTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Refined subtree is:\n$T"</span><span class="plain-syntax">, </span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11.  </b>What we do depends on the crude structure already found.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::refine_parse_tree_inner</span><button class="popup" onclick="togglePopup('usagePopup11')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup11">Usage of <span class="code-font"><span class="function-syntax">Refiner::refine_parse_tree_inner</span></span>:<br/><a href="4-rpt.html#SP10">&#167;10</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">X_OF_Y_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_1" class="named-paragraph-link"><span class="named-paragraph">Refine an X-of-Y subtree</span><span class="named-paragraph-number">11.1</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">WITH_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_2" class="named-paragraph-link"><span class="named-paragraph">Refine an X-with-Y subtree</span><span class="named-paragraph-number">11.2</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">AND_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_3" class="named-paragraph-link"><span class="named-paragraph">Refine an X-and-Y subtree</span><span class="named-paragraph-number">11.3</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">RELATIONSHIP_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_5" class="named-paragraph-link"><span class="named-paragraph">Refine a relationship subtree</span><span class="named-paragraph-number">11.5</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">CALLED_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_4" class="named-paragraph-link"><span class="named-paragraph">Refine a calling subtree</span><span class="named-paragraph-number">11.4</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">KIND_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_6" class="named-paragraph-link"><span class="named-paragraph">Refine a kind subtree</span><span class="named-paragraph-number">11.6</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">PRONOUN_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_7" class="named-paragraph-link"><span class="named-paragraph">Refine a pronoun</span><span class="named-paragraph-number">11.7</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">PROPER_NOUN_NT:</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">UNPARSED_NOUN_NT:</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_8" class="named-paragraph-link"><span class="named-paragraph">Refine what seems to be a noun phrase</span><span class="named-paragraph-number">11.8</span></a></span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP11_1" class="paragraph-anchor"></a><b>&#167;11.1.  </b>Recall that an <span class="extract"><span class="extract-syntax">X_OF_Y_NT</span></span> subtree has the form owner followed by
property name, so we forbid creation of a new object from the property name
subtree.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine an X-of-Y subtree</span><span class="named-paragraph-number">11.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><a href="4-rpt.html#SP10" class="function-link"><span class="function-syntax">Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="4-rpt.html#SP10" class="function-link"><span class="function-syntax">Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">, </span><span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11">&#167;11</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_2" class="paragraph-anchor"></a><b>&#167;11.2.  </b><span class="extract"><span class="extract-syntax">WITH_NT</span></span> is used to create something with a list of properties. This
leads to some awkward cases &mdash; for instance, where a "with" in an action
pattern like "doing something with the bucket" has been misinterpreted.
We fix those cases by hand, by reconstructing the text before it was
divided, then parsing it as an action pattern; if that works, that reading
is allowed to stand.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine an X-with-Y subtree</span><span class="named-paragraph-number">11.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><a href="4-rpt.html#SP10" class="function-link"><span class="function-syntax">Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="4-rpt.html#SP13" class="function-link"><span class="function-syntax">Refiner::perform_with_surgery</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">) == </span><span class="identifier-syntax">WITH_NT</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">IF_MODULE</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Wordings::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">Wordings::first_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">)),</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Wordings::last_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">)));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;action-pattern&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">ActionsNodes::convert_to_ACTION_node</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11">&#167;11</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_3" class="paragraph-anchor"></a><b>&#167;11.3.  </b><span class="extract"><span class="extract-syntax">AND_NT</span></span> is easy, except for "and surgery", of which more below.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine an X-and-Y subtree</span><span class="named-paragraph-number">11.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><a href="4-rpt.html#SP10" class="function-link"><span class="function-syntax">Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="4-rpt.html#SP10" class="function-link"><span class="function-syntax">Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="4-rpt.html#SP12" class="function-link"><span class="function-syntax">Refiner::perform_and_surgery</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11">&#167;11</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_4" class="paragraph-anchor"></a><b>&#167;11.4.  </b>A <span class="extract"><span class="extract-syntax">CALLED_NT</span></span> node has two children: in the phrase "an X called Y", they
will represent X and Y respectively. Y must be created afresh whatever its
name, since the whole point of "called" is that it enables the designer
to use names which would otherwise be interpreted as meaning something
significant: it is a sort of literal escape, like the backslash character
in C strings. X is never something new: it is expected to be a kind.
We convert the whole node into a simple <span class="extract"><span class="extract-syntax">PROPER_NOUN_NT</span></span> with the name
of Y and the kind of X. In this way, all <span class="extract"><span class="extract-syntax">CALLED_NT</span></span> nodes are removed
from the tree.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine a calling subtree</span><span class="named-paragraph-number">11.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><a href="4-rpt.html#SP10" class="function-link"><span class="function-syntax">Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">, </span><span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">multiplicity_ANNOT</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">1</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_MultipleCalled</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"I can only make a single 'called' thing at a time"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"or rather, the 'called' is only allowed to apply to one thing "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"at a time. For instance, 'A thing called a vodka and tonic is "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"on the table.' is allowed, but 'Two things called vodka and tonic' "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"is not."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">forbid_nowhere</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax"> == </span><span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">BelievedImpossible</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"'called' can't be used in this context"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"and is best reserved for full sentences."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><a href="4-rpt.html#SP10" class="function-link"><span class="function-syntax">Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">, </span><span class="constant-syntax">MANDATE_CREATION</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">forbid_nowhere</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11">&#167;11</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_5" class="paragraph-anchor"></a><b>&#167;11.5.  </b>A <span class="extract"><span class="extract-syntax">RELATIONSHIP_NT</span></span> node may have no children, representing "here"; or
it may have one child, a room or door which lies in some map direction. But
in general it has two children: for instance "a green marble in a blue box"
has the marble and the box as its children, the relationship being containment.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine a relationship subtree</span><span class="named-paragraph-number">11.5</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><a href="4-rpt.html#SP10" class="function-link"><span class="function-syntax">Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">IF_MODULE</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">dir</span><span class="plain-syntax"> = </span><span class="identifier-syntax">MapRelations::get_mapping_relationship</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">dir</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_5_1" class="named-paragraph-link"><span class="named-paragraph">Make the relation one which refers to a map direction</span><span class="named-paragraph-number">11.5.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        #</span><span class="identifier-syntax">endif</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">) </span><a href="4-rpt.html#SP10" class="function-link"><span class="function-syntax">Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">, </span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11">&#167;11</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_5_1" class="paragraph-anchor"></a><b>&#167;11.5.1.  </b>This handles the case of a one-child node representing a map direction,
but fills in a second child as the direction object in question. Thus if
the relation is mapped-north-of, then the second child will become the
direction object for "north".
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make the relation one which refers to a map direction</span><span class="named-paragraph-number">11.5.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">NOUN_RESOLUTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Directional predicate with BP from $O\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">dir</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">DW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Instances::get_name</span><span class="plain-syntax">(</span><span class="identifier-syntax">dir</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Diagrams::new_UNPARSED_NOUN</span><span class="plain-syntax">(</span><span class="identifier-syntax">DW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="4-rpt.html#SP1" class="function-link"><span class="function-syntax">Refiner::give_subject_to_noun</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">, </span><span class="identifier-syntax">Instances::as_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">dir</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">, </span><span class="identifier-syntax">refined_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11_5">&#167;11.5</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_6" class="paragraph-anchor"></a><b>&#167;11.6.  </b>A <span class="extract"><span class="extract-syntax">KIND_NT</span></span> node may have no children, and if so it represents the bare
word "kind": the reference must be to the kind "kind" itself.
Otherwise it has one child &mdash; the name of an existing kind of value or
object. After refinement, it will be annotated with a valid non-null
inference subject representing the domain to which any new kind would belong.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine a kind subtree</span><span class="named-paragraph-number">11.6</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> = </span><span class="identifier-syntax">KindSubjects::from_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_object</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">what</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><a href="4-rpt.html#SP10" class="function-link"><span class="function-syntax">Refiner::refine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">what</span><span class="plain-syntax">, </span><span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">what</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">KindSubjects::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_6_1" class="named-paragraph-link"><span class="named-paragraph">Issue a problem message for a kind of instance</span><span class="named-paragraph-number">11.6.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">KindSubjects::to_nonobject_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> != </span><span class="identifier-syntax">KindSubjects::from_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> != </span><span class="identifier-syntax">KindSubjects::from_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_object</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_6_2" class="named-paragraph-link"><span class="named-paragraph">Issue a problem message for a disallowed subkind</span><span class="named-paragraph-number">11.6.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11">&#167;11</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_6_1" class="paragraph-anchor"></a><b>&#167;11.6.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue a problem message for a kind of instance</span><span class="named-paragraph-number">11.6.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">InferenceSubjects::is_an_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax">)) ||</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">InferenceSubjects::is_a_kind_of_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_KindOfInstance</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"kinds can only be made from other kinds"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"so 'a kind of container' is allowed but 'a kind of Mona Lisa' (where "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"Mona Lisa is a specific thing you've already made), wouldn't be "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"allowed. There is only one Mona Lisa."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> = </span><span class="identifier-syntax">KindSubjects::from_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_object</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_KindOfActualValue</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"I don't recognise that as a kind"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"such as 'room' or 'door': it would need to be straightforwardly the name "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"of a kind, and not be qualified with adjectives like 'open'."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> = </span><span class="identifier-syntax">KindSubjects::from_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11_6">&#167;11.6</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_6_2" class="paragraph-anchor"></a><b>&#167;11.6.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue a problem message for a disallowed subkind</span><span class="named-paragraph-number">11.6.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_KindOfExotica</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="string-syntax">"you are only allowed to create kinds of objects (things, rooms, and "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"so on) and kinds of 'value'"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"so for example 'colour is a kind of value' is allowed but 'prime is "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"a kind of number' is not."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind_of_what</span><span class="plain-syntax"> = </span><span class="identifier-syntax">KindSubjects::from_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K_value</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11_6">&#167;11.6</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_7" class="paragraph-anchor"></a><b>&#167;11.7.  </b>The following could clearly be improved.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine a pronoun</span><span class="named-paragraph-number">11.7</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">pronoun_usage</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pro</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_pronoun</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pro</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pro</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">pronoun_used</span><span class="plain-syntax"> == </span><span class="identifier-syntax">here_pronoun</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">RELATIONSHIP_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Diagrams::new_PRONOUN</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">), </span><span class="identifier-syntax">pro</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">pro</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">pronoun_used</span><span class="plain-syntax"> == </span><span class="identifier-syntax">implied_pronoun</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">PluginCalls::refine_implicit_noun</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Stock::usage_might_be_singular</span><span class="plain-syntax">(</span><span class="identifier-syntax">pro</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">usage</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><a href="2-ar.html#SP1" class="function-link"><span class="function-syntax">Anaphora::get_current_subject_plurality</span></a><span class="plain-syntax">())) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_EnigmaticThey</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="string-syntax">"I'm unable to handle 'they' here"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"since it looks as if it needs to refer to more than one "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"object here, and that's something I can't manage."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">referent</span><span class="plain-syntax"> = </span><a href="2-ar.html#SP1" class="function-link"><span class="function-syntax">Anaphora::get_current_object</span></a><span class="plain-syntax">();</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">referent</span><span class="plain-syntax">) </span><a href="4-rpt.html#SP1" class="function-link"><span class="function-syntax">Refiner::give_subject_to_noun</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">referent</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_EnigmaticPronoun</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="string-syntax">"I'm not sure what to make of the pronoun here"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"since it is unclear what previously mentioned thing "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"is being referred to. In general, it's best only to use "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"'it' where it's unambiguous, and it may be worth noting "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"that 'they' is not allowed to stand for more than one "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"object at a time."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">PRONOUNS</span><span class="plain-syntax">, </span><span class="string-syntax">"Interpreting 'it' as $j\n$P"</span><span class="plain-syntax">, </span><span class="identifier-syntax">referent</span><span class="plain-syntax">, </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"misconstrued pronoun"</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11">&#167;11</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_8" class="paragraph-anchor"></a><b>&#167;11.8.  </b>The simple description of what happens to a <span class="extract"><span class="extract-syntax">PROPER_NOUN_NT</span></span> node is that
if it's an existing object or value, then it should be annotated with a
reference to that object or value; and if not, then a new object should be
created with that name. (We don't actually create here, though: we just mark
such a noun phrase by changing its node type to <span class="extract"><span class="extract-syntax">CREATED_NT</span></span>.) The more
complicated description is as follows:
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Refine what seems to be a noun phrase</span><span class="named-paragraph-number">11.8</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">PROPER_NOUN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">forbid_nowhere</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_8_1" class="named-paragraph-link"><span class="named-paragraph">Act on any special noun phrases significant to plugins</span><span class="named-paragraph-number">11.8.1</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax"> != </span><span class="constant-syntax">MANDATE_CREATION</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_8_2" class="named-paragraph-link"><span class="named-paragraph">Interpret this as an existing noun if possible</span><span class="named-paragraph-number">11.8.2</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">creation_rule</span><span class="plain-syntax"> != </span><span class="constant-syntax">FORBID_CREATION</span><span class="plain-syntax">) </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">CREATED_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11">&#167;11</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_8_1" class="paragraph-anchor"></a><b>&#167;11.8.1.  </b>For example, "above" and "below" become significant if the mapping feature
is active, and "nowhere" if the spatial one is.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Act on any special noun phrases significant to plugins</span><span class="named-paragraph-number">11.8.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">PluginCalls::act_on_special_NPs</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11_8">&#167;11.8</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_8_2" class="paragraph-anchor"></a><b>&#167;11.8.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Interpret this as an existing noun if possible</span><span class="named-paragraph-number">11.8.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_8_2_1" class="named-paragraph-link"><span class="named-paragraph">Parse the noun phrase as a value property name</span><span class="named-paragraph-number">11.8.2.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_8_2_3" class="named-paragraph-link"><span class="named-paragraph">Parse the noun phrase as a value</span><span class="named-paragraph-number">11.8.2.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">NONLOCAL_VARIABLE_NT</span><span class="plain-syntax">)) ||</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">CONSTANT_NT</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><a href="4-rpt.html#SP1" class="function-link"><span class="function-syntax">Refiner::give_spec_to_noun</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Specifications::is_description</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_8_2_5" class="named-paragraph-link"><span class="named-paragraph">Act on a description used as a noun phrase</span><span class="named-paragraph-number">11.8.2.5</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_8_2_4" class="named-paragraph-link"><span class="named-paragraph">Act on an action pattern used as a noun phrase</span><span class="named-paragraph-number">11.8.2.4</span></a></span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11_8">&#167;11.8</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_8_2_1" class="paragraph-anchor"></a><b>&#167;11.8.2.1.  </b>Perhaps it is the name of a valued property? If so, it is used as a noun,
without obvious reference to any owner: we convert it to a noun node.
</p>

<p class="commentary">(This is the next priority so that "description" will be read as its
property name meaning, not as the name of a kind of value.)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Parse the noun phrase as a value property name</span><span class="named-paragraph-number">11.8.2.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;value-property-name&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::from_property</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11_8_2">&#167;11.8.2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_8_2_2_1" class="paragraph-anchor"></a><b>&#167;11.8.2.2.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue PM_VagueVariable problem</span><span class="named-paragraph-number">11.8.2.2.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_VagueVariable</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="string-syntax">"'variable' is too vague a description"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"because it doesn't say what kind of value should go into the variable. "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"'number variable' or 'a number that varies' - whatever kind of value you "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"need - would be much clearer."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    ==&gt; { </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, - };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11_8_2_2">&#167;11.8.2.2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_8_2_2" class="paragraph-anchor"></a><b>&#167;11.8.2.2.  </b>When a noun phrase in an assertion represents a value, it's normally a
constant ("13") or else something like a description of values ("a number").
It wouldn't make sense to refer to a temporary value like a local variable,
but a global ("player" or "time of day") is possible.
</p>

<p class="commentary">The "action of taking something" syntax is provided as a way of escaping
the usual handling of action patterns; it enables "taking something" to be
a noun instead of a condition testing the current action.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;assertion-np-as-value&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">variable</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_8_2_2_1" class="named-paragraph-link"><span class="named-paragraph">Issue PM_VagueVariable problem</span><span class="named-paragraph-number">11.8.2.2.1</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">action</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">of</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;s-explicit-action&gt;</span><span class="Preform-plain-syntax">   </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { TRUE, RP[1] }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-descriptive-type-expression&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { TRUE, RP[1] }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-global-variable&gt;</span><span class="Preform-plain-syntax">                </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { TRUE, RP[1] }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_8_2_3" class="paragraph-anchor"></a><b>&#167;11.8.2.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Parse the noun phrase as a value</span><span class="named-paragraph-number">11.8.2.3</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;assertion-np-as-value&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;&lt;r&gt;&gt;</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Specifications::new_UNKNOWN</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Descriptions::get_quantifier</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_8_2_3_1" class="named-paragraph-link"><span class="named-paragraph">Check that this noun phrase is allowed a quantifier</span><span class="named-paragraph-number">11.8.2.3.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">NOUN_RESOLUTION</span><span class="plain-syntax">, </span><span class="string-syntax">"Noun phrase %W parsed as value: $P\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">), </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11_8_2">&#167;11.8.2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_8_2_3_1" class="paragraph-anchor"></a><b>&#167;11.8.2.3.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Check that this noun phrase is allowed a quantifier</span><span class="named-paragraph-number">11.8.2.3.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Quantifiers::can_be_used_in_assertions</span><span class="plain-syntax">(</span><span class="identifier-syntax">Descriptions::get_quantifier</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">)) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"$T\nSo $D\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">, </span><span class="identifier-syntax">Specifications::to_proposition</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_ComplexDeterminer</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"complicated determiners are not allowed in assertions"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"so for instance 'More than three people are in the Dining Room' "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"or 'None of the containers is open' will be rejected. Only "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"simple numbers will be allowed, as in examples like 'Three "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"people are in the Dining Room.'"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Descriptions::get_quantifier</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) == </span><span class="identifier-syntax">for_all_quantifier</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Specifications::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">K</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">Descriptions::to_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">Descriptions::number_of_adjectives_applied_to</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) == </span><span class="constant-syntax">0</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">KindSubjects::from_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">EVERY_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_ComplexEvery</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"in an assertion 'every' or 'all' can only be used with a kind"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"so for instance 'A coin is in every container' is all right, "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"because 'container' is a kind, but not 'A coin is in every "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"open container', because 'open container' is now a kind "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"qualified by a property which may come or go during play. "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"(This problem sometimes happens because a thing has been "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"called something like an 'all in one survival kit' - if you "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"need that sort of name, try using 'called' to set it.)"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11_8_2_3">&#167;11.8.2.3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_8_2_4" class="paragraph-anchor"></a><b>&#167;11.8.2.4.  </b>If the noun phrase is a valid action pattern, such as "taking something",
we change it to a new node type to mark this. We don't keep the pattern:
it will be reparsed much later on.
</p>

<p class="commentary">We have to be a little cautious, because of the way English allows participles
as nouns to mean the result of some action having taken place on something &mdash;
consider "the scoring", for instance, in the sense of a mark scored on a
piece of wood. So we parse action patterns with a lower priority than values
here, given that we know we are looking for a noun.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Act on an action pattern used as a noun phrase</span><span class="named-paragraph-number">11.8.2.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    #</span><span class="identifier-syntax">ifdef</span><span class="plain-syntax"> </span><span class="identifier-syntax">IF_MODULE</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::get_article</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;action-pattern&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">ActionsNodes::convert_to_ACTION_node</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    #</span><span class="identifier-syntax">endif</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11_8_2">&#167;11.8.2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_8_2_5" class="paragraph-anchor"></a><b>&#167;11.8.2.5.  </b>This case has been left to last, since it's so much the most difficult.
Descriptions have to be converted into a surprising range of different
subtrees &mdash; otherwise it will not be possible to issue a wide range of
to-the-point problem messages for badly constructed sentences.
</p>

<p class="commentary">Oddly, it's not the complicated descriptions which give trouble...
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Act on a description used as a noun phrase</span><span class="named-paragraph-number">11.8.2.5</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Descriptions::is_complex</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><a href="4-rpt.html#SP1" class="function-link"><span class="function-syntax">Refiner::give_spec_to_noun</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="4-rpt.html#SP11_8_2_5_1" class="named-paragraph-link"><span class="named-paragraph">Act on a simple description</span><span class="named-paragraph-number">11.8.2.5.1</span></a></span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11_8_2">&#167;11.8.2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_8_2_5_1" class="paragraph-anchor"></a><b>&#167;11.8.2.5.1.  </b>...it's the shorter phrases where, perversely, the risk of a
misunderstanding is higher. For one thing, we deliberately ignore a valid
description in two cases:
</p>

<ul class="items"><li>(a) Adjective(s) followed by the name of a specific object.
</li><li>(b) An indefinite article followed by the name of a specific object.
</li></ul>
<p class="commentary">For (a), see the example "Goat-Cheese and Sage Chicken". This contains a
kettle which can be in several states, described adjectivally, and one of
those is "heating". This means the S-parser reads "heating kettle" as if it
meant "the kettle when in the heating state". But we don't want this to be
recognised in an assertion, because it's not useful to talk about individual
objects in particular states when setting up the initial state &mdash; the kettle
either starts out as heating, or it doesn't. Moreover, we don't want to
misread a line like:
</p>

<blockquote>
    <p>Heating Kettle is a scene.</p>
</blockquote>

<p class="commentary">(also a sentence from "Goat-Cheese and Sage Chicken"). Because of this and
similar ambiguities, we ignore the S-parser's recommendation of reading
adjective(s) plus proper noun as a reference to that noun in a special state.
</p>

<p class="commentary">Case (b) comes out of a point of difference between proper and common nouns:
use of an indefinite article is fine with common nouns &mdash; "a container", for
example &mdash; but not with proper nouns: talking about "a silver bar" suggests
that this is not the same silver bar referred to in some previous
sentence.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Act on a simple description</span><span class="named-paragraph-number">11.8.2.5.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (!((</span><span class="identifier-syntax">Descriptions::to_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        ((</span><span class="identifier-syntax">Descriptions::number_of_adjectives_applied_to</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) ||</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">Articles::may_be_definite</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_article</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">)) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)))) {</span>
<span class="plain-syntax">        </span><a href="4-rpt.html#SP7" class="function-link"><span class="function-syntax">Refiner::refine_from_simple_description</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-rpt.html#SP11_8_2_5">&#167;11.8.2.5</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12. About surgeries. </b>The rest of this section is taken up with local surgical operations
performed on the tree in the light of what we can now see.
</p>

<p class="commentary">"And surgery" is a fiddly operation to correct the parse tree after
resolution of all the nouns in a phrase which involves both "and" and
"with" in a particular way. There's no problem with either of these:
</p>

<blockquote>
    <p>In the Pitch are a bat and ball with weight 10.</p>
</blockquote>

<blockquote>
    <p>In the Pitch is a sweater with score for finding 5 and description "White wool."</p>
</blockquote>

<p class="commentary">neither of which is altered by and surgery. The difficulty arises with
</p>

<blockquote>
    <p>In the Pitch is an openable and open door with description "The Hut door."</p>
</blockquote>

<p class="commentary">which, we notice, has exactly the same grammatical structure as the first of
the two sentences above, yet a very different meaning, since "openable" is a
property whereas "bat" was an object. We perform surgery on:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    AND_NT</span>
<span class="plain-syntax">        ADJECTIVE_NT "openable"</span>
<span class="plain-syntax">        WITH_NT</span>
<span class="plain-syntax">            COMMON_NOUN_NT "door"</span>
<span class="plain-syntax">            ADJECTIVE_NT "open"</span>
</pre>
<p class="commentary">to restructure the nodes as:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    WITH_NT</span>
<span class="plain-syntax">        COMMON_NOUN_NT "door"</span>
<span class="plain-syntax">        AND_NT</span>
<span class="plain-syntax">            ADJECTIVE_NT "openable"</span>
<span class="plain-syntax">            ADJECTIVE_NT "open"</span>
</pre>
<p class="commentary">This innocent-looking little function involved drawing a lot of diagrams
on the back of an envelope. Change at your peril.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::perform_and_surgery</span><button class="popup" onclick="togglePopup('usagePopup12')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup12">Usage of <span class="code-font"><span class="function-syntax">Refiner::perform_and_surgery</span></span>:<br/><a href="4-rpt.html#SP11_3">&#167;11.3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">x</span><span class="plain-syntax">, *</span><span class="identifier-syntax">a_p</span><span class="plain-syntax">, *</span><span class="identifier-syntax">w_p</span><span class="plain-syntax">, *</span><span class="identifier-syntax">p1_p</span><span class="plain-syntax">, *</span><span class="identifier-syntax">p2_p</span><span class="plain-syntax">, *</span><span class="identifier-syntax">i_p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">) == </span><span class="identifier-syntax">ADJECTIVE_NT</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        &amp;&amp; (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">) == </span><span class="identifier-syntax">WITH_NT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">a_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">; </span><span class="identifier-syntax">p1_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">; </span><span class="identifier-syntax">w_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">i_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">w_p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">; </span><span class="identifier-syntax">p2_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i_p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">a_p</span><span class="plain-syntax">, </span><span class="identifier-syntax">WITH_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_type_and_clear_annotations</span><span class="plain-syntax">(</span><span class="identifier-syntax">w_p</span><span class="plain-syntax">, </span><span class="identifier-syntax">AND_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">a_p</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">w_p</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">Node::set_subject</span><span class="plain-syntax">(</span><span class="identifier-syntax">w_p</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">x</span><span class="plain-syntax"> = </span><span class="identifier-syntax">a_p</span><span class="plain-syntax">; </span><span class="identifier-syntax">a_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">w_p</span><span class="plain-syntax">; </span><span class="identifier-syntax">w_p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">x</span><span class="plain-syntax">;</span>

<span class="plain-syntax">        </span><span class="identifier-syntax">w_p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">i_p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">i_p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">a_p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">a_p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p1_p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">a_p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p2_p</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13.  </b>"With surgery" is a less traumatic operation, motivated by sentences like:
</p>

<blockquote>
    <p>In the Pitch is an open container with description "The box of stumps and bails."</p>
</blockquote>

<p class="commentary">The initial parse tree for such a sentence will have two nested <span class="extract"><span class="extract-syntax">WITH_NT</span></span>
clauses, which is arguably correct &mdash; "a (container with property open)
with description ..." &mdash; but which is inconvenient for our implementation
of <span class="extract"><span class="extract-syntax">WITH_NT</span></span> later on. So we construe the sentence instead with a single
"with", as "a container with properties open and description ..." In
terms of the tree,
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    WITH_NT</span>
<span class="plain-syntax">        WITH_NT</span>
<span class="plain-syntax">            COMMON_NOUN_NT "container"</span>
<span class="plain-syntax">            ADJECTIVE_NT "open"</span>
<span class="plain-syntax">        PROPERTY_LIST_NT "The box..."</span>
</pre>
<p class="commentary">is reconstructed as:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    WITH_NT</span>
<span class="plain-syntax">        COMMON_NOUN_NT "container"</span>
<span class="plain-syntax">        AND_NT</span>
<span class="plain-syntax">            ADJECTIVE_NT "open"</span>
<span class="plain-syntax">            PROPERTY_LIST_NT "The box..."</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::perform_with_surgery</span><button class="popup" onclick="togglePopup('usagePopup13')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup13">Usage of <span class="code-font"><span class="function-syntax">Refiner::perform_with_surgery</span></span>:<br/><a href="4-rpt.html#SP11_2">&#167;11.2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">inst</span><span class="plain-syntax">, *</span><span class="identifier-syntax">prop_1</span><span class="plain-syntax">, *</span><span class="identifier-syntax">prop_2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">) == </span><span class="identifier-syntax">WITH_NT</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">) == </span><span class="identifier-syntax">WITH_NT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inst</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">prop_1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">prop_2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">inst</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">AND_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">prop_1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">prop_2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP14" class="paragraph-anchor"></a><b>&#167;14. Un-WITH. </b>We may subsequently learn that what appeared to be a property setting was
actually some other noun phrase containing the word "with" &mdash; a particular
issue for sentences like:
</p>

<blockquote>
    <p>The agreeing with policy action has an object called the hat.</p>
</blockquote>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Refiner::un_with</span><button class="popup" onclick="togglePopup('usagePopup14')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup14">Usage of <span class="code-font"><span class="function-syntax">Refiner::un_with</span></span>:<br/><a href="4-rpt.html#SP8">&#167;8</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">) == </span><span class="identifier-syntax">WITH_NT</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Wordings::up_to</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Wordings::last_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">)));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ap</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Lexicon::retrieve</span><span class="plain-syntax">(</span><span class="identifier-syntax">MISCELLANEOUS_MC</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Rvalues::is_CONSTANT_of_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">ap</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_action_name</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Node::set_type_and_clear_annotations</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">UNPARSED_NOUN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="4-nr.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-am.html">1</a></li><li class="progresschapter"><a href="2-bv.html">2</a></li><li class="progresschapter"><a href="3-dlr.html">3</a></li><li class="progresscurrentchapter">4</li><li class="progresssection"><a href="4-nr.html">nr</a></li><li class="progresscurrent">rpt</li><li class="progresssection"><a href="4-tc.html">tc</a></li><li class="progresssection"><a href="4-ass.html">ass</a></li><li class="progresssection"><a href="4-npa.html">npa</a></li><li class="progresssection"><a href="4-pk.html">pk</a></li><li class="progresssection"><a href="4-rk.html">rk</a></li><li class="progresssection"><a href="4-ass2.html">ass2</a></li><li class="progresssection"><a href="4-imp.html">imp</a></li><li class="progresschapter"><a href="5-id.html">5</a></li><li class="progresschapter"><a href="6-rls.html">6</a></li><li class="progresschapter"><a href="7-tc.html">7</a></li><li class="progresschapter"><a href="8-kpr.html">8</a></li><li class="progressnext"><a href="4-tc.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

