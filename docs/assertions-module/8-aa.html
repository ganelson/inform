<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Adjective Ambiguity</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
	tex: {
		inlineMath: '$', '$'], ['\\(', '\\)'
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<script src="http://code.jquery.com/jquery-1.12.4.min.js"
	integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

<script src="../docs-assets/Bigfoot.js"></script>
<link href="../docs-assets/Bigfoot.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../index.html">home</a></li>
</ul><h2>Compiler</h2><ul>
<li><a href="../structure.html">structure</a></li>
<li><a href="../inbuildn.html">inbuild</a></li>
<li><a href="../inform7n.html">inform7</a></li>
<li><a href="../intern.html">inter</a></li>
<li><a href="../services.html">services</a></li>
<li><a href="../secrets.html">secrets</a></li>
</ul><h2>Other Tools</h2><ul>
<li><a href="../inblorbn.html">inblorb</a></li>
<li><a href="../indocn.html">indoc</a></li>
<li><a href="../inform6.html">inform6</a></li>
<li><a href="../inpolicyn.html">inpolicy</a></li>
<li><a href="../inrtpsn.html">inrtps</a></li>
</ul><h2>Resources</h2><ul>
<li><a href="../extensions.html">extensions</a></li>
<li><a href="../kits.html">kits</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=18> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="../../../inweb/docs/index.html">inweb</a></li>
<li><a href="../../../intest/docs/index.html">intest</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Adjective Ambiguity' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../inform7n.html">Inform7</a></li><li><a href="index.html">assertions</a></li><li><a href="index.html#8">Chapter 8: Predicates</a></li><li><b>Adjective Ambiguity</b></li></ul></div>
<p class="purpose">Managing the multiple contextual meanings which a single adjective can have.</p>

<ul class="toc"><li><a href="8-aa.html#SP7">&#167;7. Sorting lists of meanings</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1.  </b>Adjectives can have multiple meanings. For example, it is legal to define
both of these in the same source text:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">Definition</span><span class="plain-syntax">: </span><span class="identifier-syntax">a</span><span class="plain-syntax"> </span><span class="identifier-syntax">text</span><span class="plain-syntax"> </span><span class="identifier-syntax">is</span><span class="plain-syntax"> </span><span class="identifier-syntax">empty</span><span class="plain-syntax"> </span><span class="identifier-syntax">rather</span><span class="plain-syntax"> </span><span class="identifier-syntax">than</span><span class="plain-syntax"> </span><span class="identifier-syntax">non</span><span class="plain-syntax">-</span><span class="identifier-syntax">empty</span><span class="plain-syntax"> </span><span class="identifier-syntax">if</span><span class="plain-syntax"> </span><span class="identifier-syntax">it</span><span class="plain-syntax"> </span><span class="identifier-syntax">is</span><span class="plain-syntax"> </span><span class="string-syntax">""</span><span class="plain-syntax">.</span>

<span class="identifier-syntax">Definition</span><span class="plain-syntax">: </span><span class="identifier-syntax">a</span><span class="plain-syntax"> </span><span class="identifier-syntax">table</span><span class="plain-syntax"> </span><span class="identifier-syntax">name</span><span class="plain-syntax"> </span><span class="identifier-syntax">is</span><span class="plain-syntax"> </span><span class="identifier-syntax">empty</span><span class="plain-syntax"> </span><span class="identifier-syntax">rather</span><span class="plain-syntax"> </span><span class="identifier-syntax">than</span><span class="plain-syntax"> </span><span class="identifier-syntax">non</span><span class="plain-syntax">-</span><span class="identifier-syntax">empty</span><span class="plain-syntax"> </span><span class="identifier-syntax">if</span><span class="plain-syntax"> </span><span class="identifier-syntax">the</span>
<span class="identifier-syntax">number</span><span class="plain-syntax"> </span><span class="identifier-syntax">of</span><span class="plain-syntax"> </span><span class="identifier-syntax">filled</span><span class="plain-syntax"> </span><span class="identifier-syntax">rows</span><span class="plain-syntax"> </span><span class="identifier-syntax">in</span><span class="plain-syntax"> </span><span class="identifier-syntax">it</span><span class="plain-syntax"> </span><span class="identifier-syntax">is</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span><span class="plain-syntax">.</span>
</pre>
<p class="commentary">This gives two different meanings to both "empty" and "non-empty". We can
only work out which meaning is intended by looking at the context, that is,
at the kind of whatever it is applied to. For a text, the first sense applies,
and for a table name, the second.
</p>

<p class="commentary">So, then, every adjective has the following data attached to it:
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">ADJECTIVE_MEANING_LINGUISTICS_CALLBACK</span><span class="plain-syntax"> </span><a href="8-aa.html#SP1" class="function-link"><span class="function-syntax">AdjectiveAmbiguity::new_set</span></a>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">adjective_meaning_data</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">linked_list</span><span class="plain-syntax"> *</span><span class="identifier-syntax">in_defn_order</span><span class="plain-syntax">; </span><span class="comment-syntax"> of </span><span class="extract"><span class="extract-syntax">adjective_meaning</span></span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">linked_list</span><span class="plain-syntax"> *</span><span class="identifier-syntax">in_precedence_order</span><span class="plain-syntax">; </span><span class="comment-syntax"> of </span><span class="extract"><span class="extract-syntax">adjective_meaning</span></span>
<span class="plain-syntax">} </span><span class="reserved-syntax">adjective_meaning_data</span><span class="plain-syntax">;</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveAmbiguity::new_set</span><span class="plain-syntax">(</span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adj</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_defn_order</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NEW_LINKED_LIST</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_precedence_order</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NEW_LINKED_LIST</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure adjective_meaning_data is accessed in 8/amd and here.</li></ul>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2.  </b>The following assigns a new meaning to a given word range: we find the
appropriate APH (creating if necessary) and then add the new meaning to the
end of its unsorted meaning list.
</p>

<p class="commentary">We eventually need to sort this list of definitions into logical priority
order &mdash; so that a definition applying to just Count Dracula precedes one
applying to men, which in turn precedes one applying to things. (Priority
order is irrelevant when two senses apply to domains with no overlap, as
in the case of texts and table names.) It's convenient and costs little
memory to keep the sorted list as a second linked list.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveAmbiguity::add_meaning_to_adjective</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">AdjectiveAmbiguity::add_meaning_to_adjective</span></span>:<br/>Adjectival Definition Family - <a href="5-adf.html#SP9_3">&#167;9.3</a><br/>Adjectives by Phrase - <a href="8-abp.html#SP1">&#167;1</a><br/>Adjectives by Condition - <a href="8-abc.html#SP2">&#167;2</a><br/>Adjectives by Inter Function - <a href="8-abif.html#SP2">&#167;2</a><br/>Adjectives by Inter Condition - <a href="8-abic.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adj</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">ADD_TO_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">, </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_defn_order</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">owning_adjective</span><span class="plain-syntax"> = </span><span class="identifier-syntax">adj</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">adj</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3.  </b>And here we log the unsorted list.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveAmbiguity::log</span><span class="plain-syntax">(</span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adj</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">adj</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) { </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"&lt;null-APH&gt;\n"</span><span class="plain-syntax">); </span><span class="reserved-syntax">return</span><span class="plain-syntax">; }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">n</span><span class="plain-syntax"> = </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">, </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_defn_order</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"%d: %W "</span><span class="plain-syntax">, </span><span class="identifier-syntax">n</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">indexing_text</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><a href="8-amd.html#SP1" class="function-link"><span class="function-syntax">AdjectiveMeaningDomains::log</span></a><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">n</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4.  </b>If the source tries to apply the word "open", say, to a given value or
object \(X\), when does that make sense?
</p>

<p class="commentary">We can only find out by checking every possible meaning of "open" to see
if it can accommodate the kind of value of \(X\). But this time we use weak
checking, and make it weaker still since a null kind is taken to mean "any
object", either in the AM's definition &mdash; which can happen if we are very
early in Inform's run &mdash; or because the caller doesn't actually know the
kind of value of \(X\). (In other words, adjectives tend to assume they apply
to objects rather than other values.) This means we will accept some
logically impossible outcomes &mdash; we would say that it's acceptable to apply
"open" to an animal, say &mdash; but that is actually a good thing. It means
that "list of open things" or "something open" are allowed. Source text
such as:
</p>

<blockquote>
    <p>The labrador puppy is an open animal.</p>
</blockquote>

<p class="commentary">will successfully parse, but then result in higher-level problem messages.
The following does compile:
</p>

<blockquote>
    <p>now the labrador puppy is open;</p>
</blockquote>

<p class="commentary">but results in a run-time problem message when it executes.
</p>

<p class="commentary">It makes no difference what order we check the AMs in, so we can use the
unsorted list, which is helpful since we may need to call this routine
early in the run when sorting cannot yet be done.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveAmbiguity::can_be_applied_to</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">AdjectiveAmbiguity::can_be_applied_to</span></span>:<br/>The Adjectival Predicates - <a href="8-tap.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adj</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">adj</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOOP_OVER_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">, </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_defn_order</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="8-amd.html#SP5" class="function-link"><span class="function-syntax">AdjectiveMeaningDomains::determine_avoiding_circularity</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am_kind</span><span class="plain-syntax"> = </span><a href="8-amd.html#SP7" class="function-link"><span class="function-syntax">AdjectiveMeaningDomains::get_kind</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">am_kind</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">K</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">K</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Kinds::Behaviour::is_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">                    (</span><span class="identifier-syntax">Kinds::compatible</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">, </span><span class="identifier-syntax">am_kind</span><span class="plain-syntax">) == </span><span class="identifier-syntax">ALWAYS_MATCH</span><span class="plain-syntax">))</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5.  </b>Does a given adjective have any interpretation as an enumerated property
value, or an either/or property? If so we return the earliest known.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveAmbiguity::has_enumerative_meaning</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">AdjectiveAmbiguity::has_enumerative_meaning</span></span>:<br/>Refine Parse Tree - <a href="4-rpt.html#SP6">&#167;6</a><br/>Assertions - <a href="4-ass.html#SP6_3_13">&#167;6.3.13</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adj</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">, </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_defn_order</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">InstanceAdjectives::is_enumerative</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">RETRIEVE_POINTER_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family_specific_data</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveAmbiguity::has_either_or_property_meaning</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">AdjectiveAmbiguity::has_either_or_property_meaning</span></span>:<br/>Implications - <a href="4-imp.html#SP3_2_3">&#167;3.2.3</a>, <a href="4-imp.html#SP6_1">&#167;6.1</a><br/>The Adjectival Predicates - <a href="8-tap.html#SP3">&#167;3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adj</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sense</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">adj</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOOP_OVER_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">, </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_defn_order</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">EitherOrPropertyAdjectives::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">sense</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">negated_from</span><span class="plain-syntax">) *</span><span class="identifier-syntax">sense</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sense</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">RETRIEVE_POINTER_property</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">family_specific_data</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6.  </b>Occasionally we just want one meaning:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveAmbiguity::first_meaning</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">AdjectiveAmbiguity::first_meaning</span></span>:<br/>The Adjectival Predicates - <a href="8-tap.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adj</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">adj</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FIRST_IN_LINKED_LIST</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_defn_order</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7. Sorting lists of meanings. </b>After meanings have been declared, a typical APH will have a disordered
"possible meaning" list and an empty "sorted meaning" list. The following
insertion-sorts<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> the possibles list into the sorted list.
</p>

<ul class="footnotetexts"><li class="footnote" id="fn:1"><p class="inwebfootnote"><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> Well, yes, but these are very short lists, typically 5 items or fewer.
<a href="#fnref:1" title="return to text"> &#x21A9;</a></p></li></ul>
<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveAmbiguity::sort</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">AdjectiveAmbiguity::sort</span></span>:<br/><a href="8-aa.html#SP8">&#167;8</a>, <a href="8-aa.html#SP9">&#167;9</a><br/>Adjective Meaning Domains - <a href="8-amd.html#SP4">&#167;4</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adj</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">adj</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"tried to sort meanings for null adjective"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">, </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_defn_order</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><a href="8-amd.html#SP4" class="function-link"><span class="function-syntax">AdjectiveMeaningDomains::determine_if_possible</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LinkedLists::empty</span><span class="plain-syntax">(</span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_precedence_order</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">, </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_defn_order</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am2</span><span class="plain-syntax">; </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">pos</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOOP_OVER_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">am2</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_precedence_order</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="8-aa.html#SP7" class="function-link"><span class="function-syntax">AdjectiveAmbiguity::cmp</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">am2</span><span class="plain-syntax">) == </span><span class="constant-syntax">1</span><span class="plain-syntax">) </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">pos</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LinkedLists::insert</span><span class="plain-syntax">(</span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_precedence_order</span><span class="plain-syntax">, </span><span class="identifier-syntax">pos</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveAmbiguity::cmp</span><span class="plain-syntax">(</span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am1</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am2</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am1</span><span class="plain-syntax"> == </span><span class="identifier-syntax">am2</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">d</span><span class="plain-syntax"> = </span><a href="8-amd.html#SP10" class="function-link"><span class="function-syntax">AdjectiveMeaningDomains::cmp</span></a><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain</span><span class="plain-syntax">), &amp;(</span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">d</span><span class="plain-syntax"> != </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">d</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain</span><span class="plain-syntax">.</span><span class="element-syntax">domain_infs</span><span class="plain-syntax"> == </span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">domain</span><span class="plain-syntax">.</span><span class="element-syntax">domain_infs</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="8-aa.html#SP7_1" class="named-paragraph-link"><span class="named-paragraph">Worry about definitions of the same adjective on the same domain</span><span class="named-paragraph-number">7.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">allocation_id</span><span class="plain-syntax"> - </span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">allocation_id</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7_1" class="paragraph-anchor"></a><b>&#167;7.1.  </b>In general, it's an error to define the same adjective on the same domain
twice, except for a redefinition in the source text of a definition in an
extension. (We exclude enumerative adjectives because they are defined
internally by a method which involves occasional duplication but where
the duplicates are all mutually consistent; these do not arise from the
author's source text.)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Worry about definitions of the same adjective on the same domain</span><span class="named-paragraph-number">7.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">))) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">))) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">InstanceAdjectives::is_enumerative</span><span class="plain-syntax">(</span><span class="identifier-syntax">am1</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">InstanceAdjectives::is_enumerative</span><span class="plain-syntax">(</span><span class="identifier-syntax">am2</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inform_extension</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ef1</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Extensions::corresponding_to</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Lexer::file_of_origin</span><span class="plain-syntax">(</span><span class="identifier-syntax">Wordings::first_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">))));</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inform_extension</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ef2</span><span class="plain-syntax"> =</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Extensions::corresponding_to</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Lexer::file_of_origin</span><span class="plain-syntax">(</span><span class="identifier-syntax">Wordings::first_wn</span><span class="plain-syntax">(</span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">))));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">ef1</span><span class="plain-syntax"> == </span><span class="identifier-syntax">ef2</span><span class="plain-syntax">) || ((</span><span class="identifier-syntax">ef1</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">ef2</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax"> = </span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">defined_at</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Problems::quote_wording_as_source</span><span class="plain-syntax">(1, </span><span class="identifier-syntax">am1</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">indexing_text</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Problems::quote_wording_as_source</span><span class="plain-syntax">(2, </span><span class="identifier-syntax">am2</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">indexing_text</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::handmade_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(),</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_AdjDomainDuplicated</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Problems::issue_problem_segment</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                </span><span class="string-syntax">"The definitions %1 and %2 both try to cover the same situation: "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"the same adjective applied to the exact same range. %P"</span>
<span class="plain-syntax">                </span><span class="string-syntax">"It's okay to override a definition in an extension with another "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"one in the main source text, but it's not okay to define the same "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"adjective twice over the same domain in the same file."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">Problems::issue_problem_end</span><span class="plain-syntax">();</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ef1</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ef2</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> -1;</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="8-aa.html#SP7">&#167;7</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8.  </b>With that sorting done, we can begin to use an adjective. Suppose there has
been an assertion sentence like this:
</p>

<blockquote>
    <p>The ormolu clock is fixed in place.</p>
</blockquote>

<p class="commentary">"Fixed in place" is identified as an adjective, <span class="extract"><span class="extract-syntax">adj</span></span>; the "ormulo clock" is
what it applies to, stored in either <span class="extract"><span class="extract-syntax">infs_to_assert_on</span></span>. <span class="extract"><span class="extract-syntax">kind_domain</span></span> is what
kind we think this has. <span class="extract"><span class="extract-syntax">parity</span></span> is equal to <span class="extract"><span class="extract-syntax">TRUE</span></span>.
</p>

<p class="commentary">What happens is that the list of definitions for "fixed in place" is checked
in logical precedence order, and <a href="8-am.html#SP10" class="internal">AdjectiveMeanings::assert</a> called
on any kind which the "ormolu clock" matches. (That will probably be the
definition for the "fixed in place" either/or property for things, unless
someone has given the adjective some special meaning unique to the clock.) The
first adjective meaning to be assertable then wins.
</p>

<p class="commentary">The following routine therefore acts as a junction-box, deciding which sense
of the adjective is to be applied. We return <span class="extract"><span class="extract-syntax">TRUE</span></span> if we were able to find a
definition which could be asserted and which the clock matched, and <span class="extract"><span class="extract-syntax">FALSE</span></span> if
there was no definition which applied, or if none of those which did could be
asserted for it.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">AdjectiveAmbiguity::assert</span><button class="popup" onclick="togglePopup('usagePopup7')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup7">Usage of <span class="code-font"><span class="function-syntax">AdjectiveAmbiguity::assert</span></span>:<br/>The Adjectival Predicates - <a href="8-tap.html#SP3">&#167;3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adj</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">kind_domain</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs_to_assert_on</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">val_to_assert_on</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">parity</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="8-aa.html#SP7" class="function-link"><span class="function-syntax">AdjectiveAmbiguity::sort</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">adj</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">, </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_precedence_order</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="8-amd.html#SP9" class="function-link"><span class="function-syntax">AdjectiveMeaningDomains::strong_match</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">kind_domain</span><span class="plain-syntax">, </span><span class="identifier-syntax">infs_to_assert_on</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="8-am.html#SP10" class="function-link"><span class="function-syntax">AdjectiveMeanings::assert</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">infs_to_assert_on</span><span class="plain-syntax">, </span><span class="identifier-syntax">parity</span><span class="plain-syntax">))</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9.  </b>Similarly, the following produces an I6 schema to carry out a task for the
adjective. (See <a href="8-am.html#SP6" class="internal">AdjectiveMeanings::make_schema</a> for tasks.)
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="function-syntax">AdjectiveAmbiguity::schema_for_task</span><button class="popup" onclick="togglePopup('usagePopup8')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup8">Usage of <span class="code-font"><span class="function-syntax">AdjectiveAmbiguity::schema_for_task</span></span>:<br/>The Adjectival Predicates - <a href="8-tap.html#SP3">&#167;3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">adjective</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adj</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">kind_domain</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">T</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">kind_domain</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">kind_domain</span><span class="plain-syntax"> = </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><a href="8-aa.html#SP7" class="function-link"><span class="function-syntax">AdjectiveAmbiguity::sort</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">adj</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax"> *</span><span class="identifier-syntax">am</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_LINKED_LIST</span><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="reserved-syntax">adjective_meaning</span><span class="plain-syntax">, </span><span class="identifier-syntax">adj</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">adjective_meanings</span><span class="plain-syntax">.</span><span class="element-syntax">in_precedence_order</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><a href="8-amd.html#SP4" class="function-link"><span class="function-syntax">AdjectiveMeaningDomains::determine</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="8-amd.html#SP9" class="function-link"><span class="function-syntax">AdjectiveMeaningDomains::weak_match</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">kind_domain</span><span class="plain-syntax">, </span><span class="identifier-syntax">am</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">continue</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">i6s</span><span class="plain-syntax"> = </span><a href="8-am.html#SP7" class="function-link"><span class="function-syntax">AdjectiveMeanings::get_schema</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">am</span><span class="plain-syntax">, </span><span class="identifier-syntax">T</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">i6s</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">i6s</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="8-lr.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-am.html">1</a></li><li class="progresschapter"><a href="2-bv.html">2</a></li><li class="progresschapter"><a href="3-dlr.html">3</a></li><li class="progresschapter"><a href="4-nr.html">4</a></li><li class="progresschapter"><a href="5-id.html">5</a></li><li class="progresschapter"><a href="6-rls.html">6</a></li><li class="progresschapter"><a href="7-tc.html">7</a></li><li class="progresscurrentchapter">8</li><li class="progresssection"><a href="8-kpr.html">kpr</a></li><li class="progresssection"><a href="8-tap.html">tap</a></li><li class="progresssection"><a href="8-tcp.html">tcp</a></li><li class="progresssection"><a href="8-terr.html">terr</a></li><li class="progresssection"><a href="8-qr.html">qr</a></li><li class="progresssection"><a href="8-tur.html">tur</a></li><li class="progresssection"><a href="8-er.html">er</a></li><li class="progresssection"><a href="8-lr.html">lr</a></li><li class="progresscurrent">aa</li><li class="progresssection"><a href="8-am.html">am</a></li><li class="progresssection"><a href="8-amd.html">amd</a></li><li class="progresssection"><a href="8-abp.html">abp</a></li><li class="progresssection"><a href="8-abc.html">abc</a></li><li class="progresssection"><a href="8-abif.html">abif</a></li><li class="progresssection"><a href="8-abic.html">abic</a></li><li class="progresssection"><a href="8-cu.html">cu</a></li><li class="progressnext"><a href="8-am.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

